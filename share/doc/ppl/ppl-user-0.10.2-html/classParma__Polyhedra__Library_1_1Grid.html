<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PPL: Parma_Polyhedra_Library::Grid Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::Grid Class Reference<br>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::Grid" -->A grid.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ppl.hh&gt;</code>
<p>

<p>
<a href="classParma__Polyhedra__Library_1_1Grid-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="092f5c04d267ab5709dda2d3e51aaeb9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::coefficient_type" ref="092f5c04d267ab5709dda2d3e51aaeb9" args="" -->
typedef <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#092f5c04d267ab5709dda2d3e51aaeb9">coefficient_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The numeric type of coefficients. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c">Grid</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions=0, <a class="el" href="group__PPL__CXX__interface.html#g616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind=UNIVERSE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid having the specified properties.  <a href="#0262a2b32220536d8bc60d84ad8dac4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#727dc2405cfc5f2252e6f21aa0f18074">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid, copying a system of congruences.  <a href="#727dc2405cfc5f2252e6f21aa0f18074"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#31603d81a2b0571a82c4c79b8c6e4564">Grid</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid, recycling a system of congruences.  <a href="#31603d81a2b0571a82c4c79b8c6e4564"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#0c02302b6281fa91ef9275bd37e43efc">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid, copying a system of constraints.  <a href="#0c02302b6281fa91ef9275bd37e43efc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#527ffa31e1581a8beb83a832244dada8">Grid</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid, recycling a system of constraints.  <a href="#527ffa31e1581a8beb83a832244dada8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#732d3b59f8a0ba21a72877d5fa4b98a5">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;const_gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid, copying a system of grid generators.  <a href="#732d3b59f8a0ba21a72877d5fa4b98a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#1ba0bd59426889233904d052224cab76">Grid</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;gs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid, recycling a system of grid generators.  <a href="#1ba0bd59426889233904d052224cab76"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#19623ff8cea2239d66331f29c1d0268d">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid out of a box.  <a href="#19623ff8cea2239d66331f29c1d0268d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#470e6a581b91bc6d5a4a6388d1ddde99">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;bd, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid out of a bounded-difference shape.  <a href="#470e6a581b91bc6d5a4a6388d1ddde99"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#df002bbcc4dcae5efdb56bae2971a64b">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;os, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid out of an octagonal shape.  <a href="#df002bbcc4dcae5efdb56bae2971a64b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Box &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#f306aa1f4e34bf045cd07e5ac11d8f68">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;box, <a class="el" href="structParma__Polyhedra__Library_1_1From__Covering__Box.html">From_Covering_Box</a> dummy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid out of a generic, interval-based covering box.  <a href="#f306aa1f4e34bf045cd07e5ac11d8f68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#36cc3783cdc92ab5fc69904c298ed12c">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid from a polyhedron using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the grid built is the smallest one containing <code>ph</code>.  <a href="#36cc3783cdc92ab5fc69904c298ed12c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a28d735beef86789b73b41dbbde71abf">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy-constructor.  <a href="#a28d735beef86789b73b41dbbde71abf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1ba97c180500b43954b09532151f6c9d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::operator=" ref="1ba97c180500b43954b09532151f6c9d" args="(const Grid &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#1ba97c180500b43954b09532151f6c9d">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The assignment operator. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the Grid</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fc06f600e94b7bedb91d0371a51f4c38"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::space_dimension" ref="fc06f600e94b7bedb91d0371a51f4c38" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#fc06f600e94b7bedb91d0371a51f4c38">space_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="90ca2b1613fda31a2ac7e79d9388680d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::affine_dimension" ref="90ca2b1613fda31a2ac7e79d9388680d" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#90ca2b1613fda31a2ac7e79d9388680d">affine_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <img class="formulaInl" alt="$0$" src="form_562.png">, if <code>*this</code> is empty; otherwise, returns the <a class="el" href="main.html#Grid_Affine_Dimension">affine dimension</a> of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="53b24395ac61f8b2b2accc5a3900bf69"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::constraints" ref="53b24395ac61f8b2b2accc5a3900bf69" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#53b24395ac61f8b2b2accc5a3900bf69">constraints</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of equality constraints satisfied by <code>*this</code> with the same affine dimension as <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="880344de195aef75a6b3f2a4db4787b4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::minimized_constraints" ref="880344de195aef75a6b3f2a4db4787b4" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#880344de195aef75a6b3f2a4db4787b4">minimized_constraints</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a minimal system of equality constraints satisfied by <code>*this</code> with the same affine dimension as <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8688fd38682b19e97422816d72524790"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::congruences" ref="8688fd38682b19e97422816d72524790" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#8688fd38682b19e97422816d72524790">congruences</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of congruences. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="453e51570268eb4d63fc529130a54440"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::minimized_congruences" ref="453e51570268eb4d63fc529130a54440" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#453e51570268eb4d63fc529130a54440">minimized_congruences</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of congruences in minimal form. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8865893c48cc07adae5dca6b35081751"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::grid_generators" ref="8865893c48cc07adae5dca6b35081751" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#8865893c48cc07adae5dca6b35081751">grid_generators</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of generators. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ae1850664122e9917f174d10fd3bf06"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::minimized_grid_generators" ref="6ae1850664122e9917f174d10fd3bf06" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#6ae1850664122e9917f174d10fd3bf06">minimized_grid_generators</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the minimized system of generators. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d14942b33fb82bb3e6a13e5e92ada475"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::relation_with" ref="d14942b33fb82bb3e6a13e5e92ada475" args="(const Congruence &amp;cg) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#d14942b33fb82bb3e6a13e5e92ada475">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>cg</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="803035024ab9670971868f4b1092f7c5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::relation_with" ref="803035024ab9670971868f4b1092f7c5" args="(const Grid_Generator &amp;g) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#803035024ab9670971868f4b1092f7c5">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html">Grid_Generator</a> &amp;g) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>g</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f703ba611b9e5ff613f4df35347ee95"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::relation_with" ref="6f703ba611b9e5ff613f4df35347ee95" args="(const Generator &amp;g) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#6f703ba611b9e5ff613f4df35347ee95">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>g</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce98c3e57a1237e6dd5042b5a0919193"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::relation_with" ref="ce98c3e57a1237e6dd5042b5a0919193" args="(const Constraint &amp;c) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ce98c3e57a1237e6dd5042b5a0919193">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>c</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2f31170286d3abc2f4867d0b193ae8bc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::is_empty" ref="2f31170286d3abc2f4867d0b193ae8bc" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#2f31170286d3abc2f4867d0b193ae8bc">is_empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an empty grid. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="59634a195948ff0617177d0a41e30602"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::is_universe" ref="59634a195948ff0617177d0a41e30602" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#59634a195948ff0617177d0a41e30602">is_universe</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a universe grid. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#dc7cdee1981f44b5db23f6c28c79d0a6">is_topologically_closed</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a topologically closed subset of the vector space.  <a href="#dc7cdee1981f44b5db23f6c28c79d0a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#621d377682c2c67051c24b1cc8a03497">is_disjoint_from</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint.  <a href="#621d377682c2c67051c24b1cc8a03497"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#2528b5f433e743dda827b1028b6c74cd">is_discrete</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is discrete.  <a href="#2528b5f433e743dda827b1028b6c74cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a5606b64a035977b9d76b1932227246"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::is_bounded" ref="1a5606b64a035977b9d76b1932227246" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#1a5606b64a035977b9d76b1932227246">is_bounded</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is bounded. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0047a6aa4f26d9133b9d741f68384f38"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::contains_integer_point" ref="0047a6aa4f26d9133b9d741f68384f38" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#0047a6aa4f26d9133b9d741f68384f38">contains_integer_point</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains at least one integer point. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#3ac47497148e61f3d7a3da09d17a03bf">constrains</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>.  <a href="#3ac47497148e61f3d7a3da09d17a03bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a033cfca735240b3699b523d60ad692a">bounds_from_above</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>.  <a href="#a033cfca735240b3699b523d60ad692a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#fde364ce088f82cf2b9a231e7d9f2abc">bounds_from_below</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>.  <a href="#fde364ce088f82cf2b9a231e7d9f2abc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#042613c3f4ad30b298d70143c935d7cd">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed.  <a href="#042613c3f4ad30b298d70143c935d7cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#8fa02815bb561135934f91c9adcd0cb5">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;point) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed.  <a href="#8fa02815bb561135934f91c9adcd0cb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#0d8ed7a0e48fe76e7221842c780192b0">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed.  <a href="#0d8ed7a0e48fe76e7221842c780192b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#53f980fb1ac8fa21265bec985bd1382f">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;point) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed.  <a href="#53f980fb1ac8fa21265bec985bd1382f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#d743f8b71eb68f6b41f7ea7b5d21dc22">contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>.  <a href="#d743f8b71eb68f6b41f7ea7b5d21dc22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#8d2cc5d18d050975101f2860f2919da8">strictly_contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>.  <a href="#8d2cc5d18d050975101f2860f2919da8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#87e253a2b1d8e1696c2ebf3feb11dc5f">get_covering_box</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the covering box for <code>*this</code> into <code>box</code>.  <a href="#87e253a2b1d8e1696c2ebf3feb11dc5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#8edc85ba3e8a09593959814eaad72499">OK</a> (bool check_not_empty=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if all the invariants are satisfied.  <a href="#8edc85ba3e8a09593959814eaad72499"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Space Dimension Preserving Member Functions that May Modify the Grid</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#1287b254a91451368e7e2e456f448114">add_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of congruence <code>cg</code> to <code>*this</code>.  <a href="#1287b254a91451368e7e2e456f448114"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ccb5584441a7c7c84de73810cc6afbc4">add_congruence_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of congruence <code>cg</code> to the system of congruences of <code>this</code>, reducing the result.  <a href="#ccb5584441a7c7c84de73810cc6afbc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#d09e4e3f9a9da562c6cdb73dd7b47fbe">add_grid_generator</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html">Grid_Generator</a> &amp;g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of grid generator <code>g</code> to the system of generators of <code>*this</code>.  <a href="#d09e4e3f9a9da562c6cdb73dd7b47fbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#880be9febc6dab2cdccbec8814c9a952">add_grid_generator_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html">Grid_Generator</a> &amp;g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of grid generator <code>g</code> to the system of generators of <code>*this</code>, reducing the result.  <a href="#880be9febc6dab2cdccbec8814c9a952"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a26f672c32271db69ed68fc60eee8cff">add_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of each congruence in <code>cgs</code> to <code>*this</code>.  <a href="#a26f672c32271db69ed68fc60eee8cff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#85b2560352485ac05d10aab0ee483252">add_recycled_congruences</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the congruences in <code>cgs</code> to *this.  <a href="#85b2560352485ac05d10aab0ee483252"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#726484f44f6e6653f9c0126e94e51ab0">add_congruences_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the congruences in <code>cgs</code> to the system of congruences of <code>*this</code>, reducing the result.  <a href="#726484f44f6e6653f9c0126e94e51ab0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#c587faeb0edfd2582564b9a8fa3335bd">add_recycled_congruences_and_minimize</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the congruences in <code>cgs</code> to the system of congruences of <code>this</code>, reducing the result.  <a href="#c587faeb0edfd2582564b9a8fa3335bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#9e87405c740d202951ba788f9e52cbf7">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> a congruence equivalent to constraint <code>c</code>.  <a href="#9e87405c740d202951ba788f9e52cbf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#fa7b390fb34934e419263a5fc694c946">add_constraint_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> a congruence equivalent to constraint <code>c</code>, also minimizing the result.  <a href="#fa7b390fb34934e419263a5fc694c946"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#943c42b0d1b3580e54b3ab60aa55255f">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> congruences equivalent to the constraints in <code>cs</code>.  <a href="#943c42b0d1b3580e54b3ab60aa55255f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#7704df6970b9563ef9e51793126c0ae2">add_constraints_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> congruences equivalent to the constraints in <code>cs</code>, minimizing the result.  <a href="#7704df6970b9563ef9e51793126c0ae2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#145cc7c23d407576222e5af347f401c1">add_recycled_constraints</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> congruences equivalent to the constraints in <code>cs</code>.  <a href="#145cc7c23d407576222e5af347f401c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#2a66994a33d910d0fe8daccc6cc017ed">add_recycled_constraints_and_minimize</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> congruences equivalent to the constraints in <code>cs</code>, minimizing the result.  <a href="#2a66994a33d910d0fe8daccc6cc017ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#953a608f6f9d413870fb3eee5cc6ad1e">refine_with_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the congruence <code>cg</code> to refine <code>*this</code>.  <a href="#953a608f6f9d413870fb3eee5cc6ad1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#f1ab967a6606266f7e583fc9752667fe">refine_with_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the congruences in <code>cgs</code> to refine <code>*this</code>.  <a href="#f1ab967a6606266f7e583fc9752667fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#82b76e3f18679ea161b53bfa80349009">refine_with_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the constraint <code>c</code> to refine <code>*this</code>.  <a href="#82b76e3f18679ea161b53bfa80349009"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#8f97dbc7a7c307fa72f7e904b2cbf21b">refine_with_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the constraints in <code>cs</code> to refine <code>*this</code>.  <a href="#8f97dbc7a7c307fa72f7e904b2cbf21b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#19422844125a988daaf489cbaff3835b">add_grid_generators</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the generators in <code>gs</code> to the system of generators of <code>*this</code>.  <a href="#19422844125a988daaf489cbaff3835b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#214e376adb9dc271c61b58f8b2c927f0">add_recycled_grid_generators</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the generators in <code>gs</code> to the system of generators of <code>this</code>.  <a href="#214e376adb9dc271c61b58f8b2c927f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#1522764599cd8547bfe4ef7e88d8baec">add_grid_generators_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the generators in <code>gs</code> to the system of generators of <code>*this</code>, reducing the result.  <a href="#1522764599cd8547bfe4ef7e88d8baec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#4d6e94fc9839cd5d455f195f46fc2dcf">add_recycled_grid_generators_and_minimize</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the generators in <code>gs</code> to the system of generators of <code>this</code>, reducing the result.  <a href="#4d6e94fc9839cd5d455f195f46fc2dcf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#e5dc5003b3652660bc4ff4a15e4060af">unconstrain</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>.  <a href="#e5dc5003b3652660bc4ff4a15e4060af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#26f845c3192c71f59cf1c81cd35072c5">unconstrain</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_unconstrained)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>to_be_unconstrained</code>, assigning the result to <code>*this</code>.  <a href="#26f845c3192c71f59cf1c81cd35072c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#c9d9eaf8b76024bc20ce524e13bf86a6">intersection_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>.  <a href="#c9d9eaf8b76024bc20ce524e13bf86a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#59af9a947f610641fe02639f76cfc90e">intersection_assign_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>, reducing the result.  <a href="#59af9a947f610641fe02639f76cfc90e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#9831db06919c6ee05360b08e84cccbb7">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the least upper bound of <code>*this</code> and <code>y</code>.  <a href="#9831db06919c6ee05360b08e84cccbb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#901082d5c6de5ec4b457df69e41bb70c">upper_bound_assign_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the least upper bound of <code>*this</code> and <code>y</code>, reducing the result.  <a href="#901082d5c6de5ec4b457df69e41bb70c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#68665d093308c111817eca341b98d70a">upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the upper bound of <code>*this</code> and <code>y</code> is exact it is assigned to <code>this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned.  <a href="#68665d093308c111817eca341b98d70a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#e5955a311fc4fde1edf2d5460f0a8356">difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Grid_Difference">grid-difference</a> of <code>*this</code> and <code>y</code>.  <a href="#e5955a311fc4fde1edf2d5460f0a8356"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#071aa57e439ba4f358c7fd43b03a6a49">simplify_using_context_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty.  <a href="#071aa57e439ba4f358c7fd43b03a6a49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#bb10ea556dd34e0c1e13f7e99b9efe70">affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Grid_Affine_Transformation">affine image</a> of <code>this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#bb10ea556dd34e0c1e13f7e99b9efe70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#90e87cbe8ae0717fa09ff51b70d64b47">affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Grid_Affine_Transformation">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#90e87cbe8ae0717fa09ff51b70d64b47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#d42265530a9e3b2f3bda9ab40d4a835b">generalized_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one(), Coefficient_traits::const_reference modulus=Coefficient_zero())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' = \frac{\mathrm{expr}}{\mathrm{denominator}} \pmod{\mathrm{modulus}}$" src="form_660.png">.  <a href="#d42265530a9e3b2f3bda9ab40d4a835b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#b602d97b867b5d2ea800ea7ceef4c6b5">generalized_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one(), Coefficient_traits::const_reference modulus=Coefficient_zero())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' = \frac{\mathrm{expr}}{\mathrm{denominator}} \pmod{\mathrm{modulus}}$" src="form_660.png">.  <a href="#b602d97b867b5d2ea800ea7ceef4c6b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a9c12ecd84df4ed86b5676a09fa39208">generalized_affine_image</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs, Coefficient_traits::const_reference modulus=Coefficient_zero())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' = \mathrm{rhs} \pmod{\mathrm{modulus}}$" src="form_661.png">.  <a href="#a9c12ecd84df4ed86b5676a09fa39208"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#fb9d83c4e182f640833116dc2f725076">generalized_affine_preimage</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs, Coefficient_traits::const_reference modulus=Coefficient_zero())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' = \mathrm{rhs} \pmod{\mathrm{modulus}}$" src="form_661.png">.  <a href="#fb9d83c4e182f640833116dc2f725076"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#0441c9c3b0ab0d55165bb6b4fd107f64">bounded_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">.  <a href="#0441c9c3b0ab0d55165bb6b4fd107f64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#9e4e32230b187284ac0b9ca8efba8f82">bounded_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">.  <a href="#9e4e32230b187284ac0b9ca8efba8f82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#c009459805692e582a00d4b5954ab8e5">time_elapse_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Time_Elapse">time-elapse</a> between <code>*this</code> and <code>y</code>.  <a href="#c009459805692e582a00d4b5954ab8e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2581586de73769088ece60dc01409a08"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::topological_closure_assign" ref="2581586de73769088ece60dc01409a08" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#2581586de73769088ece60dc01409a08">topological_closure_assign</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#b6bba83ceaafdb71df04b77e43bed022">congruence_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, unsigned *tp=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Widening">Grid widening</a> between <code>*this</code> and <code>y</code> using congruence systems.  <a href="#b6bba83ceaafdb71df04b77e43bed022"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#e8d42fcd571a9c9d64f0e7ffe67e995e">generator_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, unsigned *tp=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Widening">Grid widening</a> between <code>*this</code> and <code>y</code> using generator systems.  <a href="#e8d42fcd571a9c9d64f0e7ffe67e995e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#596fc5b3ee0d04895aca9139cb6cbcb6">widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, unsigned *tp=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Widening">Grid widening</a> between <code>*this</code> and <code>y</code>.  <a href="#596fc5b3ee0d04895aca9139cb6cbcb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#e47fdbff76383891b3896ac5fc213d5d">limited_congruence_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs, unsigned *tp=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the congruence variant of <a class="el" href="main.html#Grid_Widening">Grid widening</a> computation by also enforcing those congruences in <code>cgs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#e47fdbff76383891b3896ac5fc213d5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#323efbe5d43695cc65f8cd5935da94dc">limited_generator_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs, unsigned *tp=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the generator variant of the <a class="el" href="main.html#Grid_Widening">Grid widening</a> computation by also enforcing those congruences in <code>cgs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#323efbe5d43695cc65f8cd5935da94dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#9bdab8408169307fbd899ec3670cb2bf">limited_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs, unsigned *tp=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#Grid_Widening">Grid widening</a> computation by also enforcing those congruences in <code>cgs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#9bdab8408169307fbd899ec3670cb2bf"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Dimension of the Vector Space</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#10e3116398b920cb137cf576a073cc68">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new space dimensions and embeds the old grid in the new vector space.  <a href="#10e3116398b920cb137cf576a073cc68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#c4e1b49845e553ff84dc73e710def76c">add_space_dimensions_and_project</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new space dimensions to the grid and does not embed it in the new vector space.  <a href="#c4e1b49845e553ff84dc73e710def76c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#1b528a2e8d4d096f62535454e05b74ba">concatenate_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Grid_Concatenate">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order.  <a href="#1b528a2e8d4d096f62535454e05b74ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#75df0f78d7598dafa946251a04cb5d90">remove_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_removed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the specified dimensions from the vector space.  <a href="#75df0f78d7598dafa946251a04cb5d90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#7ff92e5d40e6faf667a0b1f6b8fad791">remove_higher_space_dimensions</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> new_dimension)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the higher dimensions of the vector space so that the resulting space will have dimension <code>new_dimension</code>.  <a href="#7ff92e5d40e6faf667a0b1f6b8fad791"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Partial_Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#60138f2b5d41fd62c862fdcd7c4a1e61">map_space_dimensions</a> (const Partial_Function &amp;pfunc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Grid_Map_Space_Dimensions">partial function</a>.  <a href="#60138f2b5d41fd62c862fdcd7c4a1e61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#f6df34e5e4ab9beab41cd76897d64c72">expand_space_dimension</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>.  <a href="#f6df34e5e4ab9beab41cd76897d64c72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#18ec2da355442e02ae67313ed5b48933">fold_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_folded, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Folds the space dimensions in <code>to_be_folded</code> into <code>var</code>.  <a href="#18ec2da355442e02ae67313ed5b48933"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous Member Functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="07bdac3717a59f64634da7d9b1cfaefd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::~Grid" ref="07bdac3717a59f64634da7d9b1cfaefd" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#07bdac3717a59f64634da7d9b1cfaefd">~Grid</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a598904833b374d50efc72c51914112c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::swap" ref="a598904833b374d50efc72c51914112c" args="(Grid &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a598904833b374d50efc72c51914112c">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps <code>*this</code> with grid <code>y</code>. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="508103dc808fc747a90b573083a60461"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::ascii_dump" ref="508103dc808fc747a90b573083a60461" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#508103dc808fc747a90b573083a60461">ascii_dump</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d51ba9ca3c3e0bf0042502f40d2e11b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::ascii_dump" ref="1d51ba9ca3c3e0bf0042502f40d2e11b" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#1d51ba9ca3c3e0bf0042502f40d2e11b">ascii_dump</a> (std::ostream &amp;s) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ee33974909cfc1cba605734a57d44df0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::print" ref="ee33974909cfc1cba605734a57d44df0" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ee33974909cfc1cba605734a57d44df0">print</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a26d0018999e56d94a7e96db2b6e553"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::ascii_load" ref="1a26d0018999e56d94a7e96db2b6e553" args="(std::istream &amp;s)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#1a26d0018999e56d94a7e96db2b6e553">ascii_load</a> (std::istream &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#1d51ba9ca3c3e0bf0042502f40d2e11b" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f39e1b0519a47aafb9dba4121dc41a9c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::total_memory_in_bytes" ref="f39e1b0519a47aafb9dba4121dc41a9c" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#f39e1b0519a47aafb9dba4121dc41a9c">total_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eb9b562373b4d288c03549bdba93fede"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::external_memory_in_bytes" ref="eb9b562373b4d288c03549bdba93fede" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#eb9b562373b4d288c03549bdba93fede">external_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#5f6fcc1dab2b08eff20b41d1412d1e2d">hash_code</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a 32-bit hash code for <code>*this</code>.  <a href="#5f6fcc1dab2b08eff20b41d1412d1e2d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fe613a3da3edc3cb4506f70d409f061d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::max_space_dimension" ref="fe613a3da3edc3cb4506f70d409f061d" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#fe613a3da3edc3cb4506f70d409f061d">max_space_dimension</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension all kinds of <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a> can handle. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7fc86a6331f34f34a506ab2b0609ac37"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::can_recycle_congruence_systems" ref="7fc86a6331f34f34a506ab2b0609ac37" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#7fc86a6331f34f34a506ab2b0609ac37">can_recycle_congruence_systems</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true indicating that this domain has methods that can recycle congruences. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3628b6d6e250d4c6b8301173c6ecc777"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::can_recycle_constraint_systems" ref="3628b6d6e250d4c6b8301173c6ecc777" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#3628b6d6e250d4c6b8301173c6ecc777">can_recycle_constraint_systems</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true indicating that this domain has methods that can recycle constraints. <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#87d004db7f8febf6f9c96b4a2a1c85e5">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same grid.  <a href="#87d004db7f8febf6f9c96b4a2a1c85e5"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#1cb88a546d32e7b5c07dc25055e33235">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;gr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#1cb88a546d32e7b5c07dc25055e33235"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#9e17201a9a12235a9a96cc31cfffd38f">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different grids.  <a href="#9e17201a9a12235a9a96cc31cfffd38f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#d452407f89cb560e83fb81938c12a585">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Parma_Polyhedra_Library::Grid</a> &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Parma_Polyhedra_Library::Grid</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#d452407f89cb560e83fb81938c12a585"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A grid. 
<p>
An object of the class <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a> represents a rational grid.<p>
The domain of grids <em>optimally supports</em>:<ul>
<li>all (proper and non-proper) congruences;</li><li>tautological and inconsistent constraints;</li><li>linear equality constraints (i.e., non-proper congruences).</li></ul>
<p>
Depending on the method, using a constraint that is not optimally supported by the domain will either raise an exception or result in a (possibly non-optimal) upward approximation.<p>
The domain of grids support a concept of double description similar to the one developed for polyhedra: hence, a grid can be specified as either a finite system of congruences or a finite system of generators (see Section <a class="el" href="main.html#sect_rational_grids">Rational Grids</a>) and it is always possible to obtain either representation. That is, if we know the system of congruences, we can obtain from this a system of generators that define the same grid and vice versa. These systems can contain redundant members, or they can be in the minimal form.<p>
A key attribute of any grid is its space dimension (the dimension <img class="formulaInl" alt="$n \in \Nset$" src="form_121.png"> of the enclosing vector space):<p>
<ul>
<li>all grids, the empty ones included, are endowed with a space dimension;</li><li>most operations working on a grid and another object (another grid, a congruence, a generator, a set of variables, etc.) will throw an exception if the grid and the object are not dimension-compatible (see Section <a class="el" href="main.html#Grid_Space_Dimensions">Space Dimensions and Dimension-compatibility for Grids</a>);</li><li>the only ways in which the space dimension of a grid can be changed are with <em>explicit</em> calls to operators provided for that purpose, and with standard copy, assignment and swap operators.</li></ul>
<p>
Note that two different grids can be defined on the zero-dimension space: the empty grid and the universe grid <img class="formulaInl" alt="$R^0$" src="form_513.png">.<p>
<dl class="user" compact><dt><b></b></dt><dd>In all the examples it is assumed that variables <code>x</code> and <code>y</code> are defined (where they are used) as follows: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 1</b></dt><dd>The following code builds a grid corresponding to the even integer pairs in <img class="formulaInl" alt="$\Rset^2$" src="form_106.png">, given as a system of congruences: <div class="fragment"><pre class="fragment">  Congruence_System cgs;
  cgs.insert((x %= 0) / 2);
  cgs.insert((y %= 0) / 2);
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(cgs);
</pre></div> The following code builds the same grid as above, but starting from a system of generators specifying three of the points: <div class="fragment"><pre class="fragment">  Grid_Generator_System gs;
  gs.insert(grid_point(0*x + 0*y));
  gs.insert(grid_point(0*x + 2*y));
  gs.insert(grid_point(2*x + 0*y));
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(gs);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 2</b></dt><dd>The following code builds a grid corresponding to a line in <img class="formulaInl" alt="$\Rset^2$" src="form_106.png"> by adding a single congruence to the universe grid: <div class="fragment"><pre class="fragment">  Congruence_System cgs;
  cgs.insert(x - y == 0);
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(cgs);
</pre></div> The following code builds the same grid as above, but starting from a system of generators specifying a point and a line: <div class="fragment"><pre class="fragment">  Grid_Generator_System gs;
  gs.insert(grid_point(0*x + 0*y));
  gs.insert(grid_line(x + y));
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(gs);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 3</b></dt><dd>The following code builds a grid corresponding to the integral points on the line <img class="formulaInl" alt="$x = y$" src="form_399.png"> in <img class="formulaInl" alt="$\Rset^2$" src="form_106.png"> constructed by adding an equality and congruence to the universe grid: <div class="fragment"><pre class="fragment">  Congruence_System cgs;
  cgs.insert(x - y == 0);
  cgs.insert(x %= 0);
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(cgs);
</pre></div> The following code builds the same grid as above, but starting from a system of generators specifying a point and a parameter: <div class="fragment"><pre class="fragment">  Grid_Generator_System gs;
  gs.insert(grid_point(0*x + 0*y));
  gs.insert(parameter(x + y));
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(gs);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 4</b></dt><dd>The following code builds the grid corresponding to a plane by creating the universe grid in <img class="formulaInl" alt="$\Rset^2$" src="form_106.png">: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(2);
</pre></div> The following code builds the same grid as above, but starting from the empty grid in <img class="formulaInl" alt="$\Rset^2$" src="form_106.png"> and inserting the appropriate generators (a point, and two lines). <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(2, <a class="code" href="group__PPL__CXX__interface.html#gg616fcdc7600a3a11a8a9152e75730899c7753e1dd51e1b7b3fdfafa9f8332370" title="The empty element, i.e., the empty set.">EMPTY</a>);
  gr.add_grid_generator(grid_point(0*x + 0*y));
  gr.add_grid_generator(grid_line(x));
  gr.add_grid_generator(grid_line(y));
</pre></div> Note that a generator system must contain a point when describing a grid. To ensure that this is always the case it is required that the first generator inserted in an empty grid is a point (otherwise, an exception is thrown).</dd></dl>
<dl class="user" compact><dt><b>Example 5</b></dt><dd>The following code shows the use of the function <code>add_space_dimensions_and_embed</code>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(1);
  gr.add_congruence(x == 2);
  gr.add_space_dimensions_and_embed(1);
</pre></div> We build the universe grid in the 1-dimension space <img class="formulaInl" alt="$\Rset$" src="form_17.png">. Then we add a single equality congruence, thus obtaining the grid corresponding to the singleton set <img class="formulaInl" alt="$\{ 2 \} \sseq \Rset$" src="form_514.png">. After the last line of code, the resulting grid is <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (2, y)^\transpose \in \Rset^2 \bigm| y \in \Rset \,\bigr\}. \]" src="form_515.png">
<p>
</dd></dl>
<dl class="user" compact><dt><b>Example 6</b></dt><dd>The following code shows the use of the function <code>add_space_dimensions_and_project</code>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(1);
  gr.add_congruence(x == 2);
  gr.add_space_dimensions_and_project(1);
</pre></div> The first two lines of code are the same as in Example 4 for <code>add_space_dimensions_and_embed</code>. After the last line of code, the resulting grid is the singleton set <img class="formulaInl" alt="$\bigl\{ (2, 0)^\transpose \bigr\} \sseq \Rset^2$" src="form_516.png">.</dd></dl>
<dl class="user" compact><dt><b>Example 7</b></dt><dd>The following code shows the use of the function <code>affine_image</code>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(2, <a class="code" href="group__PPL__CXX__interface.html#gg616fcdc7600a3a11a8a9152e75730899c7753e1dd51e1b7b3fdfafa9f8332370" title="The empty element, i.e., the empty set.">EMPTY</a>);
  gr.add_grid_generator(grid_point(0*x + 0*y));
  gr.add_grid_generator(grid_point(4*x + 0*y));
  gr.add_grid_generator(grid_point(0*x + 2*y));
  Linear_Expression expr = x + 3;
  gr.affine_image(x, expr);
</pre></div> In this example the starting grid is all the pairs of <img class="formulaInl" alt="$x$" src="form_479.png"> and <img class="formulaInl" alt="$y$" src="form_400.png"> in <img class="formulaInl" alt="$\Rset^2$" src="form_106.png"> where <img class="formulaInl" alt="$x$" src="form_479.png"> is an integer multiple of 4 and <img class="formulaInl" alt="$y$" src="form_400.png"> is an integer multiple of 2. The considered variable is <img class="formulaInl" alt="$x$" src="form_479.png"> and the affine expression is <img class="formulaInl" alt="$x+3$" src="form_523.png">. The resulting grid is the given grid translated 3 integers to the right (all the pairs <img class="formulaInl" alt="$(x, y)$" src="form_524.png"> where <img class="formulaInl" alt="$x$" src="form_479.png"> is -1 plus an integer multiple of 4 and <img class="formulaInl" alt="$y$" src="form_400.png"> is an integer multiple of 2). Moreover, if the affine transformation for the same variable <code>x</code> is instead <img class="formulaInl" alt="$x+y$" src="form_518.png">: <div class="fragment"><pre class="fragment">  Linear_Expression expr = x + y;
</pre></div> the resulting grid is every second integral point along the <img class="formulaInl" alt="$x=y$" src="form_525.png"> line, with this line of points repeated at every fourth integral value along the <img class="formulaInl" alt="$x$" src="form_479.png"> axis. Instead, if we do not use an invertible transformation for the same variable; for example, the affine expression <img class="formulaInl" alt="$y$" src="form_400.png">: <div class="fragment"><pre class="fragment">  Linear_Expression expr = y;
</pre></div> the resulting grid is every second point along the <img class="formulaInl" alt="$x=y$" src="form_525.png"> line.</dd></dl>
<dl class="user" compact><dt><b>Example 8</b></dt><dd>The following code shows the use of the function <code>affine_preimage</code>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(2, <a class="code" href="group__PPL__CXX__interface.html#gg616fcdc7600a3a11a8a9152e75730899c7753e1dd51e1b7b3fdfafa9f8332370" title="The empty element, i.e., the empty set.">EMPTY</a>);
  gr.add_grid_generator(grid_point(0*x + 0*y));
  gr.add_grid_generator(grid_point(4*x + 0*y));
  gr.add_grid_generator(grid_point(0*x + 2*y));
  Linear_Expression expr = x + 3;
  gr.affine_preimage(x, expr);
</pre></div> In this example the starting grid, <code>var</code> and the affine expression and the denominator are the same as in Example 6, while the resulting grid is similar but translated 3 integers to the left (all the pairs <img class="formulaInl" alt="$(x, y)$" src="form_524.png"> where <img class="formulaInl" alt="$x$" src="form_479.png"> is -3 plus an integer multiple of 4 and <img class="formulaInl" alt="$y$" src="form_400.png"> is an integer multiple of 2).. Moreover, if the affine transformation for <code>x</code> is <img class="formulaInl" alt="$x+y$" src="form_518.png"> <div class="fragment"><pre class="fragment">  Linear_Expression expr = x + y;
</pre></div> the resulting grid is a similar grid to the result in Example 6, only the grid is slanted along <img class="formulaInl" alt="$x=-y$" src="form_526.png">. Instead, if we do not use an invertible transformation for the same variable <code>x</code>, for example, the affine expression <img class="formulaInl" alt="$y$" src="form_400.png">: <div class="fragment"><pre class="fragment">  Linear_Expression expr = y;
</pre></div> the resulting grid is every fourth line parallel to the <img class="formulaInl" alt="$x$" src="form_479.png"> axis.</dd></dl>
<dl class="user" compact><dt><b>Example 9</b></dt><dd>For this example we also use the variables: <div class="fragment"><pre class="fragment">  Variable z(2);
  Variable w(3);
</pre></div> The following code shows the use of the function <code>remove_space_dimensions</code>: <div class="fragment"><pre class="fragment">  Grid_Generator_System gs;
  gs.insert(grid_point(3*x + y +0*z + 2*w));
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(gs);
  Variables_Set to_be_removed;
  to_be_removed.insert(y);
  to_be_removed.insert(z);
  gr.remove_space_dimensions(to_be_removed);
</pre></div> The starting grid is the singleton set <img class="formulaInl" alt="$\bigl\{ (3, 1, 0, 2)^\transpose \bigr\} \sseq \Rset^4$" src="form_155.png">, while the resulting grid is <img class="formulaInl" alt="$\bigl\{ (3, 2)^\transpose \bigr\} \sseq \Rset^2$" src="form_520.png">. Be careful when removing space dimensions <em>incrementally</em>: since dimensions are automatically renamed after each application of the <code>remove_space_dimensions</code> operator, unexpected results can be obtained. For instance, by using the following code we would obtain a different result: <div class="fragment"><pre class="fragment">  set&lt;Variable&gt; to_be_removed1;
  to_be_removed1.insert(y);
  gr.remove_space_dimensions(to_be_removed1);
  set&lt;Variable&gt; to_be_removed2;
  to_be_removed2.insert(z);
  gr.remove_space_dimensions(to_be_removed2);
</pre></div> In this case, the result is the grid <img class="formulaInl" alt="$\bigl\{(3, 0)^\transpose \bigr\} \sseq \Rset^2$" src="form_521.png">: when removing the set of dimensions <code>to_be_removed2</code> we are actually removing variable <img class="formulaInl" alt="$w$" src="form_522.png"> of the original grid. For the same reason, the operator <code>remove_space_dimensions</code> is not idempotent: removing twice the same non-empty set of dimensions is never the same as removing them just once. </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="0262a2b32220536d8bc60d84ad8dac4c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="0262a2b32220536d8bc60d84ad8dac4c" args="(dimension_type num_dimensions=0, Degenerate_Element kind=UNIVERSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>num_dimensions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em> = <code>UNIVERSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a grid having the specified properties. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&nbsp;</td><td>The number of dimensions of the vector space enclosing the grid;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>Specifies whether the universe or the empty grid has to be built.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="727dc2405cfc5f2252e6f21aa0f18074"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="727dc2405cfc5f2252e6f21aa0f18074" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a grid, copying a system of congruences. 
<p>
The grid inherits the space dimension of the congruence system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences defining the grid.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="31603d81a2b0571a82c4c79b8c6e4564"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="31603d81a2b0571a82c4c79b8c6e4564" args="(Congruence_System &amp;cgs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a grid, recycling a system of congruences. 
<p>
The grid inherits the space dimension of the congruence system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences defining the grid. Its data-structures may be recycled to build the grid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0c02302b6281fa91ef9275bd37e43efc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="0c02302b6281fa91ef9275bd37e43efc" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a grid, copying a system of constraints. 
<p>
The grid inherits the space dimension of the constraint system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints defining the grid.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the constraint system <code>cs</code> contains inequality constraints.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="527ffa31e1581a8beb83a832244dada8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="527ffa31e1581a8beb83a832244dada8" args="(Constraint_System &amp;cs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a grid, recycling a system of constraints. 
<p>
The grid inherits the space dimension of the constraint system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints defining the grid. Its data-structures may be recycled to build the grid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the constraint system <code>cs</code> contains inequality constraints.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="732d3b59f8a0ba21a72877d5fa4b98a5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="732d3b59f8a0ba21a72877d5fa4b98a5" args="(const Grid_Generator_System &amp;const_gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>const_gs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a grid, copying a system of grid generators. 
<p>
The grid inherits the space dimension of the generator system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>const_gs</em>&nbsp;</td><td>The system of generators defining the grid.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of generators is not empty but has no points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1ba0bd59426889233904d052224cab76"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="1ba0bd59426889233904d052224cab76" args="(Grid_Generator_System &amp;gs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a grid, recycling a system of grid generators. 
<p>
The grid inherits the space dimension of the generator system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The system of generators defining the grid. Its data-structures may be recycled to build the grid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of generators is not empty but has no points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="19623ff8cea2239d66331f29c1d0268d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="19623ff8cea2239d66331f29c1d0268d" args="(const Box&lt; Interval &gt; &amp;box, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a grid out of a box. 
<p>
The grid inherits the space dimension of the box. The built grid is the most precise grid that includes the box.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The box representing the grid to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>box</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="470e6a581b91bc6d5a4a6388d1ddde99"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="470e6a581b91bc6d5a4a6388d1ddde99" args="(const BD_Shape&lt; U &gt; &amp;bd, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a grid out of a bounded-difference shape. 
<p>
The grid inherits the space dimension of the BDS. The built grid is the most precise grid that includes the BDS.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bd</em>&nbsp;</td><td>The BDS representing the grid to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>bd</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="df002bbcc4dcae5efdb56bae2971a64b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="df002bbcc4dcae5efdb56bae2971a64b" args="(const Octagonal_Shape&lt; U &gt; &amp;os, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a grid out of an octagonal shape. 
<p>
The grid inherits the space dimension of the octagonal shape. The built grid is the most precise grid that includes the octagonal shape.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The octagonal shape representing the grid to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>os</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f306aa1f4e34bf045cd07e5ac11d8f68"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="f306aa1f4e34bf045cd07e5ac11d8f68" args="(const Box &amp;box, From_Covering_Box dummy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Box &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1From__Covering__Box.html">From_Covering_Box</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a grid out of a generic, interval-based covering box. 
<p>
The covering box is a set of upper and lower values for each dimension. When a covering box is tiled onto empty space the corners of the tiles form a rectilinear grid.<p>
A box interval with only one bound fixes the values of all grid points in the dimension associated with the box to the value of the bound. A box interval which has upper and lower bounds of equal value allows all grid points with any value in the dimension associated with the interval. The presence of a universe interval results in the empty grid. The empty box produces the empty grid of the same dimension as the box.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The covering box representing the grid to be built;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to make this constructor syntactically unique.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>box</code> exceeds the maximum allowed space dimension.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>box</code> contains any topologically open bounds.</td></tr>
  </table>
</dl>
The template class <a class="el" href="classParma__Polyhedra__Library_1_1Box.html" title="A not necessarily closed, iso-oriented hyperrectangle.">Box</a> must provide the following methods. <div class="fragment"><pre class="fragment">      <a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#fc06f600e94b7bedb91d0371a51f4c38" title="Returns the dimension of the vector space enclosing *this.">space_dimension</a>() const
</pre></div> returns the dimension of the vector space enclosing the grid represented by the covering box. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#2f31170286d3abc2f4867d0b193ae8bc" title="Returns true if and only if *this is an empty grid.">is_empty</a>() const
</pre></div> returns <code>true</code> if and only if the covering box describes the empty set. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> get_lower_bound(<a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> k, <span class="keywordtype">bool</span>&amp; closed,
                           <a class="code" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899" title="An alias for easily naming the type of PPL coefficients.">Coefficient</a>&amp; n, <a class="code" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899" title="An alias for easily naming the type of PPL coefficients.">Coefficient</a>&amp; d) <span class="keyword">const</span>
</pre></div> Let <img class="formulaInl" alt="$I$" src="form_656.png"> be the interval corresponding to the <code>k</code>-th space dimension. If <img class="formulaInl" alt="$I$" src="form_656.png"> is not bounded from below, simply return <code>false</code>. Otherwise, set <code>closed</code>, <code>n</code> and <code>d</code> as follows: <code>closed</code> is set to <code>true</code> if the lower boundary of <img class="formulaInl" alt="$I$" src="form_656.png"> is closed and is set to <code>false</code> otherwise; <code>n</code> and <code>d</code> are assigned the integers <img class="formulaInl" alt="$n$" src="form_0.png"> and <img class="formulaInl" alt="$d$" src="form_657.png"> such that the canonical fraction <img class="formulaInl" alt="$n/d$" src="form_658.png"> corresponds to the greatest lower bound of <img class="formulaInl" alt="$I$" src="form_656.png">. The fraction <img class="formulaInl" alt="$n/d$" src="form_658.png"> is in canonical form if and only if <img class="formulaInl" alt="$n$" src="form_0.png"> and <img class="formulaInl" alt="$d$" src="form_657.png"> have no common factors and <img class="formulaInl" alt="$d$" src="form_657.png"> is positive, <img class="formulaInl" alt="$0/1$" src="form_659.png"> being the unique representation for zero. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> get_upper_bound(<a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> k, <span class="keywordtype">bool</span>&amp; closed,
                           <a class="code" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899" title="An alias for easily naming the type of PPL coefficients.">Coefficient</a>&amp; n, <a class="code" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899" title="An alias for easily naming the type of PPL coefficients.">Coefficient</a>&amp; d) <span class="keyword">const</span>
</pre></div> Let <img class="formulaInl" alt="$I$" src="form_656.png"> be the interval corresponding to the <code>k</code>-th space dimension. If <img class="formulaInl" alt="$I$" src="form_656.png"> is not bounded from above, simply return <code>false</code>. Otherwise, set <code>closed</code>, <code>n</code> and <code>d</code> as follows: <code>closed</code> is set to <code>true</code> if the upper boundary of <img class="formulaInl" alt="$I$" src="form_656.png"> is closed and is set to <code>false</code> otherwise; <code>n</code> and <code>d</code> are assigned the integers <img class="formulaInl" alt="$n$" src="form_0.png"> and <img class="formulaInl" alt="$d$" src="form_657.png"> such that the canonical fraction <img class="formulaInl" alt="$n/d$" src="form_658.png"> corresponds to the least upper bound of <img class="formulaInl" alt="$I$" src="form_656.png">. 
</div>
</div><p>
<a class="anchor" name="36cc3783cdc92ab5fc69904c298ed12c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="36cc3783cdc92ab5fc69904c298ed12c" args="(const Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a grid from a polyhedron using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the grid built is the smallest one containing <code>ph</code>. 
<p>
The grid inherits the space dimension of polyhedron.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ph</em>&nbsp;</td><td>The polyhedron.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity class.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a28d735beef86789b73b41dbbde71abf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="a28d735beef86789b73b41dbbde71abf" args="(const Grid &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ordinary copy-constructor. 
<p>
The complexity argument is ignored. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="dc7cdee1981f44b5db23f6c28c79d0a6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::is_topologically_closed" ref="dc7cdee1981f44b5db23f6c28c79d0a6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::is_topologically_closed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is a topologically closed subset of the vector space. 
<p>
A grid is always topologically closed. 
</div>
</div><p>
<a class="anchor" name="621d377682c2c67051c24b1cc8a03497"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::is_disjoint_from" ref="621d377682c2c67051c24b1cc8a03497" args="(const Grid &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::is_disjoint_from           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>x</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2528b5f433e743dda827b1028b6c74cd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::is_discrete" ref="2528b5f433e743dda827b1028b6c74cd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::is_discrete           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is discrete. 
<p>
A grid is discrete if it can be defined by a generator system which contains only points and parameters. This includes the empty grid and any grid in dimension zero. 
</div>
</div><p>
<a class="anchor" name="3ac47497148e61f3d7a3da09d17a03bf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::constrains" ref="3ac47497148e61f3d7a3da09d17a03bf" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::constrains           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a033cfca735240b3699b523d60ad692a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::bounds_from_above" ref="a033cfca735240b3699b523d60ad692a" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::bounds_from_above           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>. 
<p>
This method is the same as bounds_from_below.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fde364ce088f82cf2b9a231e7d9f2abc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::bounds_from_below" ref="fde364ce088f82cf2b9a231e7d9f2abc" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::bounds_from_below           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>. 
<p>
This method is the same as bounds_from_above.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="042613c3f4ad30b298d70143c935d7cd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::maximize" ref="042613c3f4ad30b298d70143c935d7cd" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::maximize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if the supremum value can be reached in <code>this</code>. Always <code>true</code> when <code>this</code> bounds <code>expr</code>. Present for interface compatibility with class <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a>, where closure points can result in a value of false.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded by <code>*this</code>, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code> and <code>maximum</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="8fa02815bb561135934f91c9adcd0cb5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::maximize" ref="8fa02815bb561135934f91c9adcd0cb5" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum, Generator &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::maximize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if the supremum value can be reached in <code>this</code>. Always <code>true</code> when <code>this</code> bounds <code>expr</code>. Present for interface compatibility with class <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a>, where closure points can result in a value of false;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>When maximization succeeds, will be assigned a point where <code>expr</code> reaches its supremum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded by <code>*this</code>, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code>, <code>maximum</code> and <code>point</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="0d8ed7a0e48fe76e7221842c780192b0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::minimize" ref="0d8ed7a0e48fe76e7221842c780192b0" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if the is the infimum value can be reached in <code>this</code>. Always <code>true</code> when <code>this</code> bounds <code>expr</code>. Present for interface compatibility with class <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a>, where closure points can result in a value of false.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code> and <code>minimum</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="53f980fb1ac8fa21265bec985bd1382f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::minimize" ref="53f980fb1ac8fa21265bec985bd1382f" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum, Generator &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if the is the infimum value can be reached in <code>this</code>. Always <code>true</code> when <code>this</code> bounds <code>expr</code>. Present for interface compatibility with class <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a>, where closure points can result in a value of false;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>When minimization succeeds, will be assigned a point where <code>expr</code> reaches its infimum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code>, <code>minimum</code> and <code>point</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="d743f8b71eb68f6b41f7ea7b5d21dc22"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::contains" ref="d743f8b71eb68f6b41f7ea7b5d21dc22" args="(const Grid &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8d2cc5d18d050975101f2860f2919da8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::strictly_contains" ref="8d2cc5d18d050975101f2860f2919da8" args="(const Grid &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::strictly_contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="87e253a2b1d8e1696c2ebf3feb11dc5f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::get_covering_box" ref="87e253a2b1d8e1696c2ebf3feb11dc5f" args="(Box&lt; Interval &gt; &amp;box) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::get_covering_box           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the covering box for <code>*this</code> into <code>box</code>. 
<p>
The covering box is a set of upper and lower values for each dimension. When the covering box written into <code>box</code> is tiled onto empty space the corners of the tiles form the sparsest rectilinear grid that includes <code>*this</code>.<p>
The value of the lower bound of each interval of the resulting <code>box</code> are as close as possible to the origin, with positive values taking preference when the lowest positive value equals the lowest negative value.<p>
If all the points have a single value in a particular dimension of the grid then there is only a lower bound on the interval produced in <code>box</code>, and the lower bound denotes the single value for the dimension. If the coordinates of the points in a particular dimension include every value then the upper and lower bounds of the associated interval in <code>box</code> are set equal. The empty grid produces the empty <code>box</code>. The zero dimension universe grid produces the zero dimension universe box.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The <a class="el" href="classParma__Polyhedra__Library_1_1Box.html" title="A not necessarily closed, iso-oriented hyperrectangle.">Box</a> into which the covering box is written.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>box</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8edc85ba3e8a09593959814eaad72499"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::OK" ref="8edc85ba3e8a09593959814eaad72499" args="(bool check_not_empty=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::OK           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>check_not_empty</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if all the invariants are satisfied. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if and only if <code>*this</code> satisfies all the invariants and either <code>check_not_empty</code> is <code>false</code> or <code>*this</code> is not empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check_not_empty</em>&nbsp;</td><td><code>true</code> if and only if, in addition to checking the invariants, <code>*this</code> must be checked to be not empty.</td></tr>
  </table>
</dl>
The check is performed so as to intrude as little as possible. If the library has been compiled with run-time assertions enabled, error messages are written on <code>std::cerr</code> in case invariants are violated. This is useful for the purpose of debugging the library. 
</div>
</div><p>
<a class="anchor" name="1287b254a91451368e7e2e456f448114"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_congruence" ref="1287b254a91451368e7e2e456f448114" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_congruence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of congruence <code>cg</code> to <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ccb5584441a7c7c84de73810cc6afbc4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_congruence_and_minimize" ref="ccb5584441a7c7c84de73810cc6afbc4" args="(const Congruence &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::add_congruence_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of congruence <code>cg</code> to the system of congruences of <code>this</code>, reducing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d09e4e3f9a9da562c6cdb73dd7b47fbe"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_grid_generator" ref="d09e4e3f9a9da562c6cdb73dd7b47fbe" args="(const Grid_Generator &amp;g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_grid_generator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html">Grid_Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of grid generator <code>g</code> to the system of generators of <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are dimension-incompatible, or if <code>*this</code> is an empty grid and <code>g</code> is not a point. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="880be9febc6dab2cdccbec8814c9a952"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_grid_generator_and_minimize" ref="880be9febc6dab2cdccbec8814c9a952" args="(const Grid_Generator &amp;g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::add_grid_generator_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html">Grid_Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of grid generator <code>g</code> to the system of generators of <code>*this</code>, reducing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are dimension-incompatible, or if <code>*this</code> is an empty grid and <code>g</code> is not a point.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a26f672c32271db69ed68fc60eee8cff"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_congruences" ref="a26f672c32271db69ed68fc60eee8cff" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_congruences           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of each congruence in <code>cgs</code> to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>Contains the congruences that will be added to the system of congruences of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="85b2560352485ac05d10aab0ee483252"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_recycled_congruences" ref="85b2560352485ac05d10aab0ee483252" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_recycled_congruences           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the congruences in <code>cgs</code> to *this. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruence system to be added to <code>*this</code>. The congruences in <code>cgs</code> may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="726484f44f6e6653f9c0126e94e51ab0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_congruences_and_minimize" ref="726484f44f6e6653f9c0126e94e51ab0" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::add_congruences_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of the congruences in <code>cgs</code> to the system of congruences of <code>*this</code>, reducing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>Contains the congruences that will be added to the system of congruences of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c587faeb0edfd2582564b9a8fa3335bd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_recycled_congruences_and_minimize" ref="c587faeb0edfd2582564b9a8fa3335bd" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::add_recycled_congruences_and_minimize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the congruences in <code>cgs</code> to the system of congruences of <code>this</code>, reducing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruence system to be added to <code>*this</code>. The congruences in <code>cgs</code> may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e87405c740d202951ba788f9e52cbf7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_constraint" ref="9e87405c740d202951ba788f9e52cbf7" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_constraint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> a congruence equivalent to constraint <code>c</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint to be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>c</code> are dimension-incompatible or if constraint <code>c</code> is not optimally supported by the grid domain. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fa7b390fb34934e419263a5fc694c946"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_constraint_and_minimize" ref="fa7b390fb34934e419263a5fc694c946" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::add_constraint_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> a congruence equivalent to constraint <code>c</code>, also minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint to be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>c</code> are dimension-incompatible or if constraint <code>c</code> is not optimally supported by the grid domain.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="943c42b0d1b3580e54b3ab60aa55255f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_constraints" ref="943c42b0d1b3580e54b3ab60aa55255f" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_constraints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> congruences equivalent to the constraints in <code>cs</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints to be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a constraint whcih is not optimally supported by the grid domain. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7704df6970b9563ef9e51793126c0ae2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_constraints_and_minimize" ref="7704df6970b9563ef9e51793126c0ae2" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::add_constraints_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> congruences equivalent to the constraints in <code>cs</code>, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints to be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a constraint whcih is not optimally supported by the grid domain.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="145cc7c23d407576222e5af347f401c1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_recycled_constraints" ref="145cc7c23d407576222e5af347f401c1" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_recycled_constraints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> congruences equivalent to the constraints in <code>cs</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints to be added. They may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a constraint whcih is not optimally supported by the grid domain.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>cs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a66994a33d910d0fe8daccc6cc017ed"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_recycled_constraints_and_minimize" ref="2a66994a33d910d0fe8daccc6cc017ed" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::add_recycled_constraints_and_minimize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> congruences equivalent to the constraints in <code>cs</code>, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints to be added. They may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a constraint whcih is not optimally supported by the grid domain.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>cs</code> upon successful or exceptional return is that it can be safely destroyed.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="953a608f6f9d413870fb3eee5cc6ad1e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::refine_with_congruence" ref="953a608f6f9d413870fb3eee5cc6ad1e" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::refine_with_congruence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of the congruence <code>cg</code> to refine <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&nbsp;</td><td>The congruence used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f1ab967a6606266f7e583fc9752667fe"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::refine_with_congruences" ref="f1ab967a6606266f7e583fc9752667fe" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::refine_with_congruences           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of the congruences in <code>cgs</code> to refine <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruences used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="82b76e3f18679ea161b53bfa80349009"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::refine_with_constraint" ref="82b76e3f18679ea161b53bfa80349009" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::refine_with_constraint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of the constraint <code>c</code> to refine <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint used. If it is not an equality, it will be ignored</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>c</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8f97dbc7a7c307fa72f7e904b2cbf21b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::refine_with_constraints" ref="8f97dbc7a7c307fa72f7e904b2cbf21b" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::refine_with_constraints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of the constraints in <code>cs</code> to refine <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints used. Constraints that are not equalities are ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="19422844125a988daaf489cbaff3835b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_grid_generators" ref="19422844125a988daaf489cbaff3835b" args="(const Grid_Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_grid_generators           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of the generators in <code>gs</code> to the system of generators of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>Contains the generators that will be added to the system of generators of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>gs</code> are dimension-incompatible, or if <code>*this</code> is empty and the system of generators <code>gs</code> is not empty, but has no points. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="214e376adb9dc271c61b58f8b2c927f0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_recycled_grid_generators" ref="214e376adb9dc271c61b58f8b2c927f0" args="(Grid_Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_recycled_grid_generators           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the generators in <code>gs</code> to the system of generators of <code>this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The generator system to be added to <code>*this</code>. The generators in <code>gs</code> may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>gs</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>gs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1522764599cd8547bfe4ef7e88d8baec"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_grid_generators_and_minimize" ref="1522764599cd8547bfe4ef7e88d8baec" args="(const Grid_Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::add_grid_generators_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of the generators in <code>gs</code> to the system of generators of <code>*this</code>, reducing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>Contains the generators that will be added to the system of generators of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>gs</code> are dimension-incompatible, or if <code>this</code> is empty and the system of generators <code>gs</code> is not empty, but has no points.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4d6e94fc9839cd5d455f195f46fc2dcf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_recycled_grid_generators_and_minimize" ref="4d6e94fc9839cd5d455f195f46fc2dcf" args="(Grid_Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::add_recycled_grid_generators_and_minimize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the generators in <code>gs</code> to the system of generators of <code>this</code>, reducing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The generator system to be added to <code>*this</code>. The generators in <code>gs</code> may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>gs</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>gs</code> upon successful or exceptional return is that it can be safely destroyed.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5dc5003b3652660bc4ff4a15e4060af"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::unconstrain" ref="e5dc5003b3652660bc4ff4a15e4060af" args="(Variable var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::unconstrain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The space dimension that will be unconstrained.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="26f845c3192c71f59cf1c81cd35072c5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::unconstrain" ref="26f845c3192c71f59cf1c81cd35072c5" args="(const Variables_Set &amp;to_be_unconstrained)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::unconstrain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_unconstrained</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>to_be_unconstrained</code>, assigning the result to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_unconstrained</em>&nbsp;</td><td>The set of space dimension that will be unconstrained.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_removed</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c9d9eaf8b76024bc20ce524e13bf86a6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::intersection_assign" ref="c9d9eaf8b76024bc20ce524e13bf86a6" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::intersection_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="59af9a947f610641fe02639f76cfc90e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::intersection_assign_and_minimize" ref="59af9a947f610641fe02639f76cfc90e" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::intersection_assign_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>, reducing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9831db06919c6ee05360b08e84cccbb7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::upper_bound_assign" ref="9831db06919c6ee05360b08e84cccbb7" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::upper_bound_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the least upper bound of <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="901082d5c6de5ec4b457df69e41bb70c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::upper_bound_assign_and_minimize" ref="901082d5c6de5ec4b457df69e41bb70c" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::upper_bound_assign_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the least upper bound of <code>*this</code> and <code>y</code>, reducing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="68665d093308c111817eca341b98d70a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::upper_bound_assign_if_exact" ref="68665d093308c111817eca341b98d70a" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::upper_bound_assign_if_exact           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the upper bound of <code>*this</code> and <code>y</code> is exact it is assigned to <code>this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e5955a311fc4fde1edf2d5460f0a8356"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::difference_assign" ref="e5955a311fc4fde1edf2d5460f0a8356" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::difference_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Grid_Difference">grid-difference</a> of <code>*this</code> and <code>y</code>. 
<p>
The grid difference between grids x and y is the smallest grid containing all the points from x and y that are only in x.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="071aa57e439ba4f358c7fd43b03a6a49"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::simplify_using_context_assign" ref="071aa57e439ba4f358c7fd43b03a6a49" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::simplify_using_context_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bb10ea556dd34e0c1e13f7e99b9efe70"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::affine_image" ref="bb10ea556dd34e0c1e13f7e99b9efe70" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Grid_Affine_Transformation">affine image</a> of <code>this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is assigned;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="90e87cbe8ae0717fa09ff51b70d64b47"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::affine_preimage" ref="90e87cbe8ae0717fa09ff51b70d64b47" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Grid_Affine_Transformation">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is substituted;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d42265530a9e3b2f3bda9ab40d4a835b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::generalized_affine_image" ref="d42265530a9e3b2f3bda9ab40d4a835b" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one(), Coefficient_traits::const_reference modulus=Coefficient_zero())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::generalized_affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>modulus</em> = <code>Coefficient_zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' = \frac{\mathrm{expr}}{\mathrm{denominator}} \pmod{\mathrm{modulus}}$" src="form_660.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol where EQUAL is the symbol for a congruence relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression. Optional argument with an automatic value of one;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modulus</em>&nbsp;</td><td>The modulus of the congruence lhs = rhs. A modulus of zero indicates lhs == rhs. Optional argument with an automatic value of zero.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b602d97b867b5d2ea800ea7ceef4c6b5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::generalized_affine_preimage" ref="b602d97b867b5d2ea800ea7ceef4c6b5" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one(), Coefficient_traits::const_reference modulus=Coefficient_zero())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::generalized_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>modulus</em> = <code>Coefficient_zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' = \frac{\mathrm{expr}}{\mathrm{denominator}} \pmod{\mathrm{modulus}}$" src="form_660.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol where EQUAL is the symbol for a congruence relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression. Optional argument with an automatic value of one;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modulus</em>&nbsp;</td><td>The modulus of the congruence lhs = rhs. A modulus of zero indicates lhs == rhs. Optional argument with an automatic value of zero.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a9c12ecd84df4ed86b5676a09fa39208"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::generalized_affine_image" ref="a9c12ecd84df4ed86b5676a09fa39208" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs, Coefficient_traits::const_reference modulus=Coefficient_zero())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::generalized_affine_image           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>modulus</em> = <code>Coefficient_zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' = \mathrm{rhs} \pmod{\mathrm{modulus}}$" src="form_661.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol where EQUAL is the symbol for a congruence relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modulus</em>&nbsp;</td><td>The modulus of the congruence lhs = rhs. A modulus of zero indicates lhs == rhs. Optional argument with an automatic value of zero.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fb9d83c4e182f640833116dc2f725076"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::generalized_affine_preimage" ref="fb9d83c4e182f640833116dc2f725076" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs, Coefficient_traits::const_reference modulus=Coefficient_zero())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::generalized_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>modulus</em> = <code>Coefficient_zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' = \mathrm{rhs} \pmod{\mathrm{modulus}}$" src="form_661.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol where EQUAL is the symbol for a congruence relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modulus</em>&nbsp;</td><td>The modulus of the congruence lhs = rhs. A modulus of zero indicates lhs == rhs. Optional argument with an automatic value of zero.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0441c9c3b0ab0d55165bb6b4fd107f64"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::bounded_affine_image" ref="0441c9c3b0ab0d55165bb6b4fd107f64" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::bounded_affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9e4e32230b187284ac0b9ca8efba8f82"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::bounded_affine_preimage" ref="9e4e32230b187284ac0b9ca8efba8f82" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::bounded_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c009459805692e582a00d4b5954ab8e5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::time_elapse_assign" ref="c009459805692e582a00d4b5954ab8e5" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::time_elapse_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Time_Elapse">time-elapse</a> between <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b6bba83ceaafdb71df04b77e43bed022"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::congruence_widening_assign" ref="b6bba83ceaafdb71df04b77e43bed022" args="(const Grid &amp;y, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::congruence_widening_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Widening">Grid widening</a> between <code>*this</code> and <code>y</code> using congruence systems. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A grid that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Grid_Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e8d42fcd571a9c9d64f0e7ffe67e995e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::generator_widening_assign" ref="e8d42fcd571a9c9d64f0e7ffe67e995e" args="(const Grid &amp;y, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::generator_widening_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Widening">Grid widening</a> between <code>*this</code> and <code>y</code> using generator systems. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A grid that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Grid_Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="596fc5b3ee0d04895aca9139cb6cbcb6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::widening_assign" ref="596fc5b3ee0d04895aca9139cb6cbcb6" args="(const Grid &amp;y, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::widening_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Widening">Grid widening</a> between <code>*this</code> and <code>y</code>. 
<p>
This widening uses either the congruence or generator systems depending on which of the systems describing x and y are up to date and minimized.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A grid that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Grid_Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e47fdbff76383891b3896ac5fc213d5d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::limited_congruence_extrapolation_assign" ref="e47fdbff76383891b3896ac5fc213d5d" args="(const Grid &amp;y, const Congruence_System &amp;cgs, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::limited_congruence_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Improves the result of the congruence variant of <a class="el" href="main.html#Grid_Widening">Grid widening</a> computation by also enforcing those congruences in <code>cgs</code> that are satisfied by all the points of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A grid that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences used to improve the widened grid;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Grid_Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="323efbe5d43695cc65f8cd5935da94dc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::limited_generator_extrapolation_assign" ref="323efbe5d43695cc65f8cd5935da94dc" args="(const Grid &amp;y, const Congruence_System &amp;cgs, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::limited_generator_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Improves the result of the generator variant of the <a class="el" href="main.html#Grid_Widening">Grid widening</a> computation by also enforcing those congruences in <code>cgs</code> that are satisfied by all the points of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A grid that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences used to improve the widened grid;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Grid_Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9bdab8408169307fbd899ec3670cb2bf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::limited_extrapolation_assign" ref="9bdab8408169307fbd899ec3670cb2bf" args="(const Grid &amp;y, const Congruence_System &amp;cgs, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::limited_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Improves the result of the <a class="el" href="main.html#Grid_Widening">Grid widening</a> computation by also enforcing those congruences in <code>cgs</code> that are satisfied by all the points of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A grid that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences used to improve the widened grid;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Grid_Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="10e3116398b920cb137cf576a073cc68"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_space_dimensions_and_embed" ref="10e3116398b920cb137cf576a073cc68" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_space_dimensions_and_embed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <code>m</code> new space dimensions and embeds the old grid in the new vector space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of dimensions to add.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#fe613a3da3edc3cb4506f70d409f061d" title="Returns the maximum space dimension all kinds of Grid can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
</dl>
The new space dimensions will be those having the highest indexes in the new grid, which is characterized by a system of congruences in which the variables which are the new dimensions can have any value. For instance, when starting from the grid <img class="formulaInl" alt="$\cL \sseq \Rset^2$" src="form_376.png"> and adding a third space dimension, the result will be the grid <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, z)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cL \,\bigr\}. \]" src="form_662.png">
<p>
 
</div>
</div><p>
<a class="anchor" name="c4e1b49845e553ff84dc73e710def76c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_space_dimensions_and_project" ref="c4e1b49845e553ff84dc73e710def76c" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_space_dimensions_and_project           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <code>m</code> new space dimensions to the grid and does not embed it in the new vector space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of space dimensions to add.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#fe613a3da3edc3cb4506f70d409f061d" title="Returns the maximum space dimension all kinds of Grid can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
</dl>
The new space dimensions will be those having the highest indexes in the new grid, which is characterized by a system of congruences in which the variables running through the new dimensions are all constrained to be equal to 0. For instance, when starting from the grid <img class="formulaInl" alt="$\cL \sseq \Rset^2$" src="form_376.png"> and adding a third space dimension, the result will be the grid <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, 0)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cL \,\bigr\}. \]" src="form_663.png">
<p>
 
</div>
</div><p>
<a class="anchor" name="1b528a2e8d4d096f62535454e05b74ba"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::concatenate_assign" ref="1b528a2e8d4d096f62535454e05b74ba" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::concatenate_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Grid_Concatenate">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the concatenation would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#fe613a3da3edc3cb4506f70d409f061d" title="Returns the maximum space dimension all kinds of Grid can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="75df0f78d7598dafa946251a04cb5d90"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::remove_space_dimensions" ref="75df0f78d7598dafa946251a04cb5d90" args="(const Variables_Set &amp;to_be_removed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::remove_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_removed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all the specified dimensions from the vector space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_removed</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be removed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_removed</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7ff92e5d40e6faf667a0b1f6b8fad791"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::remove_higher_space_dimensions" ref="7ff92e5d40e6faf667a0b1f6b8fad791" args="(dimension_type new_dimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::remove_higher_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>new_dimension</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the higher dimensions of the vector space so that the resulting space will have dimension <code>new_dimension</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>new_dimensions</code> is greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="60138f2b5d41fd62c862fdcd7c4a1e61"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::map_space_dimensions" ref="60138f2b5d41fd62c862fdcd7c4a1e61" args="(const Partial_Function &amp;pfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Partial_Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::map_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const Partial_Function &amp;&nbsp;</td>
          <td class="paramname"> <em>pfunc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Grid_Map_Space_Dimensions">partial function</a>. 
<p>
If <code>pfunc</code> maps only some of the dimensions of <code>*this</code> then the rest will be projected away.<p>
If the highest dimension mapped to by <code>pfunc</code> is higher than the highest dimension in <code>*this</code> then the number of dimensions in <code>this</code> will be increased to the highest dimension mapped to by <code>pfunc</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfunc</em>&nbsp;</td><td>The partial function specifying the destiny of each space dimension.</td></tr>
  </table>
</dl>
The template class Partial_Function must provide the following methods. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> has_empty_codomain() const
</pre></div> returns <code>true</code> if and only if the represented partial function has an empty codomain (i.e., it is always undefined). The <code>has_empty_codomain()</code> method will always be called before the methods below. However, if <code>has_empty_codomain()</code> returns <code>true</code>, none of the functions below will be called. <div class="fragment"><pre class="fragment">      <a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> max_in_codomain() const
</pre></div> returns the maximum value that belongs to the codomain of the partial function. The <code>max_in_codomain()</code> method is called at most once. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> maps(<a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i, <a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a>&amp; j) <span class="keyword">const</span>
</pre></div> Let <img class="formulaInl" alt="$f$" src="form_323.png"> be the represented function and <img class="formulaInl" alt="$k$" src="form_286.png"> be the value of <code>i</code>. If <img class="formulaInl" alt="$f$" src="form_323.png"> is defined in <img class="formulaInl" alt="$k$" src="form_286.png">, then <img class="formulaInl" alt="$f(k)$" src="form_646.png"> is assigned to <code>j</code> and <code>true</code> is returned. If <img class="formulaInl" alt="$f$" src="form_323.png"> is undefined in <img class="formulaInl" alt="$k$" src="form_286.png">, then <code>false</code> is returned. This method is called at most <img class="formulaInl" alt="$n$" src="form_0.png"> times, where <img class="formulaInl" alt="$n$" src="form_0.png"> is the dimension of the vector space enclosing the grid.<p>
The result is undefined if <code>pfunc</code> does not encode a partial function with the properties described in the <a class="el" href="main.html#Grid_Map_Space_Dimensions">specification of the mapping operator</a>. 
</div>
</div><p>
<a class="anchor" name="f6df34e5e4ab9beab41cd76897d64c72"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::expand_space_dimension" ref="f6df34e5e4ab9beab41cd76897d64c72" args="(Variable var, dimension_type m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::expand_space_dimension           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension to be replicated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of replicas to be created.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> does not correspond to a dimension of the vector space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#fe613a3da3edc3cb4506f70d409f061d" title="Returns the maximum space dimension all kinds of Grid can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
</dl>
If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png">, with <img class="formulaInl" alt="$n > 0$" src="form_167.png">, and <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_135.png">, then the <img class="formulaInl" alt="$k$" src="form_286.png">-th space dimension is <a class="el" href="main.html#Grid_Expand_Space_Dimension">expanded</a> to <code>m</code> new space dimensions <img class="formulaInl" alt="$n$" src="form_0.png">, <img class="formulaInl" alt="$n+1$" src="form_168.png">, <img class="formulaInl" alt="$\dots$" src="form_647.png">, <img class="formulaInl" alt="$n+m-1$" src="form_170.png">. 
</div>
</div><p>
<a class="anchor" name="18ec2da355442e02ae67313ed5b48933"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::fold_space_dimensions" ref="18ec2da355442e02ae67313ed5b48933" args="(const Variables_Set &amp;to_be_folded, Variable var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::fold_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_folded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Folds the space dimensions in <code>to_be_folded</code> into <code>var</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_folded</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be folded;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension that is the destination of the folding operation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>var</code> or with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_folded</code>. Also thrown if <code>var</code> is contained in <code>to_be_folded</code>.</td></tr>
  </table>
</dl>
If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png">, with <img class="formulaInl" alt="$n > 0$" src="form_167.png">, <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_135.png">, <code>to_be_folded</code> is a set of variables whose maximum space dimension is also less than or equal to <img class="formulaInl" alt="$n$" src="form_0.png">, and <code>var</code> is not a member of <code>to_be_folded</code>, then the space dimensions corresponding to variables in <code>to_be_folded</code> are <a class="el" href="main.html#Grid_Fold_Space_Dimensions">folded</a> into the <img class="formulaInl" alt="$k$" src="form_286.png">-th space dimension. 
</div>
</div><p>
<a class="anchor" name="5f6fcc1dab2b08eff20b41d1412d1e2d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::hash_code" ref="5f6fcc1dab2b08eff20b41d1412d1e2d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Parma_Polyhedra_Library::Grid::hash_code           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a 32-bit hash code for <code>*this</code>. 
<p>
If <code>x</code> and <code>y</code> are such that <code>x == y</code>, then <code>x.hash_code() == y.hash_code()</code>. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="87d004db7f8febf6f9c96b4a2a1c85e5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::operator==" ref="87d004db7f8febf6f9c96b4a2a1c85e5" args="(const Grid &amp;x, const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same grid. 
<p>
Note that <code>x</code> and <code>y</code> may be dimension-incompatible grids: in those cases, the value <code>false</code> is returned. 
</div>
</div><p>
<a class="anchor" name="1cb88a546d32e7b5c07dc25055e33235"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::operator&lt;&lt;" ref="1cb88a546d32e7b5c07dc25055e33235" args="(std::ostream &amp;s, const Grid &amp;gr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output operator. 
<p>
Writes a textual representation of <code>gr</code> on <code>s:</code> <code>false</code> is written if <code>gr</code> is an empty grid; <code>true</code> is written if <code>gr</code> is a universe grid; a minimized system of congruences defining <code>gr</code> is written otherwise, all congruences in one row separated by ", "s. 
</div>
</div><p>
<a class="anchor" name="9e17201a9a12235a9a96cc31cfffd38f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::operator!=" ref="9e17201a9a12235a9a96cc31cfffd38f" args="(const Grid &amp;x, const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different grids. 
<p>
Note that <code>x</code> and <code>y</code> may be dimension-incompatible grids: in those cases, the value <code>true</code> is returned.
</div>
</div><p>
<a class="anchor" name="d452407f89cb560e83fb81938c12a585"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::swap" ref="d452407f89cb560e83fb81938c12a585" args="(Parma_Polyhedra_Library::Grid &amp;x, Parma_Polyhedra_Library::Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Parma_Polyhedra_Library::Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Parma_Polyhedra_Library::Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specializes <code>std::swap</code>. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 18 07:13:19 2009 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
