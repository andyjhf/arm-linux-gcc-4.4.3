<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PPL: Parma_Polyhedra_Library::Octagonal_Shape&lt; T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::Octagonal_Shape&lt; T &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::Octagonal_Shape" -->An octagonal shape.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ppl.hh&gt;</code>
<p>

<p>
<a href="classParma__Polyhedra__Library_1_1Octagonal__Shape-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96bae54a01fe00bad4306bec61bb4687"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::coefficient_type_base" ref="96bae54a01fe00bad4306bec61bb4687" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#96bae54a01fe00bad4306bec61bb4687">coefficient_type_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The numeric base type upon which OSs are built. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="891529f721ff485fe2ec90ac48952cc6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::coefficient_type" ref="891529f721ff485fe2ec90ac48952cc6" args="" -->
typedef <a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">N</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#891529f721ff485fe2ec90ac48952cc6">coefficient_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The (extended) numeric type of the inhomogeneous term of the inequalities defining an OS. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b9f6fbac96e03a00d061a2cd2ca2baf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::ascii_dump" ref="3b9f6fbac96e03a00d061a2cd2ca2baf" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#3b9f6fbac96e03a00d061a2cd2ca2baf">ascii_dump</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7dcb9b448c8c0171e18f29551077d133"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::ascii_dump" ref="7dcb9b448c8c0171e18f29551077d133" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#7dcb9b448c8c0171e18f29551077d133">ascii_dump</a> (std::ostream &amp;s) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="04704288741dbaf6f50e8fc09c43f737"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::print" ref="04704288741dbaf6f50e8fc09c43f737" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#04704288741dbaf6f50e8fc09c43f737">print</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="afdd0083c1c10d49e06f4718a826ae1b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::ascii_load" ref="afdd0083c1c10d49e06f4718a826ae1b" args="(std::istream &amp;s)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#afdd0083c1c10d49e06f4718a826ae1b">ascii_load</a> (std::istream &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#7dcb9b448c8c0171e18f29551077d133" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1091bf4d0e8ce7672f907cf5e7921120"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::total_memory_in_bytes" ref="1091bf4d0e8ce7672f907cf5e7921120" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#1091bf4d0e8ce7672f907cf5e7921120">total_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f9503f2a0fd1535ce7cb9465908006dc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::external_memory_in_bytes" ref="f9503f2a0fd1535ce7cb9465908006dc" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#f9503f2a0fd1535ce7cb9465908006dc">external_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#6f9c769f48ed91cd71bec247b7733430">hash_code</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a 32-bit hash code for <code>*this</code>.  <a href="#6f9c769f48ed91cd71bec247b7733430"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, Assignment, Swap and Destructor</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#b38e5d3ce8cc120ce4b534bc43d90d34">Octagonal_Shape</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions=0, <a class="el" href="group__PPL__CXX__interface.html#g616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind=UNIVERSE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an universe or empty OS of the specified space dimension.  <a href="#b38e5d3ce8cc120ce4b534bc43d90d34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#0a8906c6b7e5b785bd457641007d1359">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;x, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy-constructor.  <a href="#0a8906c6b7e5b785bd457641007d1359"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#c5f6c7896e64b8750e2cd9729c19d66e">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a conservative, upward approximation of <code>y</code>.  <a href="#c5f6c7896e64b8750e2cd9729c19d66e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#e37107ec8d1402bb69ac6462d7f4646d">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS from the system of constraints <code>cs</code>.  <a href="#e37107ec8d1402bb69ac6462d7f4646d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#5e74729a5f7cabef57fb795cc728869c">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS from a system of congruences.  <a href="#5e74729a5f7cabef57fb795cc728869c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#8a329c1ea10527cde394abab15b67356">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS from the system of generators <code>gs</code>.  <a href="#8a329c1ea10527cde394abab15b67356"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#46797ad634dc267c1264aa046c69f9f8">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS from the polyhedron <code>ph</code>.  <a href="#46797ad634dc267c1264aa046c69f9f8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#c720d2c0875eba7d87a4068876092025">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS out of a box.  <a href="#c720d2c0875eba7d87a4068876092025"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#fa8decb7c7093c9cde1255a6c1af62d4">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;grid, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS that approximates a grid.  <a href="#fa8decb7c7093c9cde1255a6c1af62d4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#dc326b7c8687b685c42817f7fec425e0">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;bd, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS from a BD shape.  <a href="#dc326b7c8687b685c42817f7fec425e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0a7f222ac228554b369d460087815b87"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::operator=" ref="0a7f222ac228554b369d460087815b87" args="(const Octagonal_Shape &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#0a7f222ac228554b369d460087815b87">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The assignment operator. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5e4f3b53b4dd4f7f57a13df638b162e4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::swap" ref="5e4f3b53b4dd4f7f57a13df638b162e4" args="(Octagonal_Shape &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#5e4f3b53b4dd4f7f57a13df638b162e4">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps <code>*this</code> with octagon <code>y</code>. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1921cd40fb0920e1173cf67418c63fe"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::~Octagonal_Shape" ref="f1921cd40fb0920e1173cf67418c63fe" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#f1921cd40fb0920e1173cf67418c63fe">~Octagonal_Shape</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the Octagonal_Shape</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed38463ae788879580d6372653452603"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::space_dimension" ref="ed38463ae788879580d6372653452603" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ed38463ae788879580d6372653452603">space_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8b99abb6e15eedbdb94e2466e8304c52"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::affine_dimension" ref="8b99abb6e15eedbdb94e2466e8304c52" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#8b99abb6e15eedbdb94e2466e8304c52">affine_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <img class="formulaInl" alt="$0$" src="form_562.png">, if <code>*this</code> is empty; otherwise, returns the <a class="el" href="main.html#Affine_Independence_and_Affine_Dimension">affine dimension</a> of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b5dfec17f683d1cbe01cfc71d601108c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::constraints" ref="b5dfec17f683d1cbe01cfc71d601108c" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#b5dfec17f683d1cbe01cfc71d601108c">constraints</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of constraints defining <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f14ea5b6122685afd62a3df786512d77"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::minimized_constraints" ref="f14ea5b6122685afd62a3df786512d77" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#f14ea5b6122685afd62a3df786512d77">minimized_constraints</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a minimized system of constraints defining <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f7fd07f1f8d91c830130c061da7b6c56"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::congruences" ref="f7fd07f1f8d91c830130c061da7b6c56" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#f7fd07f1f8d91c830130c061da7b6c56">congruences</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of (equality) congruences satisfied by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7c86f7ff6b09ff72e3ee3382b4c933b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::minimized_congruences" ref="b7c86f7ff6b09ff72e3ee3382b4c933b" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#b7c86f7ff6b09ff72e3ee3382b4c933b">minimized_congruences</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a minimal system of (equality) congruences satisfied by <code>*this</code> with the same affine dimension as <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#e85fbe787fa3e172ecf6a63b2847d69a">contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>.  <a href="#e85fbe787fa3e172ecf6a63b2847d69a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#f2c70f89a472f7fa34ba64817693776a">strictly_contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>.  <a href="#f2c70f89a472f7fa34ba64817693776a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#0d1677ef76c939ca2025722d2ee249e2">is_disjoint_from</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint.  <a href="#0d1677ef76c939ca2025722d2ee249e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#81c8a26a02090eb4fb9255dd814514a8">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the constraint <code>c</code>.  <a href="#81c8a26a02090eb4fb9255dd814514a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#2d266342acc104c59dc0046242ccdac8">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the congruence <code>cg</code>.  <a href="#2d266342acc104c59dc0046242ccdac8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#46a4105c8476e5f5260a775777398586">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the generator <code>g</code>.  <a href="#46a4105c8476e5f5260a775777398586"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="353fe86259fbb2dd09d451e9dd468676"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::is_empty" ref="353fe86259fbb2dd09d451e9dd468676" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#353fe86259fbb2dd09d451e9dd468676">is_empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an empty OS. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aae8e418bb3d7a1432117530eaea7ec4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::is_universe" ref="aae8e418bb3d7a1432117530eaea7ec4" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#aae8e418bb3d7a1432117530eaea7ec4">is_universe</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a universe OS. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e3be22e7dcdf54fdc0fb976fd755d0c7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::is_discrete" ref="e3be22e7dcdf54fdc0fb976fd755d0c7" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#e3be22e7dcdf54fdc0fb976fd755d0c7">is_discrete</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is discrete. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="74d2b64496aa448a85ec0b370cee0977"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::is_bounded" ref="74d2b64496aa448a85ec0b370cee0977" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#74d2b64496aa448a85ec0b370cee0977">is_bounded</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a bounded OS. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3905c42e02befd8a894c57abd9f972f5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::is_topologically_closed" ref="3905c42e02befd8a894c57abd9f972f5" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#3905c42e02befd8a894c57abd9f972f5">is_topologically_closed</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a topologically closed subset of the vector space. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="22b6ac7ec1477dc82d6db22900b59be2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::contains_integer_point" ref="22b6ac7ec1477dc82d6db22900b59be2" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#22b6ac7ec1477dc82d6db22900b59be2">contains_integer_point</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains (at least) an integer point. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#d423a6ddce01a2f2efb34b826d0de921">constrains</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>.  <a href="#d423a6ddce01a2f2efb34b826d0de921"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#7ae373e57180f03b09aa0e38d1f19811">bounds_from_above</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>.  <a href="#7ae373e57180f03b09aa0e38d1f19811"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#1ae372d4f3b58cfa4af6edd51d845209">bounds_from_below</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>.  <a href="#1ae372d4f3b58cfa4af6edd51d845209"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#0e90a75aac44c14997804b8911ff7bbb">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed.  <a href="#0e90a75aac44c14997804b8911ff7bbb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#cb19de0243a618e9bf3d62e2ee04ae01">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed.  <a href="#cb19de0243a618e9bf3d62e2ee04ae01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#cfec639e917dfd6eb63c4006ac55b807">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed.  <a href="#cfec639e917dfd6eb63c4006ac55b807"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#217e4addfae235df12c449320e65f891">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed.  <a href="#217e4addfae235df12c449320e65f891"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="35518da8c480784110d40b680256bd61"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::OK" ref="35518da8c480784110d40b680256bd61" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#35518da8c480784110d40b680256bd61">OK</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Space-Dimension Preserving Member Functions that May Modify the Octagonal_Shape</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ae058fd9619a17e121c3aab9b0612d81">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of constraint <code>c</code> to the system of constraints defining <code>*this</code>.  <a href="#ae058fd9619a17e121c3aab9b0612d81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#dc269190695c1745ab086168fcf35835">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of constraints defining <code>*this</code>.  <a href="#dc269190695c1745ab086168fcf35835"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#0e09e7efc2f63aba534614086427bf49">add_recycled_constraints</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code>.  <a href="#0e09e7efc2f63aba534614086427bf49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#0e9ecea59dea0ccb1cc3600bc11f1056">add_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> a constraint equivalent to the congruence <code>cg</code>.  <a href="#0e9ecea59dea0ccb1cc3600bc11f1056"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a493e3939364ce0db66b42f0ef6511d0">add_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>.  <a href="#a493e3939364ce0db66b42f0ef6511d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#1cd37a76428add108f267548ae76664b">add_recycled_congruences</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>.  <a href="#1cd37a76428add108f267548ae76664b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#594973c5284386e52b8c33b206a47907">refine_with_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of constraint <code>c</code> to refine the system of octagonal constraints defining <code>*this</code>.  <a href="#594973c5284386e52b8c33b206a47907"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#580264341ec83f4bf3d6da1205939b0a">refine_with_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of congruence <code>cg</code> to refine the system of octagonal constraints of <code>*this</code>.  <a href="#580264341ec83f4bf3d6da1205939b0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#c6376a87e99d3cdabaa6ee7542474849">refine_with_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the constraints in <code>cs</code> to refine the system of octagonal constraints defining <code>*this</code>.  <a href="#c6376a87e99d3cdabaa6ee7542474849"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a317313059bdf973567d2fcf5e030212">refine_with_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the congruences in <code>cgs</code> to refine the system of octagonal constraints defining <code>*this</code>.  <a href="#a317313059bdf973567d2fcf5e030212"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#fea57a711a6b7a5d501112b84b246759">unconstrain</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>.  <a href="#fea57a711a6b7a5d501112b84b246759"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#6ff5e78b07441619f850114578ca48d5">unconstrain</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_unconstrained)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>to_be_unconstrained</code>, assigning the result to <code>*this</code>.  <a href="#6ff5e78b07441619f850114578ca48d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#bfde1aac87d8218fce0fa9b4ea8a5eb1">intersection_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>.  <a href="#bfde1aac87d8218fce0fa9b4ea8a5eb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ec298ee7df246c945e6a56442e04176d">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the smallest OS that contains the convex union of <code>*this</code> and <code>y</code>.  <a href="#ec298ee7df246c945e6a56442e04176d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#bfb434e3d574f4bd53314ac8749c4731">upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned.  <a href="#bfb434e3d574f4bd53314ac8749c4731"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#72782e7d9a6612efd73b253b0f862c6b">difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the smallest octagon containing the set difference of <code>*this</code> and <code>y</code>.  <a href="#72782e7d9a6612efd73b253b0f862c6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#0a0d8c78069019f44dc34ebab82ecfc6">simplify_using_context_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty.  <a href="#0a0d8c78069019f44dc34ebab82ecfc6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ccc6c6488ea9d8555ea8e978cf188749">affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#affine_relation">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#ccc6c6488ea9d8555ea8e978cf188749"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ba9abb279871c30a4f0c6cbb188fecc1">affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#affine_relation">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#ba9abb279871c30a4f0c6cbb188fecc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#934cc1f45a6d438f5d468276140cd5a8">generalized_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine transfer function</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>.  <a href="#934cc1f45a6d438f5d468276140cd5a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#196d1efc79437ca1d96b79b7cd60387f">generalized_affine_image</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine transfer function</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>.  <a href="#196d1efc79437ca1d96b79b7cd60387f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#b499fba7b7be2932147748248180e057">bounded_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">.  <a href="#b499fba7b7be2932147748248180e057"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#702b00ff42a88c23ab25eecf0e9acef0">generalized_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>.  <a href="#702b00ff42a88c23ab25eecf0e9acef0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#25f104e58f88e05dfcb905bcd66e493b">generalized_affine_preimage</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>.  <a href="#25f104e58f88e05dfcb905bcd66e493b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#0d4db6f54c7332e1a2e0bc85e16ba176">bounded_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">.  <a href="#0d4db6f54c7332e1a2e0bc85e16ba176"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#44e10aa0180433db7d19fb8e473dc829">time_elapse_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>.  <a href="#44e10aa0180433db7d19fb8e473dc829"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d8d04d80653fb850dd92468af1995f97"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::topological_closure_assign" ref="d8d04d80653fb850dd92468af1995f97" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#d8d04d80653fb850dd92468af1995f97">topological_closure_assign</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#1d780ef5b99cc9752eb322353b7b6b08">CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>.  <a href="#1d780ef5b99cc9752eb322353b7b6b08"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#047e2a717168ae129338109f1afc9a7a">CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y, Iterator first, Iterator last, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>.  <a href="#047e2a717168ae129338109f1afc9a7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#9b7061aa20aa4b513216bcdb1a905ce7">BHMZ05_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> between <code>*this</code> and <code>y</code>.  <a href="#9b7061aa20aa4b513216bcdb1a905ce7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="173628da404c1dc2c4d423cad7f9f960"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::widening_assign" ref="173628da404c1dc2c4d423cad7f9f960" args="(const Octagonal_Shape &amp;y, unsigned *tp=0)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#173628da404c1dc2c4d423cad7f9f960">widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as BHMZ05_widening_assign(y, tp). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#fa62abe41a99d6a01cca319ed860bb5b">limited_BHMZ05_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#fa62abe41a99d6a01cca319ed860bb5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#46d5dc7df45abdea275f0295fee58c23">CC76_narrowing_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restores from <code>y</code> the constraints of <code>*this</code>, lost by <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> applications.  <a href="#46d5dc7df45abdea275f0295fee58c23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#87aadd3a9d47e978a32c9867b13220a4">limited_CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#87aadd3a9d47e978a32c9867b13220a4"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Dimension of the Vector Space</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#703f57855b17ef63b28f88fe13a51870">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new dimensions and embeds the old OS into the new space.  <a href="#703f57855b17ef63b28f88fe13a51870"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#204fb0538d07ee8ac3d5f2724419928b">add_space_dimensions_and_project</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new dimensions to the OS and does not embed it in the new space.  <a href="#204fb0538d07ee8ac3d5f2724419928b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#f41476c22751c8d79e8599443aea93da">concatenate_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order.  <a href="#f41476c22751c8d79e8599443aea93da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#1169e57865dfa83ffc8cc23071248340">remove_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_removed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the specified dimensions.  <a href="#1169e57865dfa83ffc8cc23071248340"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ba8ba56b075b2be7b6309cfaed039070">remove_higher_space_dimensions</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> new_dimension)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the higher dimensions so that the resulting space will have dimension <code>new_dimension</code>.  <a href="#ba8ba56b075b2be7b6309cfaed039070"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Partial_Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#34dbbfe20e987a3d55c7a3f2d08f1aed">map_space_dimensions</a> (const Partial_Function &amp;pfunc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>.  <a href="#34dbbfe20e987a3d55c7a3f2d08f1aed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#100662089d61a01ea43a28a944da266c">expand_space_dimension</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>.  <a href="#100662089d61a01ea43a28a944da266c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#128413fc4c3051aaa9033a8030509ae5">fold_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_folded, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Folds the space dimensions in <code>to_be_folded</code> into <code>var</code>.  <a href="#128413fc4c3051aaa9033a8030509ae5"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="38da38d0fab7eed9ee09fdb11f88fd15"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::max_space_dimension" ref="38da38d0fab7eed9ee09fdb11f88fd15" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#38da38d0fab7eed9ee09fdb11f88fd15">max_space_dimension</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension that an OS can handle. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="51fb0220102e525b11cdb06dcbe322c7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::can_recycle_constraint_systems" ref="51fb0220102e525b11cdb06dcbe322c7" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#51fb0220102e525b11cdb06dcbe322c7">can_recycle_constraint_systems</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns false indicating that this domain cannot recycle constraints. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2f13e4ffe7b47ec50721791877b41622"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::can_recycle_congruence_systems" ref="2f13e4ffe7b47ec50721791877b41622" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#2f13e4ffe7b47ec50721791877b41622">can_recycle_congruence_systems</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns false indicating that this domain cannot recycle congruences. <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#1c59e94611b71ddd67acd033a05bbbc7">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same octagon.  <a href="#1c59e94611b71ddd67acd033a05bbbc7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#137dcf52993d2ff3dd6e4678b45baf56">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;oct)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#137dcf52993d2ff3dd6e4678b45baf56"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#1c2f0ae89d7bf247a76c40282f31758e">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different shapes.  <a href="#1c2f0ae89d7bf247a76c40282f31758e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#c2cd6705bce0af4bd9880b990baf1198">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#c2cd6705bce0af4bd9880b990baf1198"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Temp , typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#025902247d9c8b46d92c514c1646ff69">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#025902247d9c8b46d92c514c1646ff69"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#af0214aee8884dc52be4e061d6b4df94">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#af0214aee8884dc52be4e061d6b4df94"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Temp , typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#2560fe5ce16277c4b4db17e951047028">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#2560fe5ce16277c4b4db17e951047028"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#6f27f62cf5d65574cbb44025b1b3e585">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code>.  <a href="#6f27f62cf5d65574cbb44025b1b3e585"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Temp , typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#715054228bad30a232707ed0357cdd98">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code>.  <a href="#715054228bad30a232707ed0357cdd98"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#62d44847fe22abb82cbac84a776a9c72">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt; &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#62d44847fe22abb82cbac84a776a9c72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#09eda1d1953d8f83e4352c6fe78cbded">coherent_index</a> (const <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> i)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T&gt;<br>
 class Parma_Polyhedra_Library::Octagonal_Shape&lt; T &gt;</h3>

An octagonal shape. 
<p>
The class template Octagonal_Shape&lt;T&gt; allows for the efficient representation of a restricted kind of <em>topologically closed</em> convex polyhedra called <em>octagonal shapes</em> (OSs, for short). The name comes from the fact that, in a vector space of dimension 2, bounded OSs are polygons with at most eight sides. The closed affine half-spaces that characterize the OS can be expressed by constraints of the form <p class="formulaDsp">
<img class="formulaDsp" alt="\[ ax_i + bx_j \leq k \]" src="form_544.png">
<p>
 where <img class="formulaInl" alt="$a, b \in \{-1, 0, 1\}$" src="form_545.png"> and <img class="formulaInl" alt="$k$" src="form_286.png"> is a rational number, which are called <em>octagonal constraints</em>.<p>
Based on the class template type parameter <code>T</code>, a family of extended numbers is built and used to approximate the inhomogeneous term of octagonal constraints. These extended numbers provide a representation for the value <img class="formulaInl" alt="$+\infty$" src="form_529.png">, as well as <em>rounding-aware</em> implementations for several arithmetic functions. The value of the type parameter <code>T</code> may be one of the following:<ul>
<li>a bounded precision integer type (e.g., <code>int32_t</code> or <code>int64_t</code>);</li><li>a bounded precision floating point type (e.g., <code>float</code> or <code>double</code>);</li><li>an unbounded integer or rational type, as provided by GMP (i.e., <code>mpz_class</code> or <code>mpq_class</code>).</li></ul>
<p>
The user interface for OSs is meant to be as similar as possible to the one developed for the polyhedron class <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a>.<p>
The OS domain <em>optimally supports</em>:<ul>
<li>tautological and inconsistent constraints and congruences;</li><li>octagonal constraints;</li><li>non-proper congruences (i.e., equalities) that are expressible as octagonal constraints.</li></ul>
<p>
Depending on the method, using a constraint or congruence that is not optimally supported by the domain will either raise an exception or result in a (possibly non-optimal) upward approximation.<p>
A constraint is octagonal if it has the form <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \pm a_i x_i \pm a_j x_j \relsym b \]" src="form_546.png">
<p>
 where <img class="formulaInl" alt="$\mathord{\relsym} \in \{ \leq, =, \geq \}$" src="form_531.png"> and <img class="formulaInl" alt="$a_i$" src="form_224.png">, <img class="formulaInl" alt="$a_j$" src="form_532.png">, <img class="formulaInl" alt="$b$" src="form_225.png"> are integer coefficients such that <img class="formulaInl" alt="$a_i = 0$" src="form_533.png">, or <img class="formulaInl" alt="$a_j = 0$" src="form_534.png">, or <img class="formulaInl" alt="$a_i = a_j$" src="form_535.png">. The user is warned that the above octagonal <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> object will be mapped into a <em>correct</em> and <em>optimal</em> approximation that, depending on the expressive power of the chosen template argument <code>T</code>, may loose some precision. Also note that strict constraints are not octagonal.<p>
For instance, a <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> object encoding <img class="formulaInl" alt="$3x + 3y \leq 1$" src="form_547.png"> will be approximated by:<ul>
<li><img class="formulaInl" alt="$x + y \leq 1$" src="form_548.png">, if <code>T</code> is a (bounded or unbounded) integer type;</li><li><img class="formulaInl" alt="$x + y \leq \frac{1}{3}$" src="form_549.png">, if <code>T</code> is the unbounded rational type <code>mpq_class</code>;</li><li><img class="formulaInl" alt="$x + y \leq k$" src="form_550.png">, where <img class="formulaInl" alt="$k > \frac{1}{3}$" src="form_540.png">, if <code>T</code> is a floating point type (having no exact representation for <img class="formulaInl" alt="$\frac{1}{3}$" src="form_541.png">).</li></ul>
<p>
On the other hand, depending from the context, a <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> object encoding <img class="formulaInl" alt="$3x - y \leq 1$" src="form_542.png"> will be either upward approximated (e.g., by safely ignoring it) or it will cause an exception.<p>
In the following examples it is assumed that the type argument <code>T</code> is one of the possible instances listed above and that variables <code>x</code>, <code>y</code> and <code>z</code> are defined (where they are used) as follows: <div class="fragment"><pre class="fragment">    Variable x(0);
    Variable y(1);
    Variable z(2);
</pre></div><p>
<dl class="user" compact><dt><b>Example 1</b></dt><dd>The following code builds an OS corresponding to a cube in <img class="formulaInl" alt="$\Rset^3$" src="form_543.png">, given as a system of constraints: <div class="fragment"><pre class="fragment">    Constraint_System cs;
    cs.insert(x &gt;= 0);
    cs.insert(x &lt;= 3);
    cs.insert(y &gt;= 0);
    cs.insert(y &lt;= 3);
    cs.insert(z &gt;= 0);
    cs.insert(z &lt;= 3);
    Octagonal_Shape&lt;T&gt; oct(cs);
</pre></div> In contrast, the following code will raise an exception, since constraints 7, 8, and 9 are not octagonal: <div class="fragment"><pre class="fragment">    Constraint_System cs;
    cs.insert(x &gt;= 0);
    cs.insert(x &lt;= 3);
    cs.insert(y &gt;= 0);
    cs.insert(y &lt;= 3);
    cs.insert(z &gt;= 0);
    cs.insert(z &lt;= 3);
    cs.insert(x - 3*y &lt;= 5);    <span class="comment">// (7)</span>
    cs.insert(x - y + z &lt;= 5);  <span class="comment">// (8)</span>
    cs.insert(x + y + z &lt;= 5);  <span class="comment">// (9)</span>
    Octagonal_Shape&lt;T&gt; oct(cs);
</pre></div> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="b38e5d3ce8cc120ce4b534bc43d90d34"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="b38e5d3ce8cc120ce4b534bc43d90d34" args="(dimension_type num_dimensions=0, Degenerate_Element kind=UNIVERSE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>num_dimensions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em> = <code>UNIVERSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an universe or empty OS of the specified space dimension. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&nbsp;</td><td>The number of dimensions of the vector space enclosing the OS;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>Specifies whether the universe or the empty OS has to be built. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0a8906c6b7e5b785bd457641007d1359"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="0a8906c6b7e5b785bd457641007d1359" args="(const Octagonal_Shape &amp;x, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ordinary copy-constructor. 
<p>
The complexity argument is ignored. 
</div>
</div><p>
<a class="anchor" name="c5f6c7896e64b8750e2cd9729c19d66e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="c5f6c7896e64b8750e2cd9729c19d66e" args="(const Octagonal_Shape&lt; U &gt; &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a conservative, upward approximation of <code>y</code>. 
<p>
The complexity argument is ignored. 
</div>
</div><p>
<a class="anchor" name="e37107ec8d1402bb69ac6462d7f4646d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="e37107ec8d1402bb69ac6462d7f4646d" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an OS from the system of constraints <code>cs</code>. 
<p>
The OS inherits the space dimension of <code>cs</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>A system of constraints: constraints that are not <a class="el" href="main.html#Octagonal_Shapes">octagonal constraints</a> are ignored (even though they may have contributed to the space dimension).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of constraints <code>cs</code> contains strict inequalities. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5e74729a5f7cabef57fb795cc728869c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="5e74729a5f7cabef57fb795cc728869c" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an OS from a system of congruences. 
<p>
The OS inherits the space dimension of <code>cgs</code> <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>A system of congruences: some elements may be safely ignored. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8a329c1ea10527cde394abab15b67356"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="8a329c1ea10527cde394abab15b67356" args="(const Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an OS from the system of generators <code>gs</code>. 
<p>
Builds the smallest OS containing the polyhedron defined by <code>gs</code>. The OS inherits the space dimension of <code>gs</code>.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of generators is not empty but has no points. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="46797ad634dc267c1264aa046c69f9f8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="46797ad634dc267c1264aa046c69f9f8" args="(const Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an OS from the polyhedron <code>ph</code>. 
<p>
Builds an OS containing <code>ph</code> using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the OS built is the smallest one containing <code>ph</code>. 
</div>
</div><p>
<a class="anchor" name="c720d2c0875eba7d87a4068876092025"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="c720d2c0875eba7d87a4068876092025" args="(const Box&lt; Interval &gt; &amp;box, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an OS out of a box. 
<p>
The OS inherits the space dimension of the box. The built OS is the most precise OS that includes the box.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The box representing the BDS to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>box</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fa8decb7c7093c9cde1255a6c1af62d4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="fa8decb7c7093c9cde1255a6c1af62d4" args="(const Grid &amp;grid, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an OS that approximates a grid. 
<p>
The OS inherits the space dimension of the grid. The built OS is the most precise OS that includes the grid.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>grid</em>&nbsp;</td><td>The grid used to build the OS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>grid</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dc326b7c8687b685c42817f7fec425e0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="dc326b7c8687b685c42817f7fec425e0" args="(const BD_Shape&lt; U &gt; &amp;bd, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an OS from a BD shape. 
<p>
The OS inherits the space dimension of the BD shape. The built OS is the most precise OS that includes the BD shape.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bd</em>&nbsp;</td><td>The BD shape used to build the OS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>bd</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e85fbe787fa3e172ecf6a63b2847d69a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::contains" ref="e85fbe787fa3e172ecf6a63b2847d69a" args="(const Octagonal_Shape &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f2c70f89a472f7fa34ba64817693776a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::strictly_contains" ref="f2c70f89a472f7fa34ba64817693776a" args="(const Octagonal_Shape &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::strictly_contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0d1677ef76c939ca2025722d2ee249e2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::is_disjoint_from" ref="0d1677ef76c939ca2025722d2ee249e2" args="(const Octagonal_Shape &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::is_disjoint_from           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>x</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="81c8a26a02090eb4fb9255dd814514a8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::relation_with" ref="81c8a26a02090eb4fb9255dd814514a8" args="(const Constraint &amp;c) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::relation_with           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the relations holding between <code>*this</code> and the constraint <code>c</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2d266342acc104c59dc0046242ccdac8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::relation_with" ref="2d266342acc104c59dc0046242ccdac8" args="(const Congruence &amp;cg) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::relation_with           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the relations holding between <code>*this</code> and the congruence <code>cg</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="46a4105c8476e5f5260a775777398586"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::relation_with" ref="46a4105c8476e5f5260a775777398586" args="(const Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::relation_with           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the relations holding between <code>*this</code> and the generator <code>g</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d423a6ddce01a2f2efb34b826d0de921"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::constrains" ref="d423a6ddce01a2f2efb34b826d0de921" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::constrains           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7ae373e57180f03b09aa0e38d1f19811"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::bounds_from_above" ref="7ae373e57180f03b09aa0e38d1f19811" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::bounds_from_above           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1ae372d4f3b58cfa4af6edd51d845209"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::bounds_from_below" ref="1ae372d4f3b58cfa4af6edd51d845209" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::bounds_from_below           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e90a75aac44c14997804b8911ff7bbb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::maximize" ref="0e90a75aac44c14997804b8911ff7bbb" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::maximize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if and only if the supremum is also the maximum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code> and <code>maximum</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="cb19de0243a618e9bf3d62e2ee04ae01"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::maximize" ref="cb19de0243a618e9bf3d62e2ee04ae01" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::maximize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if and only if the supremum is also the maximum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>When maximization succeeds, will be assigned the point or closure point where <code>expr</code> reaches its supremum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code>, <code>maximum</code> and <code>g</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="cfec639e917dfd6eb63c4006ac55b807"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::minimize" ref="cfec639e917dfd6eb63c4006ac55b807" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if and only if the infimum is also the minimum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code> and <code>minimum</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="217e4addfae235df12c449320e65f891"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::minimize" ref="217e4addfae235df12c449320e65f891" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if and only if the infimum is also the minimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>When minimization succeeds, will be assigned a point or closure point where <code>expr</code> reaches its infimum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code>, <code>minimum</code> and <code>g</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="ae058fd9619a17e121c3aab9b0612d81"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_constraint" ref="ae058fd9619a17e121c3aab9b0612d81" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_constraint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of constraint <code>c</code> to the system of constraints defining <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint to be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible, or <code>c</code> is not optimally supported by the OS domain. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dc269190695c1745ab086168fcf35835"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_constraints" ref="dc269190695c1745ab086168fcf35835" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_constraints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the constraints in <code>cs</code> to the system of constraints defining <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints that will be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible, or <code>cs</code> contains a constraint which is not optimally supported by the OS domain. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e09e7efc2f63aba534614086427bf49"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_recycled_constraints" ref="0e09e7efc2f63aba534614086427bf49" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_recycled_constraints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be added to <code>*this</code>. The constraints in <code>cs</code> may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible, or <code>cs</code> contains a constraint which is not optimally supported by the OS domain.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e9ecea59dea0ccb1cc3600bc11f1056"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_congruence" ref="0e9ecea59dea0ccb1cc3600bc11f1056" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_congruence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> a constraint equivalent to the congruence <code>cg</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&nbsp;</td><td>The congruence to be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible, or <code>cg</code> is not optimally supported by the OS domain. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a493e3939364ce0db66b42f0ef6511d0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_congruences" ref="a493e3939364ce0db66b42f0ef6511d0" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_congruences           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruences to be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, or <code>cgs</code> contains a congruence which is not optimally supported by the OS domain. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1cd37a76428add108f267548ae76664b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_recycled_congruences" ref="1cd37a76428add108f267548ae76664b" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_recycled_congruences           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruence system to be added to <code>*this</code>. The congruences in <code>cgs</code> may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, or <code>cgs</code> contains a congruence which is not optimally supported by the OS domain.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="594973c5284386e52b8c33b206a47907"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::refine_with_constraint" ref="594973c5284386e52b8c33b206a47907" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::refine_with_constraint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of constraint <code>c</code> to refine the system of octagonal constraints defining <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint. If it is not a octagonal constraint, it will be ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="580264341ec83f4bf3d6da1205939b0a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::refine_with_congruence" ref="580264341ec83f4bf3d6da1205939b0a" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::refine_with_congruence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of congruence <code>cg</code> to refine the system of octagonal constraints of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&nbsp;</td><td>The congruence. If it is not a octagonal equality, it will be ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c6376a87e99d3cdabaa6ee7542474849"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::refine_with_constraints" ref="c6376a87e99d3cdabaa6ee7542474849" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::refine_with_constraints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of the constraints in <code>cs</code> to refine the system of octagonal constraints defining <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be used. Constraints that are not octagonal are ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a317313059bdf973567d2fcf5e030212"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::refine_with_congruences" ref="a317313059bdf973567d2fcf5e030212" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::refine_with_congruences           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of the congruences in <code>cgs</code> to refine the system of octagonal constraints defining <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruence system to be used. Congruences that are not octagonal equalities are ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fea57a711a6b7a5d501112b84b246759"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::unconstrain" ref="fea57a711a6b7a5d501112b84b246759" args="(Variable var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::unconstrain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The space dimension that will be unconstrained.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6ff5e78b07441619f850114578ca48d5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::unconstrain" ref="6ff5e78b07441619f850114578ca48d5" args="(const Variables_Set &amp;to_be_unconstrained)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::unconstrain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_unconstrained</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>to_be_unconstrained</code>, assigning the result to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_unconstrained</em>&nbsp;</td><td>The set of space dimension that will be unconstrained.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_removed</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bfde1aac87d8218fce0fa9b4ea8a5eb1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::intersection_assign" ref="bfde1aac87d8218fce0fa9b4ea8a5eb1" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::intersection_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ec298ee7df246c945e6a56442e04176d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::upper_bound_assign" ref="ec298ee7df246c945e6a56442e04176d" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::upper_bound_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the smallest OS that contains the convex union of <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bfb434e3d574f4bd53314ac8749c4731"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::upper_bound_assign_if_exact" ref="bfb434e3d574f4bd53314ac8749c4731" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::upper_bound_assign_if_exact           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="72782e7d9a6612efd73b253b0f862c6b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::difference_assign" ref="72782e7d9a6612efd73b253b0f862c6b" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::difference_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the smallest octagon containing the set difference of <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0a0d8c78069019f44dc34ebab82ecfc6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::simplify_using_context_assign" ref="0a0d8c78069019f44dc34ebab82ecfc6" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::simplify_using_context_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ccc6c6488ea9d8555ea8e978cf188749"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::affine_image" ref="ccc6c6488ea9d8555ea8e978cf188749" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#affine_relation">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is assigned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ba9abb279871c30a4f0c6cbb188fecc1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::affine_preimage" ref="ba9abb279871c30a4f0c6cbb188fecc1" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#affine_relation">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is substituted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="934cc1f45a6d438f5d468276140cd5a8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::generalized_affine_image" ref="934cc1f45a6d438f5d468276140cd5a8" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::generalized_affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine transfer function</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine transfer function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="196d1efc79437ca1d96b79b7cd60387f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::generalized_affine_image" ref="196d1efc79437ca1d96b79b7cd60387f" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::generalized_affine_image           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine transfer function</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b499fba7b7be2932147748248180e057"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::bounded_affine_image" ref="b499fba7b7be2932147748248180e057" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::bounded_affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="702b00ff42a88c23ab25eecf0e9acef0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::generalized_affine_preimage" ref="702b00ff42a88c23ab25eecf0e9acef0" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::generalized_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine transfer function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="25f104e58f88e05dfcb905bcd66e493b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::generalized_affine_preimage" ref="25f104e58f88e05dfcb905bcd66e493b" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::generalized_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0d4db6f54c7332e1a2e0bc85e16ba176"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::bounded_affine_preimage" ref="0d4db6f54c7332e1a2e0bc85e16ba176" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::bounded_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="44e10aa0180433db7d19fb8e473dc829"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::time_elapse_assign" ref="44e10aa0180433db7d19fb8e473dc829" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::time_elapse_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1d780ef5b99cc9752eb322353b7b6b08"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::CC76_extrapolation_assign" ref="1d780ef5b99cc9752eb322353b7b6b08" args="(const Octagonal_Shape &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::CC76_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>An OS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="047e2a717168ae129338109f1afc9a7a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::CC76_extrapolation_assign" ref="047e2a717168ae129338109f1afc9a7a" args="(const Octagonal_Shape &amp;y, Iterator first, Iterator last, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::CC76_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>An OS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>An iterator that points to the first stop_point.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>An iterator that points to the last stop_point.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9b7061aa20aa4b513216bcdb1a905ce7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::BHMZ05_widening_assign" ref="9b7061aa20aa4b513216bcdb1a905ce7" args="(const Octagonal_Shape &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::BHMZ05_widening_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> between <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>An OS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fa62abe41a99d6a01cca319ed860bb5b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::limited_BHMZ05_extrapolation_assign" ref="fa62abe41a99d6a01cca319ed860bb5b" args="(const Octagonal_Shape &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::limited_BHMZ05_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Improves the result of the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>An OS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened OS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible or if there is in <code>cs</code> a strict inequality. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="46d5dc7df45abdea275f0295fee58c23"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::CC76_narrowing_assign" ref="46d5dc7df45abdea275f0295fee58c23" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::CC76_narrowing_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restores from <code>y</code> the constraints of <code>*this</code>, lost by <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> applications. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>An OS that <em>must</em> contain <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="87aadd3a9d47e978a32c9867b13220a4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::limited_CC76_extrapolation_assign" ref="87aadd3a9d47e978a32c9867b13220a4" args="(const Octagonal_Shape &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::limited_CC76_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Improves the result of the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>An OS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened OS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a strict inequality. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="703f57855b17ef63b28f88fe13a51870"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_space_dimensions_and_embed" ref="703f57855b17ef63b28f88fe13a51870" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_space_dimensions_and_embed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <code>m</code> new dimensions and embeds the old OS into the new space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of dimensions to add.</td></tr>
  </table>
</dl>
The new dimensions will be those having the highest indexes in the new OS, which is characterized by a system of constraints in which the variables running through the new dimensions are not constrained. For instance, when starting from the OS <img class="formulaInl" alt="$\cO \sseq \Rset^2$" src="form_677.png"> and adding a third dimension, the result will be the OS <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, z)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cO \,\bigr\}. \]" src="form_678.png">
<p>
 
</div>
</div><p>
<a class="anchor" name="204fb0538d07ee8ac3d5f2724419928b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_space_dimensions_and_project" ref="204fb0538d07ee8ac3d5f2724419928b" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_space_dimensions_and_project           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <code>m</code> new dimensions to the OS and does not embed it in the new space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of dimensions to add.</td></tr>
  </table>
</dl>
The new dimensions will be those having the highest indexes in the new OS, which is characterized by a system of constraints in which the variables running through the new dimensions are all constrained to be equal to 0. For instance, when starting from the OS <img class="formulaInl" alt="$\cO \sseq \Rset^2$" src="form_677.png"> and adding a third dimension, the result will be the OS <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, 0)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cO \,\bigr\}. \]" src="form_679.png">
<p>
 
</div>
</div><p>
<a class="anchor" name="f41476c22751c8d79e8599443aea93da"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::concatenate_assign" ref="f41476c22751c8d79e8599443aea93da" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::concatenate_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the concatenation would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#38da38d0fab7eed9ee09fdb11f88fd15" title="Returns the maximum space dimension that an OS can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1169e57865dfa83ffc8cc23071248340"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::remove_space_dimensions" ref="1169e57865dfa83ffc8cc23071248340" args="(const Variables_Set &amp;to_be_removed)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::remove_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_removed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all the specified dimensions. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_removed</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the dimensions to be removed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_removed</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ba8ba56b075b2be7b6309cfaed039070"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::remove_higher_space_dimensions" ref="ba8ba56b075b2be7b6309cfaed039070" args="(dimension_type new_dimension)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::remove_higher_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>new_dimension</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the higher dimensions so that the resulting space will have dimension <code>new_dimension</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>new_dimension</code> is greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="34dbbfe20e987a3d55c7a3f2d08f1aed"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::map_space_dimensions" ref="34dbbfe20e987a3d55c7a3f2d08f1aed" args="(const Partial_Function &amp;pfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Partial_Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::map_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const Partial_Function &amp;&nbsp;</td>
          <td class="paramname"> <em>pfunc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfunc</em>&nbsp;</td><td>The partial function specifying the destiny of each dimension.</td></tr>
  </table>
</dl>
The template class Partial_Function must provide the following methods. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> has_empty_codomain() const
</pre></div> returns <code>true</code> if and only if the represented partial function has an empty codomain (i.e., it is always undefined). The <code>has_empty_codomain()</code> method will always be called before the methods below. However, if <code>has_empty_codomain()</code> returns <code>true</code>, none of the functions below will be called. <div class="fragment"><pre class="fragment">      <a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> max_in_codomain() const
</pre></div> returns the maximum value that belongs to the codomain of the partial function. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> maps(<a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i, <a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a>&amp; j) <span class="keyword">const</span>
</pre></div> Let <img class="formulaInl" alt="$f$" src="form_323.png"> be the represented function and <img class="formulaInl" alt="$k$" src="form_286.png"> be the value of <code>i</code>. If <img class="formulaInl" alt="$f$" src="form_323.png"> is defined in <img class="formulaInl" alt="$k$" src="form_286.png">, then <img class="formulaInl" alt="$f(k)$" src="form_646.png"> is assigned to <code>j</code> and <code>true</code> is returned. If <img class="formulaInl" alt="$f$" src="form_323.png"> is undefined in <img class="formulaInl" alt="$k$" src="form_286.png">, then <code>false</code> is returned.<p>
The result is undefined if <code>pfunc</code> does not encode a partial function with the properties described in the <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">specification of the mapping operator</a>. 
</div>
</div><p>
<a class="anchor" name="100662089d61a01ea43a28a944da266c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::expand_space_dimension" ref="100662089d61a01ea43a28a944da266c" args="(Variable var, dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::expand_space_dimension           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension to be replicated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of replicas to be created.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> does not correspond to a dimension of the vector space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#38da38d0fab7eed9ee09fdb11f88fd15" title="Returns the maximum space dimension that an OS can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
</dl>
If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png">, with <img class="formulaInl" alt="$n > 0$" src="form_167.png">, and <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_135.png">, then the <img class="formulaInl" alt="$k$" src="form_286.png">-th space dimension is <a class="el" href="main.html#expand_space_dimension">expanded</a> to <code>m</code> new space dimensions <img class="formulaInl" alt="$n$" src="form_0.png">, <img class="formulaInl" alt="$n+1$" src="form_168.png">, <img class="formulaInl" alt="$\dots$" src="form_647.png">, <img class="formulaInl" alt="$n+m-1$" src="form_170.png">. 
</div>
</div><p>
<a class="anchor" name="128413fc4c3051aaa9033a8030509ae5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::fold_space_dimensions" ref="128413fc4c3051aaa9033a8030509ae5" args="(const Variables_Set &amp;to_be_folded, Variable var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::fold_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_folded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Folds the space dimensions in <code>to_be_folded</code> into <code>var</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_folded</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be folded;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension that is the destination of the folding operation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>var</code> or with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_folded</code>. Also thrown if <code>var</code> is contained in <code>to_be_folded</code>.</td></tr>
  </table>
</dl>
If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png">, with <img class="formulaInl" alt="$n > 0$" src="form_167.png">, <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_135.png">, <code>to_be_folded</code> is a set of variables whose maximum space dimension is also less than or equal to <img class="formulaInl" alt="$n$" src="form_0.png">, and <code>var</code> is not a member of <code>to_be_folded</code>, then the space dimensions corresponding to variables in <code>to_be_folded</code> are <a class="el" href="main.html#fold_space_dimensions">folded</a> into the <img class="formulaInl" alt="$k$" src="form_286.png">-th space dimension. 
</div>
</div><p>
<a class="anchor" name="6f9c769f48ed91cd71bec247b7733430"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::hash_code" ref="6f9c769f48ed91cd71bec247b7733430" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::hash_code           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a 32-bit hash code for <code>*this</code>. 
<p>
If <code>x</code> and <code>y</code> are such that <code>x == y</code>, then <code>x.hash_code() == y.hash_code()</code>. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="1c59e94611b71ddd67acd033a05bbbc7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::operator==" ref="1c59e94611b71ddd67acd033a05bbbc7" args="(const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same octagon. 
<p>
Note that <code>x</code> and <code>y</code> may be dimension-incompatible shapes: in this case, the value <code>false</code> is returned.
</div>
</div><p>
<a class="anchor" name="137dcf52993d2ff3dd6e4678b45baf56"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::operator&lt;&lt;" ref="137dcf52993d2ff3dd6e4678b45baf56" args="(std::ostream &amp;s, const Octagonal_Shape&lt; T &gt; &amp;oct)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output operator. 
<p>
Writes a textual representation of <code>oct</code> on <code>s:</code> <code>false</code> is written if <code>oct</code> is an empty polyhedron; <code>true</code> is written if <code>oct</code> is a universe polyhedron; a system of constraints defining <code>oct</code> is written otherwise, all constraints separated by ", ".
</div>
</div><p>
<a class="anchor" name="1c2f0ae89d7bf247a76c40282f31758e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::operator!=" ref="1c2f0ae89d7bf247a76c40282f31758e" args="(const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different shapes. 
<p>
Note that <code>x</code> and <code>y</code> may be dimension-incompatible shapes: in this case, the value <code>true</code> is returned.
</div>
</div><p>
<a class="anchor" name="c2cd6705bce0af4bd9880b990baf1198"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::rectilinear_distance_assign" ref="c2cd6705bce0af4bd9880b990baf1198" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. 
<p>
If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.<p>
If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.
</div>
</div><p>
<a class="anchor" name="025902247d9c8b46d92c514c1646ff69"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::rectilinear_distance_assign" ref="025902247d9c8b46d92c514c1646ff69" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. 
<p>
If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.
</div>
</div><p>
<a class="anchor" name="af0214aee8884dc52be4e061d6b4df94"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::euclidean_distance_assign" ref="af0214aee8884dc52be4e061d6b4df94" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the euclidean distance between <code>x</code> and <code>y</code>. 
<p>
If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.<p>
If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.
</div>
</div><p>
<a class="anchor" name="2560fe5ce16277c4b4db17e951047028"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::euclidean_distance_assign" ref="2560fe5ce16277c4b4db17e951047028" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the euclidean distance between <code>x</code> and <code>y</code>. 
<p>
If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.
</div>
</div><p>
<a class="anchor" name="6f27f62cf5d65574cbb44025b1b3e585"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::l_infinity_distance_assign" ref="6f27f62cf5d65574cbb44025b1b3e585" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code>. 
<p>
If the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.<p>
If the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.
</div>
</div><p>
<a class="anchor" name="715054228bad30a232707ed0357cdd98"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::l_infinity_distance_assign" ref="715054228bad30a232707ed0357cdd98" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code>. 
<p>
If the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.
</div>
</div><p>
<a class="anchor" name="62d44847fe22abb82cbac84a776a9c72"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::swap" ref="62d44847fe22abb82cbac84a776a9c72" args="(Parma_Polyhedra_Library::Octagonal_Shape&lt; T &gt; &amp;x, Parma_Polyhedra_Library::Octagonal_Shape&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specializes <code>std::swap</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="09eda1d1953d8f83e4352c6fe78cbded"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::coherent_index" ref="09eda1d1953d8f83e4352c6fe78cbded" args="(const dimension_type i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> coherent_index           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 18 07:13:19 2009 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
