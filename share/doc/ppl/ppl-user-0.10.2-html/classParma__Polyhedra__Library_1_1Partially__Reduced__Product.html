<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PPL: Parma_Polyhedra_Library::Partially_Reduced_Product&lt; D1, D2, R &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::Partially_Reduced_Product&lt; D1, D2, R &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::Partially_Reduced_Product" -->The partially reduced product of two abstractions.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ppl.hh&gt;</code>
<p>

<p>
<a href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#6713cca018bed4091ffafb98ca4833d0">Partially_Reduced_Product</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions=0, <a class="el" href="group__PPL__CXX__interface.html#g616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind=UNIVERSE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an object having the specified properties.  <a href="#6713cca018bed4091ffafb98ca4833d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#28f6854a94a3a7d58034cb1d51ae9c7c">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a pair, copying a system of congruences.  <a href="#28f6854a94a3a7d58034cb1d51ae9c7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#4857c775f03d5b4ff084723eed2b5e31">Partially_Reduced_Product</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a pair, recycling a system of congruences.  <a href="#4857c775f03d5b4ff084723eed2b5e31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#1daec40615d5a93ce0de360865d93497">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a pair, copying a system of constraints.  <a href="#1daec40615d5a93ce0de360865d93497"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#bc31d844172a202d43d08e299e26322f">Partially_Reduced_Product</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a pair, recycling a system of constraints.  <a href="#bc31d844172a202d43d08e299e26322f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#d3eb603756ab7be783cd92410ac7aed7">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a product, from a C polyhedron.  <a href="#d3eb603756ab7be783cd92410ac7aed7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#dca9874a75b5ba09114b8495a23c4edd">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a product, from an NNC polyhedron.  <a href="#dca9874a75b5ba09114b8495a23c4edd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ef3ebc0ed74af80cd3653321153360bd">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;gr, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a product, from a grid.  <a href="#ef3ebc0ed74af80cd3653321153360bd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#2b4e2b95a505c70e40370e121cd179a4">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a product out of a box.  <a href="#2b4e2b95a505c70e40370e121cd179a4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#b95eae83384d8c6b41b9ed8f9fd16704">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;bd, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a product out of a BD shape.  <a href="#b95eae83384d8c6b41b9ed8f9fd16704"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#2b3eb71543b3284872781f0b4481fe39">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;os, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a product out of an octagonal shape.  <a href="#2b3eb71543b3284872781f0b4481fe39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b5db50d397654bd1a8d4067d90f7419"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="3b5db50d397654bd1a8d4067d90f7419" args="(const Partially_Reduced_Product &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#3b5db50d397654bd1a8d4067d90f7419">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy-constructor. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename E1 , typename E2 , typename S &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#8cdc72dfa85aed4e613f780b02e69e92">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; E1, E2, S &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a conservative, upward approximation of <code>y</code>.  <a href="#8cdc72dfa85aed4e613f780b02e69e92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="187bdab1051f58af280af66645ce1fed"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::operator=" ref="187bdab1051f58af280af66645ce1fed" args="(const Partially_Reduced_Product &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#187bdab1051f58af280af66645ce1fed">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The assignment operator. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b3ad0a7ad694f4a7724504544aff49fa"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::reduce" ref="b3ad0a7ad694f4a7724504544aff49fa" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#b3ad0a7ad694f4a7724504544aff49fa">reduce</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reduce. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the Partially_Reduced_Product</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="38a5f3efb1fe599046d2ed48223bfa41"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::space_dimension" ref="38a5f3efb1fe599046d2ed48223bfa41" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#38a5f3efb1fe599046d2ed48223bfa41">space_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="46f912e8b181561f68062e183005c8bc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::affine_dimension" ref="46f912e8b181561f68062e183005c8bc" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#46f912e8b181561f68062e183005c8bc">affine_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the minimum <a class="el" href="main.html#Affine_Independence_and_Affine_Dimension">affine dimension</a> (see also <a class="el" href="main.html#Grid_Affine_Dimension">grid affine dimension</a>) of the components of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c2583843b139ce11b842155b35d60332"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::domain1" ref="c2583843b139ce11b842155b35d60332" args="() const " -->
const D1 &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#c2583843b139ce11b842155b35d60332">domain1</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a constant reference to the first of the pair. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="294875fd6b469d8949f08c24b5893b6e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::domain2" ref="294875fd6b469d8949f08c24b5893b6e" args="() const " -->
const D2 &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#294875fd6b469d8949f08c24b5893b6e">domain2</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a constant reference to the second of the pair. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1dc5b9db43a16365ba0773a96fe1b799"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::constraints" ref="1dc5b9db43a16365ba0773a96fe1b799" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#1dc5b9db43a16365ba0773a96fe1b799">constraints</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of constraints which approximates <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2fe458f016db5eeeb95bee46f1800533"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::minimized_constraints" ref="2fe458f016db5eeeb95bee46f1800533" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#2fe458f016db5eeeb95bee46f1800533">minimized_constraints</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of constraints which approximates <code>*this</code>, in reduced form. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6bd361a7c7e187c0ff63c62894e741f8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::congruences" ref="6bd361a7c7e187c0ff63c62894e741f8" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#6bd361a7c7e187c0ff63c62894e741f8">congruences</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of congruences which approximates <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="425f248891aec4ed7800bd92334fd7c1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::minimized_congruences" ref="425f248891aec4ed7800bd92334fd7c1" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#425f248891aec4ed7800bd92334fd7c1">minimized_congruences</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of congruences which approximates <code>*this</code>, in reduced form. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cc8d0378d1cb13b5ddc04dd12cf18ebe"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::relation_with" ref="cc8d0378d1cb13b5ddc04dd12cf18ebe" args="(const Constraint &amp;c) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#cc8d0378d1cb13b5ddc04dd12cf18ebe">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>c</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3be7b3a04406453631aef24b817565a5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::relation_with" ref="3be7b3a04406453631aef24b817565a5" args="(const Congruence &amp;cg) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#3be7b3a04406453631aef24b817565a5">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>cg</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d3e2a76d26bef272d0a13fa3bae9a5c2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::relation_with" ref="d3e2a76d26bef272d0a13fa3bae9a5c2" args="(const Generator &amp;g) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#d3e2a76d26bef272d0a13fa3bae9a5c2">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>g</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ad10819182a33870e4b0a7e3b2bca564"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_empty" ref="ad10819182a33870e4b0a7e3b2bca564" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ad10819182a33870e4b0a7e3b2bca564">is_empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if either of the components of <code>*this</code> are empty. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1190fcf4794305386f8475f9ac51ce00"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_universe" ref="1190fcf4794305386f8475f9ac51ce00" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#1190fcf4794305386f8475f9ac51ce00">is_universe</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if both of the components of <code>*this</code> are the universe. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="41c9a9dc63e253ac5ed21cbdad4e2640"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_topologically_closed" ref="41c9a9dc63e253ac5ed21cbdad4e2640" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#41c9a9dc63e253ac5ed21cbdad4e2640">is_topologically_closed</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if both of the components of <code>*this</code> are topologically closed subsets of the vector space. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#db466cb206f1d16d24257a838d130cf2">is_disjoint_from</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are componentwise disjoint.  <a href="#db466cb206f1d16d24257a838d130cf2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="df7bd95cb0014251d60d1fd82c1d3932"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_discrete" ref="df7bd95cb0014251d60d1fd82c1d3932" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#df7bd95cb0014251d60d1fd82c1d3932">is_discrete</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if a component of <code>*this</code> is discrete. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fb7b94b681c4d195080fa81ed1480cc2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_bounded" ref="fb7b94b681c4d195080fa81ed1480cc2" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#fb7b94b681c4d195080fa81ed1480cc2">is_bounded</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if a component of <code>*this</code> is bounded. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#e386245235cada70fc797b0747b0d326">constrains</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>.  <a href="#e386245235cada70fc797b0747b0d326"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#99dc4fb442b60dc9c694d7abc853a3dc">bounds_from_above</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>.  <a href="#99dc4fb442b60dc9c694d7abc853a3dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a8128b9910f31bc963842e48c44a863e">bounds_from_below</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>.  <a href="#a8128b9910f31bc963842e48c44a863e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#3a03cd3ea1b11c1c8dbdf462959d79df">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed.  <a href="#3a03cd3ea1b11c1c8dbdf462959d79df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#6d33d9f1d987efe6e333c7ad1993dd5a">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;point) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed.  <a href="#6d33d9f1d987efe6e333c7ad1993dd5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#b73df10027395d3b2c9fbd3f3e77944e">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below i <code>*this</code>, in which case the infimum value is computed.  <a href="#b73df10027395d3b2c9fbd3f3e77944e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#5358c9f367ad37e650d411ab5e558e50">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;point) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed.  <a href="#5358c9f367ad37e650d411ab5e558e50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#888509fe116790d0b9a267e614be10ec">contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if each component of <code>*this</code> contains the corresponding component of <code>y</code>.  <a href="#888509fe116790d0b9a267e614be10ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#78e60691cfc6b6b52a34cc7952380a84">strictly_contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if each component of <code>*this</code> strictly contains the corresponding component of <code>y</code>.  <a href="#78e60691cfc6b6b52a34cc7952380a84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="41d30675a3c28980af0f087b06a1f4c1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::OK" ref="41d30675a3c28980af0f087b06a1f4c1" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#41d30675a3c28980af0f087b06a1f4c1">OK</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Space Dimension Preserving Member Functions that May Modify the Partially_Reduced_Product</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ffd7d0678df82882b006ea7b02771f98">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds constraint <code>c</code> to <code>*this</code>.  <a href="#ffd7d0678df82882b006ea7b02771f98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#c6434b8a020aeda5828830fd4b639277">refine_with_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the constraint <code>c</code> to refine <code>*this</code>.  <a href="#c6434b8a020aeda5828830fd4b639277"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#d3a8f10409a9fd73afb6691686d6862c">add_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of congruence <code>cg</code> to <code>*this</code>.  <a href="#d3a8f10409a9fd73afb6691686d6862c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#201ee4c814267695f31b30be833917bf">refine_with_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the congruence <code>cg</code> to refine <code>*this</code>.  <a href="#201ee4c814267695f31b30be833917bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#1d52cb88936eb0f5bde559b39f8ec42c">add_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the congruences in <code>cgs</code> to <code>*this</code>.  <a href="#1d52cb88936eb0f5bde559b39f8ec42c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#faf0bc4f0e0a036dbc3852b3e4490243">refine_with_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the congruences in <code>cgs</code> to refine <code>*this</code>.  <a href="#faf0bc4f0e0a036dbc3852b3e4490243"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ea7119974f9313e4c93908a2955c4186">add_recycled_congruences</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the congruences in <code>cgs</code> to *this.  <a href="#ea7119974f9313e4c93908a2955c4186"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#0c2c96efcf10102068f754c608a12427">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the constraint system in <code>cs</code> to <code>*this</code>.  <a href="#0c2c96efcf10102068f754c608a12427"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#3a031a8e65176b8bd80d2857bd9a68b6">refine_with_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the constraints in <code>cs</code> to refine <code>*this</code>.  <a href="#3a031a8e65176b8bd80d2857bd9a68b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#afc9294d3fb5f2c0fd8d4e4d22c283b6">add_recycled_constraints</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraint system in <code>cs</code> to <code>*this</code>.  <a href="#afc9294d3fb5f2c0fd8d4e4d22c283b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#7ea45b608af772cd69e2c23d7d62a3cf">unconstrain</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>.  <a href="#7ea45b608af772cd69e2c23d7d62a3cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#3ad1db1c5141d2815c0d849d12548e4c">unconstrain</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_unconstrained)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>to_be_unconstrained</code>, assigning the result to <code>*this</code>.  <a href="#3ad1db1c5141d2815c0d849d12548e4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#676b331ee61606b74be4cd1f90756839">intersection_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the componentwise intersection of <code>*this</code> and <code>y</code>.  <a href="#676b331ee61606b74be4cd1f90756839"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#0ea21bf85aa2e90c449435cfedcef181">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> an upper bound of <code>*this</code> and <code>y</code> computed on the corresponding components.  <a href="#0ea21bf85aa2e90c449435cfedcef181"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#db0fa15c5f30fc4be6a94ce2606208ef">upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> an upper bound of <code>*this</code> and <code>y</code> computed on the corresponding components. If it is exact on each of the components of <code>*this</code>, <code>true</code> is returned, otherwise <code>false</code> is returned.  <a href="#db0fa15c5f30fc4be6a94ce2606208ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#15b21e990e26976e615a7d3244ed843e">difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> an approximation of the set-theoretic difference of <code>*this</code> and <code>y</code>.  <a href="#15b21e990e26976e615a7d3244ed843e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#8b2ee24610cb804238f33581093948c1">affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#8b2ee24610cb804238f33581093948c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#7999968db9fb568980215d2c84393358">affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#7999968db9fb568980215d2c84393358"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#bb5709426ac80aa0bcf907b4f1d4a577">generalized_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code> (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.).  <a href="#bb5709426ac80aa0bcf907b4f1d4a577"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#c7b41dba5d22086cb9715c3f51248f98">generalized_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.).  <a href="#c7b41dba5d22086cb9715c3f51248f98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#97cc0d02a88d52e79cbb6615a3bbab42">generalized_affine_image</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.).  <a href="#97cc0d02a88d52e79cbb6615a3bbab42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#2c47f2f619b1d0f322b742891920735f">generalized_affine_preimage</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.).  <a href="#2c47f2f619b1d0f322b742891920735f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#e274e65fc3f012ab21bcffa3177228c5">bounded_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">.  <a href="#e274e65fc3f012ab21bcffa3177228c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#732e7355673aa63a2fc22a470a36f707">bounded_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">.  <a href="#732e7355673aa63a2fc22a470a36f707"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#77a2a8e38120a21ac0d5f19eb6e1668b">time_elapse_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>. (See also <a class="el" href="main.html#Grid_Time_Elapse">time-elapse</a>.).  <a href="#77a2a8e38120a21ac0d5f19eb6e1668b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="940db627ef73d29e63fed31acc7553f7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::topological_closure_assign" ref="940db627ef73d29e63fed31acc7553f7" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#940db627ef73d29e63fed31acc7553f7">topological_closure_assign</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#99247c74022e8d51cd0a2d93a87bcfe5">widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y, unsigned *tp=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the "widening" between <code>*this</code> and <code>y</code>.  <a href="#99247c74022e8d51cd0a2d93a87bcfe5"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Dimension of the Vector Space</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#2f90e70dbef264e99b7015c0ce7e16fd">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new space dimensions and embeds the components of <code>*this</code> in the new vector space.  <a href="#2f90e70dbef264e99b7015c0ce7e16fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#19a2fb28254bc142e01f3ee00c27ea89">add_space_dimensions_and_project</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new space dimensions and does not embed the components in the new vector space.  <a href="#19a2fb28254bc142e01f3ee00c27ea89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#c5ec610fb42e16beaac59b537a71f187">concatenate_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to the first (resp., second) component of <code>*this</code> the "concatenation" of the first (resp., second) components of <code>*this</code> and <code>y</code>, taken in this order. See also <a class="el" href="main.html#Concatenating_Polyhedra">Concatenating Polyhedra</a> and <a class="el" href="main.html#Grid_Concatenate">Concatenating Grids</a>.  <a href="#c5ec610fb42e16beaac59b537a71f187"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#4c7c04e76c758c53feeb8c5cf58638a6">remove_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_removed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the specified dimensions from the vector space.  <a href="#4c7c04e76c758c53feeb8c5cf58638a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#dfe66b5a34b84fcf63d1a48777f68e4d">remove_higher_space_dimensions</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> new_dimension)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the higher dimensions of the vector space so that the resulting space will have dimension <code>new_dimension</code>.  <a href="#dfe66b5a34b84fcf63d1a48777f68e4d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Partial_Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#1ae424886d05361c1a78c89dbdd5b7db">map_space_dimensions</a> (const Partial_Function &amp;pfunc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>.  <a href="#1ae424886d05361c1a78c89dbdd5b7db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#7a1f9b31c3ed7dc3e7691b9110ddbedb">expand_space_dimension</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>.  <a href="#7a1f9b31c3ed7dc3e7691b9110ddbedb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#966dadd4ba398fb77b77584e5af698af">fold_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_folded, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Folds the space dimensions in <code>to_be_folded</code> into <code>var</code>.  <a href="#966dadd4ba398fb77b77584e5af698af"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous Member Functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cbcc65a843515d547f055b687d1e6d5f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::~Partially_Reduced_Product" ref="cbcc65a843515d547f055b687d1e6d5f" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#cbcc65a843515d547f055b687d1e6d5f">~Partially_Reduced_Product</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9bd884fea397d9d6cde6426e6f47cc4e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::swap" ref="9bd884fea397d9d6cde6426e6f47cc4e" args="(Partially_Reduced_Product &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#9bd884fea397d9d6cde6426e6f47cc4e">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps <code>*this</code> with product <code>y</code>. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="57fc3d9d838fd7e20e80806307452a91"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::ascii_dump" ref="57fc3d9d838fd7e20e80806307452a91" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#57fc3d9d838fd7e20e80806307452a91">ascii_dump</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9a864135634ed49de1aeae3b38ed933a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::ascii_dump" ref="9a864135634ed49de1aeae3b38ed933a" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#9a864135634ed49de1aeae3b38ed933a">ascii_dump</a> (std::ostream &amp;s) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="885e896b320d1f4285b5dc92a20f8884"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::print" ref="885e896b320d1f4285b5dc92a20f8884" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#885e896b320d1f4285b5dc92a20f8884">print</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="804363984fe210abe47624522dfb7a92"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::ascii_load" ref="804363984fe210abe47624522dfb7a92" args="(std::istream &amp;s)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#804363984fe210abe47624522dfb7a92">ascii_load</a> (std::istream &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#9a864135634ed49de1aeae3b38ed933a" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dea57326388915780370a677453778b3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::total_memory_in_bytes" ref="dea57326388915780370a677453778b3" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#dea57326388915780370a677453778b3">total_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8eb19423295d8af4d69f144fc227128f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::external_memory_in_bytes" ref="8eb19423295d8af4d69f144fc227128f" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#8eb19423295d8af4d69f144fc227128f">external_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#f191b9781c37da15b49810d47a838823">hash_code</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a 32-bit hash code for <code>*this</code>.  <a href="#f191b9781c37da15b49810d47a838823"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4a53183970490595ac39c8c070601c6f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::max_space_dimension" ref="4a53183970490595ac39c8c070601c6f" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#4a53183970490595ac39c8c070601c6f">max_space_dimension</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension this product can handle. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="343e039e48425126b187827066d12bf2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Domain1" ref="343e039e48425126b187827066d12bf2" args="" -->
typedef D1&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#343e039e48425126b187827066d12bf2">Domain1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the first component. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4ac4e4131c756f0ffce85b9dec7d2b3a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Domain2" ref="4ac4e4131c756f0ffce85b9dec7d2b3a" args="" -->
typedef D2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#4ac4e4131c756f0ffce85b9dec7d2b3a">Domain2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the second component. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b3b8f7e6fdd123f510ba85f4527bdee3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::clear_reduced_flag" ref="b3b8f7e6fdd123f510ba85f4527bdee3" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#b3b8f7e6fdd123f510ba85f4527bdee3">clear_reduced_flag</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the reduced flag. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="269f357fca785afae3774b1e084d9b93"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::set_reduced_flag" ref="269f357fca785afae3774b1e084d9b93" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#269f357fca785afae3774b1e084d9b93">set_reduced_flag</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the reduced flag. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21a9e355a53ec45a5a60213fa8c24f2e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_reduced" ref="21a9e355a53ec45a5a60213fa8c24f2e" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#21a9e355a53ec45a5a60213fa8c24f2e">is_reduced</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if and only if the reduced flag is set. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="43ab45399b7e22ffcd6403b7e59a473c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::d1" ref="43ab45399b7e22ffcd6403b7e59a473c" args="" -->
D1&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#43ab45399b7e22ffcd6403b7e59a473c">d1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first component. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2d12805af932544a4fc1575f8db62a3d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::d2" ref="2d12805af932544a4fc1575f8db62a3d" args="" -->
D2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#2d12805af932544a4fc1575f8db62a3d">d2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The second component. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2a8683afd33a1d57db43c9db16de1f5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::reduced" ref="a2a8683afd33a1d57db43c9db16de1f5" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a2a8683afd33a1d57db43c9db16de1f5">reduced</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag to record whether the components are reduced with respect to each other and the reduction class. <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#de7792cb469ddf1d5d8944bbe7f1f55a">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if the components of <code>x</code> and <code>y</code> are pairwise equal.  <a href="#de7792cb469ddf1d5d8944bbe7f1f55a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename D1 , typename D2 , typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#3a18eff42a557fd87d59895399c7a13f">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;dp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#3a18eff42a557fd87d59895399c7a13f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename D1 , typename D2 , typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#7a9afaf958c6f9dd09c89bd706dc09b0">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if the components of <code>x</code> and <code>y</code> are not pairwise equal.  <a href="#7a9afaf958c6f9dd09c89bd706dc09b0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename D1 , typename D2 , typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#0e39243c24d99f8d374f9c14e3da8d98">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#0e39243c24d99f8d374f9c14e3da8d98"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename D1, typename D2, typename R&gt;<br>
 class Parma_Polyhedra_Library::Partially_Reduced_Product&lt; D1, D2, R &gt;</h3>

The partially reduced product of two abstractions. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>At present, the supported instantiations for the two domain templates <code>D1</code> and <code>D2</code> are the simple pointset domains: <code><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a></code>, <code><a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html" title="A not necessarily closed convex polyhedron.">NNC_Polyhedron</a></code>, <code><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a></code>, <code>Octagonal_Shape&lt;T&gt;</code>, <code>BD_Shape&lt;T&gt;</code>, <code>Box&lt;T&gt;</code>.</dd></dl>
An object of the class <code>Partially_Reduced_Product&lt;D1, D2, R&gt;</code> represents the (partially reduced) product of two pointset domains <code>D1</code> and <code>D2</code> where the form of any reduction is defined by the reduction class <code>R</code>.<p>
Suppose <img class="formulaInl" alt="$D_1$" src="form_551.png"> and <img class="formulaInl" alt="$D_2$" src="form_552.png"> are two abstract domains with concretization functions: <img class="formulaInl" alt="$\fund{\gamma_1}{D_1}{\Rset^n}$" src="form_553.png"> and <img class="formulaInl" alt="$\fund{\gamma_2}{D_2}{\Rset^n}$" src="form_554.png">, respectively.<p>
The partially reduced product <img class="formulaInl" alt="$D = D_1 \times D_2$" src="form_555.png">, for any reduction class <code>R</code>, has a concretization <img class="formulaInl" alt="$\fund{\gamma}{D}{\Rset^n}$" src="form_556.png"> where, if <img class="formulaInl" alt="$d = (d_1, d_2) \in D$" src="form_557.png"> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma(d) = \gamma_1(d_1) \inters \gamma_2(d_2). \]" src="form_558.png">
<p>
<p>
The operations are defined to be the result of applying the corresponding operations on each of the components provided the product is already reduced by the reduction method defined by <code>R</code>. In particular, if <code>R</code> is the <code>No_Reduction&lt;D1, D2&gt;</code> class, then the class <code>Partially_Reduced_Product&lt;D1, D2, R&gt;</code> domain is the direct product as defined in <a class="el" href="main.html#CC79">[CC79]</a>.<p>
How the results on the components are interpreted and combined depend on the specific test. For example, the test for emptiness will first make sure the product is reduced (using the reduction method provided by <code>R</code> if it is not already known to be reduced) and then test if either component is empty; thus, if <code>R</code> defines no reduction between its components and <img class="formulaInl" alt="$d = (G, P) \in (\Gset \times \Pset)$" src="form_559.png"> is a direct product in one dimension where <img class="formulaInl" alt="$G$" src="form_560.png"> denotes the set of numbers that are integral multiples of 3 while <img class="formulaInl" alt="$P$" src="form_77.png"> denotes the set of numbers between 1 and 2, then an operation that tests for emptiness should return false. However, the test for the universe returns true if and only if the test <code><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#1190fcf4794305386f8475f9ac51ce00" title="Returns true if and only if both of the components of *this are the universe.">is_universe()</a></code> on both components returns true.<p>
<dl class="user" compact><dt><b></b></dt><dd>In all the examples it is assumed that the template <code>R</code> is the <code>No_Reduction&lt;D1, D2&gt;</code> class and that variables <code>x</code> and <code>y</code> are defined (where they are used) as follows: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 1</b></dt><dd>The following code builds a direct product of a <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a> and NNC <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a>, corresponding to the positive even integer pairs in <img class="formulaInl" alt="$\Rset^2$" src="form_106.png">, given as a system of congruences: <div class="fragment"><pre class="fragment">  Congruence_System cgs;
  cgs.insert((x %= 0) / 2);
  cgs.insert((y %= 0) / 2);
  Partially_Reduced_Product&lt;Grid, NNC_Polyhedron, No_Reduction&lt;D1, D2&gt; &gt;
    dp(cgs);
  dp.add_constraint(x &gt;= 0);
  dp.add_constraint(y &gt;= 0);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 2</b></dt><dd>The following code builds the same product in <img class="formulaInl" alt="$\Rset^2$" src="form_106.png">: <div class="fragment"><pre class="fragment">  Partially_Reduced_Product&lt;Grid, NNC_Polyhedron, No_Reduction&lt;D1, D2&gt; &gt; dp(2);
  dp.add_constraint(x &gt;= 0);
  dp.add_constraint(y &gt;= 0);
  dp.add_congruence((x %= 0) / 2);
  dp.add_congruence((y %= 0) / 2);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 3</b></dt><dd>The following code will write "dp is empty": <div class="fragment"><pre class="fragment">  Partially_Reduced_Product&lt;Grid, NNC_Polyhedron, No_Reduction&lt;D1, D2&gt; &gt; dp(1);
  dp.add_congruence((x %= 0) / 2);
  dp.add_congruence((x %= 1) / 2);
  <span class="keywordflow">if</span> (dp.is_empty())
    cout &lt;&lt; <span class="stringliteral">"dp is empty."</span> &lt;&lt; endl;
  <span class="keywordflow">else</span>
    cout &lt;&lt; <span class="stringliteral">"dp is not empty."</span> &lt;&lt; endl;
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 4</b></dt><dd>The following code will write "dp is not empty": <div class="fragment"><pre class="fragment">  Partially_Reduced_Product&lt;Grid, NNC_Polyhedron, No_Reduction&lt;D1, D2&gt; &gt; dp(1);
  dp.add_congruence((x %= 0) / 2);
  dp.add_constraint(x &gt;= 1);
  dp.add_constraint(x &lt;= 1);
  <span class="keywordflow">if</span> (dp.is_empty())
    cout &lt;&lt; <span class="stringliteral">"dp is empty."</span> &lt;&lt; endl;
  <span class="keywordflow">else</span>
    cout &lt;&lt; <span class="stringliteral">"dp is not empty."</span> &lt;&lt; endl;
</pre></div> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6713cca018bed4091ffafb98ca4833d0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="6713cca018bed4091ffafb98ca4833d0" args="(dimension_type num_dimensions=0, Degenerate_Element kind=UNIVERSE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>num_dimensions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em> = <code>UNIVERSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an object having the specified properties. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&nbsp;</td><td>The number of dimensions of the vector space enclosing the pair;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>Specifies whether a universe or an empty pair has to be built.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="28f6854a94a3a7d58034cb1d51ae9c7c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="28f6854a94a3a7d58034cb1d51ae9c7c" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a pair, copying a system of congruences. 
<p>
The pair inherits the space dimension of the congruence system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences to be approximated by the pair.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of congruences is imcompatible with one of the components.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>cgs</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4857c775f03d5b4ff084723eed2b5e31"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="4857c775f03d5b4ff084723eed2b5e31" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a pair, recycling a system of congruences. 
<p>
The pair inherits the space dimension of the congruence system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences to be approximates by the pair. Its data-structures may be recycled to build the pair.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of congruences is imcompatible with one of the components.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>cgs</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1daec40615d5a93ce0de360865d93497"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="1daec40615d5a93ce0de360865d93497" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a pair, copying a system of constraints. 
<p>
The pair inherits the space dimension of the constraint system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints to be approximated by the pair.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of constraints is imcompatible with one of the components.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>cs</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bc31d844172a202d43d08e299e26322f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="bc31d844172a202d43d08e299e26322f" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a pair, recycling a system of constraints. 
<p>
The pair inherits the space dimension of the constraint system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints to be approximated by the pair.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of constraints is imcompatible with one of the components.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>cs</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d3eb603756ab7be783cd92410ac7aed7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="d3eb603756ab7be783cd92410ac7aed7" args="(const C_Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a product, from a C polyhedron. 
<p>
Builds a product containing <code>ph</code> using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the built product is the smallest one containing <code>ph</code>. The product inherits the space dimension of the polyhedron.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ph</em>&nbsp;</td><td>The polyhedron to be approximated by the product.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity that will not be exceeded.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>ph</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dca9874a75b5ba09114b8495a23c4edd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="dca9874a75b5ba09114b8495a23c4edd" args="(const NNC_Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a product, from an NNC polyhedron. 
<p>
Builds a product containing <code>ph</code> using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the built product is the smallest one containing <code>ph</code>. The product inherits the space dimension of the polyhedron.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ph</em>&nbsp;</td><td>The polyhedron to be approximated by the product.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity that will not be exceeded.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>ph</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ef3ebc0ed74af80cd3653321153360bd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="ef3ebc0ed74af80cd3653321153360bd" args="(const Grid &amp;gr, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a product, from a grid. 
<p>
Builds a product containing <code>gr</code>. The product inherits the space dimension of the grid.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gr</em>&nbsp;</td><td>The grid to be approximated by the product.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity is ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>gr</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2b4e2b95a505c70e40370e121cd179a4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="2b4e2b95a505c70e40370e121cd179a4" args="(const Box&lt; Interval &gt; &amp;box, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a product out of a box. 
<p>
Builds a product containing <code>box</code>. The product inherits the space dimension of the box.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The box representing the pair to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity is ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>box</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b95eae83384d8c6b41b9ed8f9fd16704"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="b95eae83384d8c6b41b9ed8f9fd16704" args="(const BD_Shape&lt; U &gt; &amp;bd, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a product out of a BD shape. 
<p>
Builds a product containing <code>bd</code>. The product inherits the space dimension of the BD shape.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bd</em>&nbsp;</td><td>The BD shape representing the product to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity is ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>bd</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2b3eb71543b3284872781f0b4481fe39"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="2b3eb71543b3284872781f0b4481fe39" args="(const Octagonal_Shape&lt; U &gt; &amp;os, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a product out of an octagonal shape. 
<p>
Builds a product containing <code>os</code>. The product inherits the space dimension of the octagonal shape.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The octagonal shape representing the product to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity is ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>os</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8cdc72dfa85aed4e613f780b02e69e92"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="8cdc72dfa85aed4e613f780b02e69e92" args="(const Partially_Reduced_Product&lt; E1, E2, S &gt; &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
<div class="memtemplate">
template&lt;typename E1 , typename E2 , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; E1, E2, S &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a conservative, upward approximation of <code>y</code>. 
<p>
Builds a product containing <code>y</code> using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the built product is the smallest one containing <code>y</code>. The product inherits the space dimension of y.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The product to be approximated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity that will not be exceeded.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>y</code> exceeds the maximum allowed space dimension.</td></tr>
  </table>
</dl>
The built product is independent of the order of the components of <code>y</code>. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="db466cb206f1d16d24257a838d130cf2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_disjoint_from" ref="db466cb206f1d16d24257a838d130cf2" args="(const Partially_Reduced_Product &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::is_disjoint_from           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are componentwise disjoint. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>x</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e386245235cada70fc797b0747b0d326"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::constrains" ref="e386245235cada70fc797b0747b0d326" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::constrains           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="99dc4fb442b60dc9c694d7abc853a3dc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::bounds_from_above" ref="99dc4fb442b60dc9c694d7abc853a3dc" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::bounds_from_above           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>. 
<p>
This method is the same as bounds_from_below.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a8128b9910f31bc963842e48c44a863e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::bounds_from_below" ref="a8128b9910f31bc963842e48c44a863e" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::bounds_from_below           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>. 
<p>
This method is the same as bounds_from_above.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3a03cd3ea1b11c1c8dbdf462959d79df"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::maximize" ref="3a03cd3ea1b11c1c8dbdf462959d79df" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::maximize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if the supremum value can be reached in <code>this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded by <code>*this</code>, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code> and <code>maximum</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="6d33d9f1d987efe6e333c7ad1993dd5a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::maximize" ref="6d33d9f1d987efe6e333c7ad1993dd5a" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum, Generator &amp;point) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::maximize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if the supremum value can be reached in <code>this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>When maximization succeeds, will be assigned a generator point where <code>expr</code> reaches its supremum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded by <code>*this</code>, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code>, <code>maximum</code> and <code>point</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="b73df10027395d3b2c9fbd3f3e77944e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::minimize" ref="b73df10027395d3b2c9fbd3f3e77944e" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below i <code>*this</code>, in which case the infimum value is computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if the infimum value can be reached in <code>this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code> and <code>minimum</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="5358c9f367ad37e650d411ab5e558e50"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::minimize" ref="5358c9f367ad37e650d411ab5e558e50" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum, Generator &amp;point) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if the infimum value can be reached in <code>this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>When minimization succeeds, will be assigned a generator point where <code>expr</code> reaches its infimum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code>, <code>minimum</code> and <code>point</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="888509fe116790d0b9a267e614be10ec"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::contains" ref="888509fe116790d0b9a267e614be10ec" args="(const Partially_Reduced_Product &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if each component of <code>*this</code> contains the corresponding component of <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="78e60691cfc6b6b52a34cc7952380a84"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::strictly_contains" ref="78e60691cfc6b6b52a34cc7952380a84" args="(const Partially_Reduced_Product &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::strictly_contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if each component of <code>*this</code> strictly contains the corresponding component of <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ffd7d0678df82882b006ea7b02771f98"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_constraint" ref="ffd7d0678df82882b006ea7b02771f98" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_constraint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds constraint <code>c</code> to <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>c</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c6434b8a020aeda5828830fd4b639277"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::refine_with_constraint" ref="c6434b8a020aeda5828830fd4b639277" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::refine_with_constraint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use the constraint <code>c</code> to refine <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint to be used for refinement.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>c</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d3a8f10409a9fd73afb6691686d6862c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_congruence" ref="d3a8f10409a9fd73afb6691686d6862c" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_congruence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of congruence <code>cg</code> to <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="201ee4c814267695f31b30be833917bf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::refine_with_congruence" ref="201ee4c814267695f31b30be833917bf" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::refine_with_congruence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use the congruence <code>cg</code> to refine <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&nbsp;</td><td>The congruence to be used for refinement.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1d52cb88936eb0f5bde559b39f8ec42c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_congruences" ref="1d52cb88936eb0f5bde559b39f8ec42c" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_congruences           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of the congruences in <code>cgs</code> to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruence system to be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="faf0bc4f0e0a036dbc3852b3e4490243"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::refine_with_congruences" ref="faf0bc4f0e0a036dbc3852b3e4490243" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::refine_with_congruences           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use the congruences in <code>cgs</code> to refine <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruences to be used for refinement.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ea7119974f9313e4c93908a2955c4186"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_recycled_congruences" ref="ea7119974f9313e4c93908a2955c4186" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_recycled_congruences           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the congruences in <code>cgs</code> to *this. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruence system to be added that may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0c2c96efcf10102068f754c608a12427"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_constraints" ref="0c2c96efcf10102068f754c608a12427" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_constraints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of the constraint system in <code>cs</code> to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3a031a8e65176b8bd80d2857bd9a68b6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::refine_with_constraints" ref="3a031a8e65176b8bd80d2857bd9a68b6" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::refine_with_constraints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use the constraints in <code>cs</code> to refine <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints to be used for refinement.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="afc9294d3fb5f2c0fd8d4e4d22c283b6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_recycled_constraints" ref="afc9294d3fb5f2c0fd8d4e4d22c283b6" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_recycled_constraints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the constraint system in <code>cs</code> to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be added that may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>cs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ea45b608af772cd69e2c23d7d62a3cf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::unconstrain" ref="7ea45b608af772cd69e2c23d7d62a3cf" args="(Variable var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::unconstrain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The space dimension that will be unconstrained.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3ad1db1c5141d2815c0d849d12548e4c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::unconstrain" ref="3ad1db1c5141d2815c0d849d12548e4c" args="(const Variables_Set &amp;to_be_unconstrained)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::unconstrain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_unconstrained</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>to_be_unconstrained</code>, assigning the result to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_unconstrained</em>&nbsp;</td><td>The set of space dimension that will be unconstrained.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_removed</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="676b331ee61606b74be4cd1f90756839"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::intersection_assign" ref="676b331ee61606b74be4cd1f90756839" args="(const Partially_Reduced_Product &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::intersection_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the componentwise intersection of <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0ea21bf85aa2e90c449435cfedcef181"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::upper_bound_assign" ref="0ea21bf85aa2e90c449435cfedcef181" args="(const Partially_Reduced_Product &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::upper_bound_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> an upper bound of <code>*this</code> and <code>y</code> computed on the corresponding components. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="db0fa15c5f30fc4be6a94ce2606208ef"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::upper_bound_assign_if_exact" ref="db0fa15c5f30fc4be6a94ce2606208ef" args="(const Partially_Reduced_Product &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::upper_bound_assign_if_exact           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> an upper bound of <code>*this</code> and <code>y</code> computed on the corresponding components. If it is exact on each of the components of <code>*this</code>, <code>true</code> is returned, otherwise <code>false</code> is returned. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="15b21e990e26976e615a7d3244ed843e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::difference_assign" ref="15b21e990e26976e615a7d3244ed843e" args="(const Partially_Reduced_Product &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::difference_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> an approximation of the set-theoretic difference of <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8b2ee24610cb804238f33581093948c1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::affine_image" ref="8b2ee24610cb804238f33581093948c1" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is assigned;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7999968db9fb568980215d2c84393358"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::affine_preimage" ref="7999968db9fb568980215d2c84393358" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is substituted;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bb5709426ac80aa0bcf907b4f1d4a577"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::generalized_affine_image" ref="bb5709426ac80aa0bcf907b4f1d4a577" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::generalized_affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code> (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c7b41dba5d22086cb9715c3f51248f98"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::generalized_affine_preimage" ref="c7b41dba5d22086cb9715c3f51248f98" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::generalized_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="97cc0d02a88d52e79cbb6615a3bbab42"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::generalized_affine_image" ref="97cc0d02a88d52e79cbb6615a3bbab42" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::generalized_affine_image           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2c47f2f619b1d0f322b742891920735f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::generalized_affine_preimage" ref="2c47f2f619b1d0f322b742891920735f" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::generalized_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e274e65fc3f012ab21bcffa3177228c5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::bounded_affine_image" ref="e274e65fc3f012ab21bcffa3177228c5" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::bounded_affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="732e7355673aa63a2fc22a470a36f707"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::bounded_affine_preimage" ref="732e7355673aa63a2fc22a470a36f707" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::bounded_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="77a2a8e38120a21ac0d5f19eb6e1668b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::time_elapse_assign" ref="77a2a8e38120a21ac0d5f19eb6e1668b" args="(const Partially_Reduced_Product &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::time_elapse_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>. (See also <a class="el" href="main.html#Grid_Time_Elapse">time-elapse</a>.). 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="99247c74022e8d51cd0a2d93a87bcfe5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::widening_assign" ref="99247c74022e8d51cd0a2d93a87bcfe5" args="(const Partially_Reduced_Product &amp;y, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::widening_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the "widening" between <code>*this</code> and <code>y</code>. 
<p>
This widening uses either the congruence or generator systems depending on which of the systems describing x and y are up to date and minimized.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A product that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2f90e70dbef264e99b7015c0ce7e16fd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_space_dimensions_and_embed" ref="2f90e70dbef264e99b7015c0ce7e16fd" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_space_dimensions_and_embed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <code>m</code> new space dimensions and embeds the components of <code>*this</code> in the new vector space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of dimensions to add.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#4a53183970490595ac39c8c070601c6f" title="Returns the maximum space dimension this product can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="19a2fb28254bc142e01f3ee00c27ea89"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_space_dimensions_and_project" ref="19a2fb28254bc142e01f3ee00c27ea89" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_space_dimensions_and_project           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <code>m</code> new space dimensions and does not embed the components in the new vector space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of space dimensions to add.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#4a53183970490595ac39c8c070601c6f" title="Returns the maximum space dimension this product can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c5ec610fb42e16beaac59b537a71f187"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::concatenate_assign" ref="c5ec610fb42e16beaac59b537a71f187" args="(const Partially_Reduced_Product &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::concatenate_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to the first (resp., second) component of <code>*this</code> the "concatenation" of the first (resp., second) components of <code>*this</code> and <code>y</code>, taken in this order. See also <a class="el" href="main.html#Concatenating_Polyhedra">Concatenating Polyhedra</a> and <a class="el" href="main.html#Grid_Concatenate">Concatenating Grids</a>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the concatenation would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#4a53183970490595ac39c8c070601c6f" title="Returns the maximum space dimension this product can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4c7c04e76c758c53feeb8c5cf58638a6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::remove_space_dimensions" ref="4c7c04e76c758c53feeb8c5cf58638a6" args="(const Variables_Set &amp;to_be_removed)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::remove_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_removed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all the specified dimensions from the vector space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_removed</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be removed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_removed</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dfe66b5a34b84fcf63d1a48777f68e4d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::remove_higher_space_dimensions" ref="dfe66b5a34b84fcf63d1a48777f68e4d" args="(dimension_type new_dimension)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::remove_higher_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>new_dimension</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the higher dimensions of the vector space so that the resulting space will have dimension <code>new_dimension</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>new_dimensions</code> is greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1ae424886d05361c1a78c89dbdd5b7db"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::map_space_dimensions" ref="1ae424886d05361c1a78c89dbdd5b7db" args="(const Partial_Function &amp;pfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
<div class="memtemplate">
template&lt;typename Partial_Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::map_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const Partial_Function &amp;&nbsp;</td>
          <td class="paramname"> <em>pfunc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>. 
<p>
If <code>pfunc</code> maps only some of the dimensions of <code>*this</code> then the rest will be projected away.<p>
If the highest dimension mapped to by <code>pfunc</code> is higher than the highest dimension in <code>*this</code> then the number of dimensions in <code>this</code> will be increased to the highest dimension mapped to by <code>pfunc</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfunc</em>&nbsp;</td><td>The partial function specifying the destiny of each space dimension.</td></tr>
  </table>
</dl>
The template class <code>Partial_Function</code> must provide the following methods. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> has_empty_codomain() const
</pre></div> returns <code>true</code> if and only if the represented partial function has an empty codomain (i.e., it is always undefined). The <code>has_empty_codomain()</code> method will always be called before the methods below. However, if <code>has_empty_codomain()</code> returns <code>true</code>, none of the functions below will be called. <div class="fragment"><pre class="fragment">      <a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> max_in_codomain() const
</pre></div> returns the maximum value that belongs to the codomain of the partial function. The <code>max_in_codomain()</code> method is called at most once. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> maps(<a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i, <a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a>&amp; j) <span class="keyword">const</span>
</pre></div> Let <img class="formulaInl" alt="$f$" src="form_323.png"> be the represented function and <img class="formulaInl" alt="$k$" src="form_286.png"> be the value of <code>i</code>. If <img class="formulaInl" alt="$f$" src="form_323.png"> is defined in <img class="formulaInl" alt="$k$" src="form_286.png">, then <img class="formulaInl" alt="$f(k)$" src="form_646.png"> is assigned to <code>j</code> and <code>true</code> is returned. If <img class="formulaInl" alt="$f$" src="form_323.png"> is undefined in <img class="formulaInl" alt="$k$" src="form_286.png">, then <code>false</code> is returned. This method is called at most <img class="formulaInl" alt="$n$" src="form_0.png"> times, where <img class="formulaInl" alt="$n$" src="form_0.png"> is the dimension of the vector space enclosing <code>*this</code>.<p>
The result is undefined if <code>pfunc</code> does not encode a partial function with the properties described in <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">specification of the mapping operator</a>. 
</div>
</div><p>
<a class="anchor" name="7a1f9b31c3ed7dc3e7691b9110ddbedb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::expand_space_dimension" ref="7a1f9b31c3ed7dc3e7691b9110ddbedb" args="(Variable var, dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::expand_space_dimension           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension to be replicated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of replicas to be created.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> does not correspond to a dimension of the vector space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#4a53183970490595ac39c8c070601c6f" title="Returns the maximum space dimension this product can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
</dl>
If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png">, with <img class="formulaInl" alt="$n > 0$" src="form_167.png">, and <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_135.png">, then the <img class="formulaInl" alt="$k$" src="form_286.png">-th space dimension is <a class="el" href="main.html#Expanding_One_Dimension_of_the_Vector_Space_to_Multiple_Dimensions">expanded</a> to <code>m</code> new space dimensions <img class="formulaInl" alt="$n$" src="form_0.png">, <img class="formulaInl" alt="$n+1$" src="form_168.png">, <img class="formulaInl" alt="$\dots$" src="form_647.png">, <img class="formulaInl" alt="$n+m-1$" src="form_170.png">. 
</div>
</div><p>
<a class="anchor" name="966dadd4ba398fb77b77584e5af698af"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::fold_space_dimensions" ref="966dadd4ba398fb77b77584e5af698af" args="(const Variables_Set &amp;to_be_folded, Variable var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::fold_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_folded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Folds the space dimensions in <code>to_be_folded</code> into <code>var</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_folded</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be folded;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension that is the destination of the folding operation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>var</code> or with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_folded</code>. Also thrown if <code>var</code> is contained in <code>to_be_folded</code>.</td></tr>
  </table>
</dl>
If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png">, with <img class="formulaInl" alt="$n > 0$" src="form_167.png">, <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_135.png">, <code>to_be_folded</code> is a set of variables whose maximum space dimension is also less than or equal to <img class="formulaInl" alt="$n$" src="form_0.png">, and <code>var</code> is not a member of <code>to_be_folded</code>, then the space dimensions corresponding to variables in <code>to_be_folded</code> are <a class="el" href="main.html#Folding_Multiple_Dimensions_of_the_Vector_Space_into_One_Dimension">folded</a> into the <img class="formulaInl" alt="$k$" src="form_286.png">-th space dimension. 
</div>
</div><p>
<a class="anchor" name="f191b9781c37da15b49810d47a838823"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::hash_code" ref="f191b9781c37da15b49810d47a838823" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::hash_code           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a 32-bit hash code for <code>*this</code>. 
<p>
If <code>x</code> and <code>y</code> are such that <code>x == y</code>, then <code>x.hash_code() == y.hash_code()</code>. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="de7792cb469ddf1d5d8944bbe7f1f55a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::operator==" ref="de7792cb469ddf1d5d8944bbe7f1f55a" args="(const Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;x, const Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if the components of <code>x</code> and <code>y</code> are pairwise equal. 
<p>
Note that <code>x</code> and <code>y</code> may be dimension-incompatible: in those cases, the value <code>false</code> is returned.
</div>
</div><p>
<a class="anchor" name="3a18eff42a557fd87d59895399c7a13f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::operator&lt;&lt;" ref="3a18eff42a557fd87d59895399c7a13f" args="(std::ostream &amp;s, const Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;dp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output operator. 
<p>
Writes a textual representation of <code>dp</code> on <code>s</code>.
</div>
</div><p>
<a class="anchor" name="7a9afaf958c6f9dd09c89bd706dc09b0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::operator!=" ref="7a9afaf958c6f9dd09c89bd706dc09b0" args="(const Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;x, const Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if the components of <code>x</code> and <code>y</code> are not pairwise equal. 
<p>
Note that <code>x</code> and <code>y</code> may be dimension-incompatible: in those cases, the value <code>true</code> is returned.
</div>
</div><p>
<a class="anchor" name="0e39243c24d99f8d374f9c14e3da8d98"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::swap" ref="0e39243c24d99f8d374f9c14e3da8d98" args="(Parma_Polyhedra_Library::Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;x, Parma_Polyhedra_Library::Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specializes <code>std::swap</code>. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 18 07:13:19 2009 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
