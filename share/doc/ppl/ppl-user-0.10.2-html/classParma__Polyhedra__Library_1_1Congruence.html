<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PPL: Parma_Polyhedra_Library::Congruence Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::Congruence Class Reference<br>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::Congruence" --><!-- doxytag: inherits="Parma_Polyhedra_Library::Row" -->A linear congruence.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ppl.hh&gt;</code>
<p>
Inherits Parma_Polyhedra_Library::Row.
<p>

<p>
<a href="classParma__Polyhedra__Library_1_1Congruence-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ba7dbedd485eab91821f129132a04723"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::Congruence" ref="ba7dbedd485eab91821f129132a04723" args="(const Congruence &amp;cg)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#ba7dbedd485eab91821f129132a04723">Congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy-constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#3a4c3af6146717b3302f467368eafe46">Congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy-constructs (modulo 0) from equality constraint <code>c</code>.  <a href="#3a4c3af6146717b3302f467368eafe46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b45e800217e1c61d8595e2ffc51a83ad"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::~Congruence" ref="b45e800217e1c61d8595e2ffc51a83ad" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#b45e800217e1c61d8595e2ffc51a83ad">~Congruence</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c93e938cd478716c7c9e5e9988f7a98"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator=" ref="2c93e938cd478716c7c9e5e9988f7a98" args="(const Congruence &amp;cg)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#2c93e938cd478716c7c9e5e9988f7a98">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="584cb5084fe5479b0c373e3d17fe5ffd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::space_dimension" ref="584cb5084fe5479b0c373e3d17fe5ffd" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#584cb5084fe5479b0c373e3d17fe5ffd">space_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Coefficient_traits::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#79c648d88214174287e3763b804f4aaf">coefficient</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the coefficient of <code>v</code> in <code>*this</code>.  <a href="#79c648d88214174287e3763b804f4aaf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3c9879f0c9dcb81fe1bbf78828509ef6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::inhomogeneous_term" ref="3c9879f0c9dcb81fe1bbf78828509ef6" args="() const " -->
Coefficient_traits::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#3c9879f0c9dcb81fe1bbf78828509ef6">inhomogeneous_term</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the inhomogeneous term of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="39b6f38fff55dd953ec509b3739dd17d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::modulus" ref="39b6f38fff55dd953ec509b3739dd17d" args="() const " -->
Coefficient_traits::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#39b6f38fff55dd953ec509b3739dd17d">modulus</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const reference to the modulus of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a03b119140132112557907b772102b33">operator/=</a> (Coefficient_traits::const_reference k)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies <code>k</code> into the modulus of <code>*this</code>.  <a href="#a03b119140132112557907b772102b33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#e96eebded76c559c95910dc233c68f06">is_tautological</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a tautology (i.e., an always true congruence).  <a href="#e96eebded76c559c95910dc233c68f06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#c26379e5f82fd0223682b11b9e052ea5">is_inconsistent</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is inconsistent (i.e., an always false congruence).  <a href="#c26379e5f82fd0223682b11b9e052ea5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#29c6deef0eb3911adbb08d36a8f0b3f2">is_proper_congruence</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if the modulus is greater than zero.  <a href="#29c6deef0eb3911adbb08d36a8f0b3f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#6609e54e84d50cd074c2dd65f38b47da">is_equality</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if <code>*this</code> is an equality.  <a href="#6609e54e84d50cd074c2dd65f38b47da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d67d37524d1fb7f31766c0b02cb8591a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::is_equal_at_dimension" ref="d67d37524d1fb7f31766c0b02cb8591a" args="(dimension_type dim, const Congruence &amp;cg) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#d67d37524d1fb7f31766c0b02cb8591a">is_equal_at_dimension</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> dim, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if <code>*this</code> is equal to <code>cg</code> in dimension <code>dim</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="484373d269a31c21efae44a83f8be6f0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::total_memory_in_bytes" ref="484373d269a31c21efae44a83f8be6f0" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#484373d269a31c21efae44a83f8be6f0">total_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a lower bound to the total size in bytes of the memory occupied by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ff04e47054c14b2edf29096ecc95ab7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::external_memory_in_bytes" ref="0ff04e47054c14b2edf29096ecc95ab7" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#0ff04e47054c14b2edf29096ecc95ab7">external_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="43983a6ee447e480f8700915bccb4811"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::ascii_dump" ref="43983a6ee447e480f8700915bccb4811" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#43983a6ee447e480f8700915bccb4811">ascii_dump</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c53e4323b140cdd4ba1ac96e7204d93a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::ascii_dump" ref="c53e4323b140cdd4ba1ac96e7204d93a" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#c53e4323b140cdd4ba1ac96e7204d93a">ascii_dump</a> (std::ostream &amp;s) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="146b211f83e22bd011d3de2e5975073b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::print" ref="146b211f83e22bd011d3de2e5975073b" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#146b211f83e22bd011d3de2e5975073b">print</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="94b3624c208219e401569cd289049b38"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::ascii_load" ref="94b3624c208219e401569cd289049b38" args="(std::istream &amp;s)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#94b3624c208219e401569cd289049b38">ascii_load</a> (std::istream &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation of the internal representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="33e6005a1fe40cb202eb619912c25c3c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::OK" ref="33e6005a1fe40cb202eb619912c25c3c" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#33e6005a1fe40cb202eb619912c25c3c">OK</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5a207ecd92e9fd8f3b1937a5064746a9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::max_space_dimension" ref="5a207ecd92e9fd8f3b1937a5064746a9" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#5a207ecd92e9fd8f3b1937a5064746a9">max_space_dimension</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension a <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html" title="A linear congruence.">Congruence</a> can handle. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b917a480b6afe7e2750aa2862c6783cf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::initialize" ref="b917a480b6afe7e2750aa2862c6783cf" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#b917a480b6afe7e2750aa2862c6783cf">initialize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2ca2446f563956eb2b92ddd17e5c0b2c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::finalize" ref="2ca2446f563956eb2b92ddd17e5c0b2c" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#2ca2446f563956eb2b92ddd17e5c0b2c">finalize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalizes the class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d07dc0dabac5685f9db8d9dc11e513f1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::zero_dim_integrality" ref="d07dc0dabac5685f9db8d9dc11e513f1" args="()" -->
static const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#d07dc0dabac5685f9db8d9dc11e513f1">zero_dim_integrality</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reference to the true (zero-dimension space) congruence <img class="formulaInl" alt="$0 = 1 \pmod{1}$" src="form_636.png">, also known as the <em>integrality congruence</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8aab82f7118966662582f88725ce4735"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::zero_dim_false" ref="8aab82f7118966662582f88725ce4735" args="()" -->
static const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#8aab82f7118966662582f88725ce4735">zero_dim_false</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reference to the false (zero-dimension space) congruence <img class="formulaInl" alt="$0 = 1 \pmod{0}$" src="form_637.png">. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7facb7a06ac72f1af2bc514c788f1a38"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::create" ref="7facb7a06ac72f1af2bc514c788f1a38" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
static <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#7facb7a06ac72f1af2bc514c788f1a38">create</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the congruence <img class="formulaInl" alt="$e1 = e2 \pmod{1}$" src="form_627.png">. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="57362a4d56c397575a6d043cdbcec0f9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::create" ref="57362a4d56c397575a6d043cdbcec0f9" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
static <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#57362a4d56c397575a6d043cdbcec0f9">create</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the congruence <img class="formulaInl" alt="$e = n \pmod{1}$" src="form_628.png">. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b3db7ba1765b3a04f8d320968f70447"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::create" ref="5b3db7ba1765b3a04f8d320968f70447" args="(Coefficient_traits::const_reference n, const Linear_Expression &amp;e)" -->
static <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#5b3db7ba1765b3a04f8d320968f70447">create</a> (Coefficient_traits::const_reference n, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the congruence <img class="formulaInl" alt="$n = e \pmod{1}$" src="form_638.png">. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#6a24743a95176da13995bb6c17151c9b">sign_normalize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalizes the signs.  <a href="#6a24743a95176da13995bb6c17151c9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#29c63b939ed830a0395170835e60beaf">normalize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalizes signs and the inhomogeneous term.  <a href="#29c63b939ed830a0395170835e60beaf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#fcf86304f17dc474e1e5bbe0486c1b59">strong_normalize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls normalize, then divides out common factors.  <a href="#fcf86304f17dc474e1e5bbe0486c1b59"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a948df90fc7880e7e52ceef297ee9bbf">operator/</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg, Coefficient_traits::const_reference k)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of <code>cg</code>, multiplying <code>k</code> into the copy's modulus.  <a href="#a948df90fc7880e7e52ceef297ee9bbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#2cb39e7c88e9e724e7970d0e953f2c81">operator/</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c, Coefficient_traits::const_reference m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a congruence from <code>c</code>, with <code>m</code> as the modulus.  <a href="#2cb39e7c88e9e724e7970d0e953f2c81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#deee840f3313b6050d439dbe5fe2fdd7">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are equivalent.  <a href="#deee840f3313b6050d439dbe5fe2fdd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#af7dc46b2cfbd6650ac1d2035d331f15">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>false</code> if and only if <code>x</code> and <code>y</code> are equivalent.  <a href="#af7dc46b2cfbd6650ac1d2035d331f15"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#e0c9395c1ac4d96e245be43fcd76424c">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operators.  <a href="#e0c9395c1ac4d96e245be43fcd76424c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#7415de7b412a5e297810ff35a97a2849">operator%=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the congruence <img class="formulaInl" alt="$e1 = e2 \pmod{1}$" src="form_627.png">.  <a href="#7415de7b412a5e297810ff35a97a2849"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#54cdd6074f90a5623c8ae7ddcfedc5c2">operator%=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the congruence <img class="formulaInl" alt="$e = n \pmod{1}$" src="form_628.png">.  <a href="#54cdd6074f90a5623c8ae7ddcfedc5c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#c8652f34bdfa731c02c1900f62bd5e88">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Parma_Polyhedra_Library::Congruence</a> &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Parma_Polyhedra_Library::Congruence</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#c8652f34bdfa731c02c1900f62bd5e88"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A linear congruence. 
<p>
An object of the class <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html" title="A linear congruence.">Congruence</a> is a congruence:<ul>
<li><img class="formulaInl" alt="$\cg = \sum_{i=0}^{n-1} a_i x_i + b = 0 \pmod m$" src="form_499.png"></li></ul>
<p>
where <img class="formulaInl" alt="$n$" src="form_0.png"> is the dimension of the space, <img class="formulaInl" alt="$a_i$" src="form_224.png"> is the integer coefficient of variable <img class="formulaInl" alt="$x_i$" src="form_466.png">, <img class="formulaInl" alt="$b$" src="form_225.png"> is the integer inhomogeneous term and <img class="formulaInl" alt="$m$" src="form_158.png"> is the integer modulus; if <img class="formulaInl" alt="$m = 0$" src="form_164.png">, then <img class="formulaInl" alt="$\cg$" src="form_408.png"> represents the equality congruence <img class="formulaInl" alt="$\sum_{i=0}^{n-1} a_i x_i + b = 0$" src="form_471.png"> and, if <img class="formulaInl" alt="$m \neq 0$" src="form_500.png">, then the congruence <img class="formulaInl" alt="$\cg$" src="form_408.png"> is said to be a proper congruence.<p>
<dl class="user" compact><dt><b>How to build a congruence</b></dt><dd>Congruences <img class="formulaInl" alt="$\pmod{1}$" src="form_501.png"> are typically built by applying the congruence symbol `<code>%=</code>' to a pair of linear expressions. Congruences with modulus <code>m</code> are typically constructed by building a congruence <img class="formulaInl" alt="$\pmod{1}$" src="form_501.png"> using the given pair of linear expressions and then adding the modulus <code>m</code> using the modulus symbol is `<code>/</code>'.</dd></dl>
The space dimension of a congruence is defined as the maximum space dimension of the arguments of its constructor.<p>
<dl class="user" compact><dt><b></b></dt><dd>In the following examples it is assumed that variables <code>x</code>, <code>y</code> and <code>z</code> are defined as follows: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
  Variable z(2);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 1</b></dt><dd>The following code builds the equality congruence <img class="formulaInl" alt="$3x + 5y - z = 0$" src="form_474.png">, having space dimension <img class="formulaInl" alt="$3$" src="form_468.png">: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#ba7dbedd485eab91821f129132a04723" title="Ordinary copy-constructor.">Congruence</a> eq_cg((3*x + 5*y - z %= 0) / 0);
</pre></div> The following code builds the congruence <img class="formulaInl" alt="$4x = 2y - 13 \pmod{1}$" src="form_502.png">, having space dimension <img class="formulaInl" alt="$2$" src="form_470.png">: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#ba7dbedd485eab91821f129132a04723" title="Ordinary copy-constructor.">Congruence</a> mod1_cg(4*x %= 2*y - 13);
</pre></div> The following code builds the congruence <img class="formulaInl" alt="$4x = 2y - 13 \pmod{2}$" src="form_503.png">, having space dimension <img class="formulaInl" alt="$2$" src="form_470.png">: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#ba7dbedd485eab91821f129132a04723" title="Ordinary copy-constructor.">Congruence</a> mod2_cg((4*x %= 2*y - 13) / 2);
</pre></div> An unsatisfiable congruence on the zero-dimension space <img class="formulaInl" alt="$\Rset^0$" src="form_165.png"> can be specified as follows: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#ba7dbedd485eab91821f129132a04723" title="Ordinary copy-constructor.">Congruence</a> false_cg = <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#8aab82f7118966662582f88725ce4735" title="Returns a reference to the false (zero-dimension space) congruence .">Congruence::zero_dim_false</a>();
</pre></div> Equivalent, but more involved ways are the following: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#ba7dbedd485eab91821f129132a04723" title="Ordinary copy-constructor.">Congruence</a> false_cg1((<a class="code" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero</a>() %= 1) / 0);
  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#ba7dbedd485eab91821f129132a04723" title="Ordinary copy-constructor.">Congruence</a> false_cg2((<a class="code" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero</a>() %= 1) / 2);
</pre></div> In contrast, the following code defines an unsatisfiable congruence having space dimension <img class="formulaInl" alt="$3$" src="form_468.png">: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#ba7dbedd485eab91821f129132a04723" title="Ordinary copy-constructor.">Congruence</a> false_cg3((0*z %= 1) / 0);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>How to inspect a congruence</b></dt><dd>Several methods are provided to examine a congruence and extract all the encoded information: its space dimension, its modulus and the value of its integer coefficients.</dd></dl>
<dl class="user" compact><dt><b>Example 2</b></dt><dd>The following code shows how it is possible to access the modulus as well as each of the coefficients. Given a congruence with linear expression <code>e</code> and modulus <code>m</code> (in this case <img class="formulaInl" alt="$x - 5y + 3z = 4 \pmod{5}$" src="form_504.png">), we construct a new congruence with the same modulus <code>m</code> but where the linear expression is <img class="formulaInl" alt="$2 e$" src="form_505.png"> (<img class="formulaInl" alt="$2x - 10y + 6z = 8 \pmod{5}$" src="form_506.png">). <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#ba7dbedd485eab91821f129132a04723" title="Ordinary copy-constructor.">Congruence</a> cg1((x - 5*y + 3*z %= 4) / 5);
  cout &lt;&lt; <span class="stringliteral">"Congruence cg1: "</span> &lt;&lt; cg1 &lt;&lt; endl;
  <span class="keyword">const</span> <a class="code" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899" title="An alias for easily naming the type of PPL coefficients.">Coefficient</a>&amp; m = cg1.modulus();
  <span class="keywordflow">if</span> (m == 0)
    cout &lt;&lt; <span class="stringliteral">"Congruence cg1 is an equality."</span> &lt;&lt; endl;
  <span class="keywordflow">else</span> {
    Linear_Expression e;
    <span class="keywordflow">for</span> (<a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i = cg1.space_dimension(); i-- &gt; 0; )
      e += 2 * cg1.coefficient(Variable(i)) * Variable(i);
      e += 2 * cg1.inhomogeneous_term();
    <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#ba7dbedd485eab91821f129132a04723" title="Ordinary copy-constructor.">Congruence</a> cg2((e %= 0) / m);
    cout &lt;&lt; <span class="stringliteral">"Congruence cg2: "</span> &lt;&lt; cg2 &lt;&lt; endl;
  }
</pre></div> The actual output could be the following: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#ba7dbedd485eab91821f129132a04723" title="Ordinary copy-constructor.">Congruence</a> cg1: A - 5*B + 3*C %= 4 / 5
  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#ba7dbedd485eab91821f129132a04723" title="Ordinary copy-constructor.">Congruence</a> cg2: 2*A - 10*B + 6*C %= 8 / 5
</pre></div> Note that, in general, the particular output obtained can be syntactically different from the (semantically equivalent) congruence considered. </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="3a4c3af6146717b3302f467368eafe46"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::Congruence" ref="3a4c3af6146717b3302f467368eafe46" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Congruence::Congruence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy-constructs (modulo 0) from equality constraint <code>c</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>c</code> is an inequality. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="79c648d88214174287e3763b804f4aaf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::coefficient" ref="79c648d88214174287e3763b804f4aaf" args="(Variable v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient_traits::const_reference Parma_Polyhedra_Library::Congruence::coefficient           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the coefficient of <code>v</code> in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>thrown if the index of <code>v</code> is greater than or equal to the space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a03b119140132112557907b772102b33"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator/=" ref="a03b119140132112557907b772102b33" args="(Coefficient_traits::const_reference k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp; Parma_Polyhedra_Library::Congruence::operator/=           </td>
          <td>(</td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>k</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplies <code>k</code> into the modulus of <code>*this</code>. 
<p>
If called with <code>*this</code> representing the congruence <img class="formulaInl" alt="$ e_1 = e_2 \pmod{m}$" src="form_629.png">, then it returns with *this representing the congruence <img class="formulaInl" alt="$ e_1 = e_2 \pmod{mk}$" src="form_630.png">. 
</div>
</div><p>
<a class="anchor" name="e96eebded76c559c95910dc233c68f06"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::is_tautological" ref="e96eebded76c559c95910dc233c68f06" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Congruence::is_tautological           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is a tautology (i.e., an always true congruence). 
<p>
A tautological congruence has one the following two forms:<ul>
<li>an equality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + 0 == 0$" src="form_631.png">; or</li><li>a proper congruence: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b \%= 0 / m$" src="form_632.png">, where <img class="formulaInl" alt="$b = 0 \pmod{m}$" src="form_633.png">. </li></ul>

</div>
</div><p>
<a class="anchor" name="c26379e5f82fd0223682b11b9e052ea5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::is_inconsistent" ref="c26379e5f82fd0223682b11b9e052ea5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Congruence::is_inconsistent           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is inconsistent (i.e., an always false congruence). 
<p>
An inconsistent congruence has one of the following two forms:<ul>
<li>an equality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b == 0$" src="form_634.png"> where <img class="formulaInl" alt="$b \neq 0$" src="form_613.png">; or</li><li>a proper congruence: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b \%= 0 / m$" src="form_632.png">, where <img class="formulaInl" alt="$b \neq 0 \pmod{m}$" src="form_635.png">. </li></ul>

</div>
</div><p>
<a class="anchor" name="29c6deef0eb3911adbb08d36a8f0b3f2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::is_proper_congruence" ref="29c6deef0eb3911adbb08d36a8f0b3f2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Congruence::is_proper_congruence           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if the modulus is greater than zero. 
<p>
A congruence with a modulus of 0 is a linear equality. 
</div>
</div><p>
<a class="anchor" name="6609e54e84d50cd074c2dd65f38b47da"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::is_equality" ref="6609e54e84d50cd074c2dd65f38b47da" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Congruence::is_equality           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if <code>*this</code> is an equality. 
<p>
A modulus of zero denotes a linear equality. 
</div>
</div><p>
<a class="anchor" name="6a24743a95176da13995bb6c17151c9b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::sign_normalize" ref="6a24743a95176da13995bb6c17151c9b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Congruence::sign_normalize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalizes the signs. 
<p>
The signs of the coefficients and the inhomogeneous term are normalized, leaving the first non-zero homogeneous coefficient positive. 
</div>
</div><p>
<a class="anchor" name="29c63b939ed830a0395170835e60beaf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::normalize" ref="29c63b939ed830a0395170835e60beaf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Congruence::normalize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalizes signs and the inhomogeneous term. 
<p>
Applies sign_normalize, then reduces the inhomogeneous term to the smallest possible positive number. 
</div>
</div><p>
<a class="anchor" name="fcf86304f17dc474e1e5bbe0486c1b59"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::strong_normalize" ref="fcf86304f17dc474e1e5bbe0486c1b59" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Congruence::strong_normalize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls normalize, then divides out common factors. 
<p>
Strongly normalized Congruences have equivalent semantics if and only if their syntaxes (as output by operator&lt;&lt;) are equal. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="a948df90fc7880e7e52ceef297ee9bbf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator/" ref="a948df90fc7880e7e52ceef297ee9bbf" args="(const Congruence &amp;cg, Coefficient_traits::const_reference k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> operator/           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a copy of <code>cg</code>, multiplying <code>k</code> into the copy's modulus. 
<p>
If <code>cg</code> represents the congruence <img class="formulaInl" alt="$ e_1 = e_2 \pmod{m}$" src="form_629.png">, then the result represents the congruence <img class="formulaInl" alt="$ e_1 = e_2 \pmod{mk}$" src="form_630.png">.
</div>
</div><p>
<a class="anchor" name="2cb39e7c88e9e724e7970d0e953f2c81"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator/" ref="2cb39e7c88e9e724e7970d0e953f2c81" args="(const Constraint &amp;c, Coefficient_traits::const_reference m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> operator/           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a congruence from <code>c</code>, with <code>m</code> as the modulus. 
<p>

</div>
</div><p>
<a class="anchor" name="deee840f3313b6050d439dbe5fe2fdd7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator==" ref="deee840f3313b6050d439dbe5fe2fdd7" args="(const Congruence &amp;x, const Congruence &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are equivalent. 
<p>

</div>
</div><p>
<a class="anchor" name="af7dc46b2cfbd6650ac1d2035d331f15"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator!=" ref="af7dc46b2cfbd6650ac1d2035d331f15" args="(const Congruence &amp;x, const Congruence &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>false</code> if and only if <code>x</code> and <code>y</code> are equivalent. 
<p>

</div>
</div><p>
<a class="anchor" name="e0c9395c1ac4d96e245be43fcd76424c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator&lt;&lt;" ref="e0c9395c1ac4d96e245be43fcd76424c" args="(std::ostream &amp;s, const Congruence &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output operators. 
<p>

</div>
</div><p>
<a class="anchor" name="7415de7b412a5e297810ff35a97a2849"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator%=" ref="7415de7b412a5e297810ff35a97a2849" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> operator%=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the congruence <img class="formulaInl" alt="$e1 = e2 \pmod{1}$" src="form_627.png">. 
<p>

</div>
</div><p>
<a class="anchor" name="54cdd6074f90a5623c8ae7ddcfedc5c2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator%=" ref="54cdd6074f90a5623c8ae7ddcfedc5c2" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> operator%=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the congruence <img class="formulaInl" alt="$e = n \pmod{1}$" src="form_628.png">. 
<p>

</div>
</div><p>
<a class="anchor" name="c8652f34bdfa731c02c1900f62bd5e88"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::swap" ref="c8652f34bdfa731c02c1900f62bd5e88" args="(Parma_Polyhedra_Library::Congruence &amp;x, Parma_Polyhedra_Library::Congruence &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Parma_Polyhedra_Library::Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Parma_Polyhedra_Library::Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specializes <code>std::swap</code>. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 18 07:13:19 2009 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
