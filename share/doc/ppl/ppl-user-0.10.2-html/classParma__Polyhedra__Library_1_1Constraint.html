<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PPL: Parma_Polyhedra_Library::Constraint Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::Constraint Class Reference<br>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::Constraint" --><!-- doxytag: inherits="Parma_Polyhedra_Library::Linear_Row" -->A linear equality or inequality.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ppl.hh&gt;</code>
<p>
Inherits Parma_Polyhedra_Library::Linear_Row.
<p>

<p>
<a href="classParma__Polyhedra__Library_1_1Constraint-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#c9b8aa34a8ed8e2c3c38d0435adff6ab">Type</a> { <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#c9b8aa34a8ed8e2c3c38d0435adff6abb5b32713c840499d9e29facf95a17f41">EQUALITY</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#c9b8aa34a8ed8e2c3c38d0435adff6abc1539389d3643cf986ef5bb99697d1cc">NONSTRICT_INEQUALITY</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#c9b8aa34a8ed8e2c3c38d0435adff6ab7491a8ba26958c3e27bed23b7eef1a7e">STRICT_INEQUALITY</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The constraint type.  <a href="classParma__Polyhedra__Library_1_1Constraint.html#c9b8aa34a8ed8e2c3c38d0435adff6ab">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36a0c8ccab7923610bd27f637af63e1d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::Constraint" ref="36a0c8ccab7923610bd27f637af63e1d" args="(const Constraint &amp;c)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#36a0c8ccab7923610bd27f637af63e1d">Constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy-constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#8fb8b2fe343e5afa80edc06bfa31460b">Constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy-constructs from equality congruence <code>cg</code>.  <a href="#8fb8b2fe343e5afa80edc06bfa31460b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c7bf9d127644aa14a09eab633e87f544"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::~Constraint" ref="c7bf9d127644aa14a09eab633e87f544" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#c7bf9d127644aa14a09eab633e87f544">~Constraint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dc926136daee1f47975434ee45298ec"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator=" ref="9dc926136daee1f47975434ee45298ec" args="(const Constraint &amp;c)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#9dc926136daee1f47975434ee45298ec">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3c1dcd74ba0b2509f45aad45a5d922ce"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::space_dimension" ref="3c1dcd74ba0b2509f45aad45a5d922ce" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#3c1dcd74ba0b2509f45aad45a5d922ce">space_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="239b0622fbcfe1638b4246deab2caa29"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::type" ref="239b0622fbcfe1638b4246deab2caa29" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#c9b8aa34a8ed8e2c3c38d0435adff6ab">Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#239b0622fbcfe1638b4246deab2caa29">type</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint type of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="745ac1cdddf74c6f387cfbbbc566dc78"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_equality" ref="745ac1cdddf74c6f387cfbbbc566dc78" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#745ac1cdddf74c6f387cfbbbc566dc78">is_equality</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an equality constraint. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6976f576e6e50941ee7a7b1a737c0eb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_inequality" ref="b6976f576e6e50941ee7a7b1a737c0eb" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#b6976f576e6e50941ee7a7b1a737c0eb">is_inequality</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an inequality constraint (either strict or non-strict). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b3186208850238a080373f035cd532cc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_nonstrict_inequality" ref="b3186208850238a080373f035cd532cc" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#b3186208850238a080373f035cd532cc">is_nonstrict_inequality</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a non-strict inequality constraint. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="442aecbe0ce384a7c1add146fb125ed6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_strict_inequality" ref="442aecbe0ce384a7c1add146fb125ed6" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#442aecbe0ce384a7c1add146fb125ed6">is_strict_inequality</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a strict inequality constraint. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Coefficient_traits::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#2679da4dbd5b8c33ef607aee49690c2a">coefficient</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the coefficient of <code>v</code> in <code>*this</code>.  <a href="#2679da4dbd5b8c33ef607aee49690c2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9960963fb1f8fb56631e0402557065ae"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::inhomogeneous_term" ref="9960963fb1f8fb56631e0402557065ae" args="() const " -->
Coefficient_traits::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#9960963fb1f8fb56631e0402557065ae">inhomogeneous_term</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the inhomogeneous term of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="78c24741e21a4406ea8ad1588c768147"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::total_memory_in_bytes" ref="78c24741e21a4406ea8ad1588c768147" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#78c24741e21a4406ea8ad1588c768147">total_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a lower bound to the total size in bytes of the memory occupied by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ab383f3930179982937f7733a283a03"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::external_memory_in_bytes" ref="0ab383f3930179982937f7733a283a03" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#0ab383f3930179982937f7733a283a03">external_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#29202eb817eb5c9d59433abeeb4f2eea">is_tautological</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a tautology (i.e., an always true constraint).  <a href="#29202eb817eb5c9d59433abeeb4f2eea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ea0fedb82a525e6ada13cd7fd2d03225">is_inconsistent</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is inconsistent (i.e., an always false constraint).  <a href="#ea0fedb82a525e6ada13cd7fd2d03225"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#f8fcee7f8582b0afc9115eb1304c24f9">is_equivalent_to</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are equivalent constraints.  <a href="#f8fcee7f8582b0afc9115eb1304c24f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0f18894c8f97fa0cd38736462f36132"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::ascii_dump" ref="b0f18894c8f97fa0cd38736462f36132" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#b0f18894c8f97fa0cd38736462f36132">ascii_dump</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7bdaff085ea6859cdec9b27bffb6de4b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::ascii_dump" ref="7bdaff085ea6859cdec9b27bffb6de4b" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#7bdaff085ea6859cdec9b27bffb6de4b">ascii_dump</a> (std::ostream &amp;s) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="93d5d6abf06ec551294c4c18abb4349d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::print" ref="93d5d6abf06ec551294c4c18abb4349d" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#93d5d6abf06ec551294c4c18abb4349d">print</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0d50a5df6b31c6de90fe366e18e750ff"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::ascii_load" ref="0d50a5df6b31c6de90fe366e18e750ff" args="(std::istream &amp;s)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#0d50a5df6b31c6de90fe366e18e750ff">ascii_load</a> (std::istream &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#7bdaff085ea6859cdec9b27bffb6de4b" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6742bd7f3f2cb079b96900dda0147940"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::OK" ref="6742bd7f3f2cb079b96900dda0147940" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#6742bd7f3f2cb079b96900dda0147940">OK</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fa6ba487c08199e83a970fc49b53d3d0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::swap" ref="fa6ba487c08199e83a970fc49b53d3d0" args="(Constraint &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#fa6ba487c08199e83a970fc49b53d3d0">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps <code>*this</code> with <code>y</code>. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="09c8fc0753a389cc42f84c12f7920832"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::max_space_dimension" ref="09c8fc0753a389cc42f84c12f7920832" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#09c8fc0753a389cc42f84c12f7920832">max_space_dimension</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension a <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> can handle. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ab38d6ea061e7c2cb1595ba9cf2fd42"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::initialize" ref="0ab38d6ea061e7c2cb1595ba9cf2fd42" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#0ab38d6ea061e7c2cb1595ba9cf2fd42">initialize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="af207e746f4a3dc2722e254612dab3b3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::finalize" ref="af207e746f4a3dc2722e254612dab3b3" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#af207e746f4a3dc2722e254612dab3b3">finalize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalizes the class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2935fff040a5b31930fff594a0b2596d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::zero_dim_false" ref="2935fff040a5b31930fff594a0b2596d" args="()" -->
static const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#2935fff040a5b31930fff594a0b2596d">zero_dim_false</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The unsatisfiable (zero-dimension space) constraint <img class="formulaInl" alt="$0 = 1$" src="form_333.png">. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bbde4b86cfca3e29a917650f4c9c62d5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::zero_dim_positivity" ref="bbde4b86cfca3e29a917650f4c9c62d5" args="()" -->
static const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#bbde4b86cfca3e29a917650f4c9c62d5">zero_dim_positivity</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The true (zero-dimension space) constraint <img class="formulaInl" alt="$0 \leq 1$" src="form_606.png">, also known as <em>positivity constraint</em>. <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#dba3d929f4317a38ad387c5b45a91199">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>e1</code> = <code>e2</code>.  <a href="#dba3d929f4317a38ad387c5b45a91199"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#047a99eb91872d19730f4fd14a81f55c">operator==</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v1, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>v1</code> = <code>v2</code>.  <a href="#047a99eb91872d19730f4fd14a81f55c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#f2eb5d22ef23937a261cfe3f6bc435e6">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>e</code> = <code>n</code>.  <a href="#f2eb5d22ef23937a261cfe3f6bc435e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#448b4387171ec166085eb46aacedaad9">operator==</a> (Coefficient_traits::const_reference n, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>n</code> = <code>e</code>.  <a href="#448b4387171ec166085eb46aacedaad9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#61bc4f536e4c04b9594e1b6c7e13d76e">operator&gt;=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>e1</code> &gt;= <code>e2</code>.  <a href="#61bc4f536e4c04b9594e1b6c7e13d76e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#600a652347fb8718e0bc05f7230b8d8a">operator&gt;=</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v1, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>v1</code> &gt;= <code>v2</code>.  <a href="#600a652347fb8718e0bc05f7230b8d8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#e3cacddb2450b8b685b8f39936a2b69d">operator&gt;=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>e</code> &gt;= <code>n</code>.  <a href="#e3cacddb2450b8b685b8f39936a2b69d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#e615df068adfbb40a0b0b7a993579d22">operator&gt;=</a> (Coefficient_traits::const_reference n, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>n</code> &gt;= <code>e</code>.  <a href="#e615df068adfbb40a0b0b7a993579d22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#f06b2331eb3d080794682080b7f7eb1d">operator&lt;=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>e1</code> &lt;= <code>e2</code>.  <a href="#f06b2331eb3d080794682080b7f7eb1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#423e3bb0d9886c630c3c227def9f2073">operator&lt;=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>e</code> &lt;= <code>n</code>.  <a href="#423e3bb0d9886c630c3c227def9f2073"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#bdd61469bc5c6dfc6e97f306a751035c">operator&lt;=</a> (Coefficient_traits::const_reference n, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>n</code> &lt;= <code>e</code>.  <a href="#bdd61469bc5c6dfc6e97f306a751035c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#cc5c5125e7237c5913981b99a502f332">operator&gt;</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>e1</code> &gt; <code>e2</code>.  <a href="#cc5c5125e7237c5913981b99a502f332"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#61208276a246a505bd753ffbb568bfe7">operator&gt;</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v1, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>v1</code> &gt; <code>v2</code>.  <a href="#61208276a246a505bd753ffbb568bfe7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#f245f065572b31c8ca97e196e45f9cf9">operator&gt;</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>e</code> &gt; <code>n</code>.  <a href="#f245f065572b31c8ca97e196e45f9cf9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#89943bdfa5424bf7acecc51a7b6949c8">operator&gt;</a> (Coefficient_traits::const_reference n, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>n</code> &gt; <code>e</code>.  <a href="#89943bdfa5424bf7acecc51a7b6949c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#852f422dfdf14a1e8a97b4dad77f7e36">operator&lt;</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>e1</code> &lt; <code>e2</code>.  <a href="#852f422dfdf14a1e8a97b4dad77f7e36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#3c920e734593812d8529bc12be6f503e">operator&lt;</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>e</code> &lt; <code>n</code>.  <a href="#3c920e734593812d8529bc12be6f503e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#54742578f3ff98e32e7e15d6b554f13f">operator&lt;</a> (Coefficient_traits::const_reference n, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>n</code> &lt; <code>e</code>.  <a href="#54742578f3ff98e32e7e15d6b554f13f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#340e8b886fb185bed798dcbc1391c126">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> is equivalent to <code>y</code>.  <a href="#340e8b886fb185bed798dcbc1391c126"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#e86d21a6490f299af6229d70cf20c3ba">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> is not equivalent to <code>y</code>.  <a href="#e86d21a6490f299af6229d70cf20c3ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#2fb9117b8937e3d9a9b4d3ae397bb79a">operator&lt;=</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v1, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>v1</code> &lt;= <code>v2</code>.  <a href="#2fb9117b8937e3d9a9b4d3ae397bb79a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#4b4c0277d3b6c85ab6633ae9f5e235c6">operator&lt;</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v1, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constraint <code>v1</code> &lt; <code>v2</code>.  <a href="#4b4c0277d3b6c85ab6633ae9f5e235c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#66a2134e0f7fc74d62b14f46631dc2c7">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Parma_Polyhedra_Library::Constraint</a> &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Parma_Polyhedra_Library::Constraint</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#66a2134e0f7fc74d62b14f46631dc2c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#182ea33f63c0eea708e02a32b0904f30">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#182ea33f63c0eea708e02a32b0904f30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#cedadd7f7742a18d941ded77da69ba9a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#c9b8aa34a8ed8e2c3c38d0435adff6ab">Constraint::Type</a> &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#cedadd7f7742a18d941ded77da69ba9a"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A linear equality or inequality. 
<p>
An object of the class <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> is either:<ul>
<li>an equality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} a_i x_i + b = 0$" src="form_471.png">;</li><li>a non-strict inequality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} a_i x_i + b \geq 0$" src="form_472.png">; or</li><li>a strict inequality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} a_i x_i + b > 0$" src="form_473.png">;</li></ul>
<p>
where <img class="formulaInl" alt="$n$" src="form_0.png"> is the dimension of the space, <img class="formulaInl" alt="$a_i$" src="form_224.png"> is the integer coefficient of variable <img class="formulaInl" alt="$x_i$" src="form_466.png"> and <img class="formulaInl" alt="$b$" src="form_225.png"> is the integer inhomogeneous term.<p>
<dl class="user" compact><dt><b>How to build a constraint</b></dt><dd>Constraints are typically built by applying a relation symbol to a pair of linear expressions. Available relation symbols are equality (<code>==</code>), non-strict inequalities (<code>&gt;=</code> and <code>&lt;=</code>) and strict inequalities (<code>&lt;</code> and <code>&gt;</code>). The space dimension of a constraint is defined as the maximum space dimension of the arguments of its constructor.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>In the following examples it is assumed that variables <code>x</code>, <code>y</code> and <code>z</code> are defined as follows: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
  Variable z(2);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 1</b></dt><dd>The following code builds the equality constraint <img class="formulaInl" alt="$3x + 5y - z = 0$" src="form_474.png">, having space dimension <img class="formulaInl" alt="$3$" src="form_468.png">: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy-constructor.">Constraint</a> eq_c(3*x + 5*y - z == 0);
</pre></div> The following code builds the (non-strict) inequality constraint <img class="formulaInl" alt="$4x \geq 2y - 13$" src="form_475.png">, having space dimension <img class="formulaInl" alt="$2$" src="form_470.png">: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy-constructor.">Constraint</a> ineq_c(4*x &gt;= 2*y - 13);
</pre></div> The corresponding strict inequality constraint <img class="formulaInl" alt="$4x > 2y - 13$" src="form_476.png"> is obtained as follows: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy-constructor.">Constraint</a> strict_ineq_c(4*x &gt; 2*y - 13);
</pre></div> An unsatisfiable constraint on the zero-dimension space <img class="formulaInl" alt="$\Rset^0$" src="form_165.png"> can be specified as follows: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy-constructor.">Constraint</a> false_c = <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#2935fff040a5b31930fff594a0b2596d" title="The unsatisfiable (zero-dimension space) constraint .">Constraint::zero_dim_false</a>();
</pre></div> Equivalent, but more involved ways are the following: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy-constructor.">Constraint</a> false_c1(<a class="code" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero</a>() == 1);
  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy-constructor.">Constraint</a> false_c2(<a class="code" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero</a>() &gt;= 1);
  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy-constructor.">Constraint</a> false_c3(<a class="code" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero</a>() &gt; 0);
</pre></div> In contrast, the following code defines an unsatisfiable constraint having space dimension <img class="formulaInl" alt="$3$" src="form_468.png">: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy-constructor.">Constraint</a> false_c(0*z == 1);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>How to inspect a constraint</b></dt><dd>Several methods are provided to examine a constraint and extract all the encoded information: its space dimension, its type (equality, non-strict inequality, strict inequality) and the value of its integer coefficients.</dd></dl>
<dl class="user" compact><dt><b>Example 2</b></dt><dd>The following code shows how it is possible to access each single coefficient of a constraint. Given an inequality constraint (in this case <img class="formulaInl" alt="$x - 5y + 3z \leq 4$" src="form_477.png">), we construct a new constraint corresponding to its complement (thus, in this case we want to obtain the strict inequality constraint <img class="formulaInl" alt="$x - 5y + 3z > 4$" src="form_478.png">). <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy-constructor.">Constraint</a> c1(x - 5*y + 3*z &lt;= 4);
  cout &lt;&lt; <span class="stringliteral">"Constraint c1: "</span> &lt;&lt; c1 &lt;&lt; endl;
  <span class="keywordflow">if</span> (c1.is_equality())
    cout &lt;&lt; <span class="stringliteral">"Constraint c1 is not an inequality."</span> &lt;&lt; endl;
  <span class="keywordflow">else</span> {
    Linear_Expression e;
    <span class="keywordflow">for</span> (<a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i = c1.space_dimension(); i-- &gt; 0; )
      e += c1.coefficient(Variable(i)) * Variable(i);
    e += c1.inhomogeneous_term();
    <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy-constructor.">Constraint</a> c2 = c1.is_strict_inequality() ? (e &lt;= 0) : (e &lt; 0);
    cout &lt;&lt; <span class="stringliteral">"Complement c2: "</span> &lt;&lt; c2 &lt;&lt; endl;
  }
</pre></div> The actual output is the following: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy-constructor.">Constraint</a> c1: -A + 5*B - 3*C &gt;= -4
  Complement c2: A - 5*B + 3*C &gt; 4
</pre></div> Note that, in general, the particular output obtained can be syntactically different from the (semantically equivalent) constraint considered. </dd></dl>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="c9b8aa34a8ed8e2c3c38d0435adff6ab"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::Type" ref="c9b8aa34a8ed8e2c3c38d0435adff6ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#c9b8aa34a8ed8e2c3c38d0435adff6ab">Parma_Polyhedra_Library::Constraint::Type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The constraint type. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="c9b8aa34a8ed8e2c3c38d0435adff6abb5b32713c840499d9e29facf95a17f41"></a><!-- doxytag: member="EQUALITY" ref="c9b8aa34a8ed8e2c3c38d0435adff6abb5b32713c840499d9e29facf95a17f41" args="" -->EQUALITY</em>&nbsp;</td><td>
The constraint is an equality. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="c9b8aa34a8ed8e2c3c38d0435adff6abc1539389d3643cf986ef5bb99697d1cc"></a><!-- doxytag: member="NONSTRICT_INEQUALITY" ref="c9b8aa34a8ed8e2c3c38d0435adff6abc1539389d3643cf986ef5bb99697d1cc" args="" -->NONSTRICT_INEQUALITY</em>&nbsp;</td><td>
The constraint is a non-strict inequality. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="c9b8aa34a8ed8e2c3c38d0435adff6ab7491a8ba26958c3e27bed23b7eef1a7e"></a><!-- doxytag: member="STRICT_INEQUALITY" ref="c9b8aa34a8ed8e2c3c38d0435adff6ab7491a8ba26958c3e27bed23b7eef1a7e" args="" -->STRICT_INEQUALITY</em>&nbsp;</td><td>
The constraint is a strict inequality. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="8fb8b2fe343e5afa80edc06bfa31460b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::Constraint" ref="8fb8b2fe343e5afa80edc06bfa31460b" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Constraint::Constraint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy-constructs from equality congruence <code>cg</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>cg</code> is a proper congruence. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2679da4dbd5b8c33ef607aee49690c2a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::coefficient" ref="2679da4dbd5b8c33ef607aee49690c2a" args="(Variable v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient_traits::const_reference Parma_Polyhedra_Library::Constraint::coefficient           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the coefficient of <code>v</code> in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>thrown if the index of <code>v</code> is greater than or equal to the space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="29202eb817eb5c9d59433abeeb4f2eea"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_tautological" ref="29202eb817eb5c9d59433abeeb4f2eea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Constraint::is_tautological           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is a tautology (i.e., an always true constraint). 
<p>
A tautology can have either one of the following forms:<ul>
<li>an equality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + 0 = 0$" src="form_607.png">; or</li><li>a non-strict inequality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b \geq 0$" src="form_608.png">, where <img class="formulaInl" alt="$b \geq 0$" src="form_609.png">; or</li><li>a strict inequality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b > 0$" src="form_610.png">, where <img class="formulaInl" alt="$b > 0$" src="form_611.png">. </li></ul>

</div>
</div><p>
<a class="anchor" name="ea0fedb82a525e6ada13cd7fd2d03225"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_inconsistent" ref="ea0fedb82a525e6ada13cd7fd2d03225" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Constraint::is_inconsistent           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is inconsistent (i.e., an always false constraint). 
<p>
An inconsistent constraint can have either one of the following forms:<ul>
<li>an equality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b = 0$" src="form_612.png">, where <img class="formulaInl" alt="$b \neq 0$" src="form_613.png">; or</li><li>a non-strict inequality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b \geq 0$" src="form_608.png">, where <img class="formulaInl" alt="$b < 0$" src="form_614.png">; or</li><li>a strict inequality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b > 0$" src="form_610.png">, where <img class="formulaInl" alt="$b \leq 0$" src="form_615.png">. </li></ul>

</div>
</div><p>
<a class="anchor" name="f8fcee7f8582b0afc9115eb1304c24f9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_equivalent_to" ref="f8fcee7f8582b0afc9115eb1304c24f9" args="(const Constraint &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Constraint::is_equivalent_to           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are equivalent constraints. 
<p>
Constraints having different space dimensions are not equivalent. Note that constraints having different types may nonetheless be equivalent, if they both are tautologies or inconsistent. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="dba3d929f4317a38ad387c5b45a91199"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator==" ref="dba3d929f4317a38ad387c5b45a91199" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>e1</code> = <code>e2</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="047a99eb91872d19730f4fd14a81f55c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator==" ref="047a99eb91872d19730f4fd14a81f55c" args="(Variable v1, Variable v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator==           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>v1</code> = <code>v2</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="f2eb5d22ef23937a261cfe3f6bc435e6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator==" ref="f2eb5d22ef23937a261cfe3f6bc435e6" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>e</code> = <code>n</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="448b4387171ec166085eb46aacedaad9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator==" ref="448b4387171ec166085eb46aacedaad9" args="(Coefficient_traits::const_reference n, const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator==           </td>
          <td>(</td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>n</code> = <code>e</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="61bc4f536e4c04b9594e1b6c7e13d76e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;=" ref="61bc4f536e4c04b9594e1b6c7e13d76e" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt;=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>e1</code> &gt;= <code>e2</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="600a652347fb8718e0bc05f7230b8d8a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;=" ref="600a652347fb8718e0bc05f7230b8d8a" args="(Variable v1, Variable v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt;=           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>v1</code> &gt;= <code>v2</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="e3cacddb2450b8b685b8f39936a2b69d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;=" ref="e3cacddb2450b8b685b8f39936a2b69d" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt;=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>e</code> &gt;= <code>n</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="e615df068adfbb40a0b0b7a993579d22"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;=" ref="e615df068adfbb40a0b0b7a993579d22" args="(Coefficient_traits::const_reference n, const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt;=           </td>
          <td>(</td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>n</code> &gt;= <code>e</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="f06b2331eb3d080794682080b7f7eb1d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;=" ref="f06b2331eb3d080794682080b7f7eb1d" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt;=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>e1</code> &lt;= <code>e2</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="423e3bb0d9886c630c3c227def9f2073"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;=" ref="423e3bb0d9886c630c3c227def9f2073" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt;=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>e</code> &lt;= <code>n</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="bdd61469bc5c6dfc6e97f306a751035c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;=" ref="bdd61469bc5c6dfc6e97f306a751035c" args="(Coefficient_traits::const_reference n, const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt;=           </td>
          <td>(</td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>n</code> &lt;= <code>e</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="cc5c5125e7237c5913981b99a502f332"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;" ref="cc5c5125e7237c5913981b99a502f332" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>e1</code> &gt; <code>e2</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="61208276a246a505bd753ffbb568bfe7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;" ref="61208276a246a505bd753ffbb568bfe7" args="(Variable v1, Variable v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt;           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>v1</code> &gt; <code>v2</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="f245f065572b31c8ca97e196e45f9cf9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;" ref="f245f065572b31c8ca97e196e45f9cf9" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>e</code> &gt; <code>n</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="89943bdfa5424bf7acecc51a7b6949c8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;" ref="89943bdfa5424bf7acecc51a7b6949c8" args="(Coefficient_traits::const_reference n, const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt;           </td>
          <td>(</td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>n</code> &gt; <code>e</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="852f422dfdf14a1e8a97b4dad77f7e36"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;" ref="852f422dfdf14a1e8a97b4dad77f7e36" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>e1</code> &lt; <code>e2</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="3c920e734593812d8529bc12be6f503e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;" ref="3c920e734593812d8529bc12be6f503e" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>e</code> &lt; <code>n</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="54742578f3ff98e32e7e15d6b554f13f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;" ref="54742578f3ff98e32e7e15d6b554f13f" args="(Coefficient_traits::const_reference n, const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>n</code> &lt; <code>e</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="340e8b886fb185bed798dcbc1391c126"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator==" ref="340e8b886fb185bed798dcbc1391c126" args="(const Constraint &amp;x, const Constraint &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> is equivalent to <code>y</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="e86d21a6490f299af6229d70cf20c3ba"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator!=" ref="e86d21a6490f299af6229d70cf20c3ba" args="(const Constraint &amp;x, const Constraint &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> is not equivalent to <code>y</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="2fb9117b8937e3d9a9b4d3ae397bb79a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;=" ref="2fb9117b8937e3d9a9b4d3ae397bb79a" args="(Variable v1, Variable v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt;=           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>v1</code> &lt;= <code>v2</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="4b4c0277d3b6c85ab6633ae9f5e235c6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;" ref="4b4c0277d3b6c85ab6633ae9f5e235c6" args="(Variable v1, Variable v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt;           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constraint <code>v1</code> &lt; <code>v2</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="66a2134e0f7fc74d62b14f46631dc2c7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::swap" ref="66a2134e0f7fc74d62b14f46631dc2c7" args="(Parma_Polyhedra_Library::Constraint &amp;x, Parma_Polyhedra_Library::Constraint &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Parma_Polyhedra_Library::Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Parma_Polyhedra_Library::Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specializes <code>std::swap</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="182ea33f63c0eea708e02a32b0904f30"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;&lt;" ref="182ea33f63c0eea708e02a32b0904f30" args="(std::ostream &amp;s, const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output operator. 
<p>

</div>
</div><p>
<a class="anchor" name="cedadd7f7742a18d941ded77da69ba9a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;&lt;" ref="cedadd7f7742a18d941ded77da69ba9a" args="(std::ostream &amp;s, const Constraint::Type &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#c9b8aa34a8ed8e2c3c38d0435adff6ab">Constraint::Type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output operator. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 18 07:13:19 2009 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
