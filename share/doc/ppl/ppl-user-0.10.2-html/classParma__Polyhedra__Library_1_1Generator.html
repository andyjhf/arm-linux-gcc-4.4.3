<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PPL: Parma_Polyhedra_Library::Generator Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::Generator Class Reference<br>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::Generator" --><!-- doxytag: inherits="Parma_Polyhedra_Library::Linear_Row" -->A line, ray, point or closure point.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ppl.hh&gt;</code>
<p>
Inherits Parma_Polyhedra_Library::Linear_Row.
<p>
Inherited by <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html">Parma_Polyhedra_Library::Grid_Generator</a><code> [private]</code>.
<p>

<p>
<a href="classParma__Polyhedra__Library_1_1Generator-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#55b76ba0041601d8da38ab5ad619eed5">Type</a> { <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#55b76ba0041601d8da38ab5ad619eed54312979a12cae5ebb0791496e1ccce7a">LINE</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#55b76ba0041601d8da38ab5ad619eed505abaa6ff4aa204c25c94719e8a2b6f4">RAY</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#55b76ba0041601d8da38ab5ad619eed5b7fe867b1243e111ef4364e3ef5b5329">POINT</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#55b76ba0041601d8da38ab5ad619eed5bed2d3fff60e7c0b8fc325bf46f9725f">CLOSURE_POINT</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The generator type.  <a href="classParma__Polyhedra__Library_1_1Generator.html#55b76ba0041601d8da38ab5ad619eed5">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3f29f8b40d09b17eaa4cbaac069f72a0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::Generator" ref="3f29f8b40d09b17eaa4cbaac069f72a0" args="(const Generator &amp;g)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0">Generator</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy-constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b339ccb929a7255295ad19a5b168d5d0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::~Generator" ref="b339ccb929a7255295ad19a5b168d5d0" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#b339ccb929a7255295ad19a5b168d5d0">~Generator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4fb7d78e7b37d7f4b99babdc5cc84783"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::operator=" ref="4fb7d78e7b37d7f4b99babdc5cc84783" args="(const Generator &amp;g)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#4fb7d78e7b37d7f4b99babdc5cc84783">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1c884f5152f75040139ec3d9ec8ac293"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::space_dimension" ref="1c884f5152f75040139ec3d9ec8ac293" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#1c884f5152f75040139ec3d9ec8ac293">space_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7c502c8d46ed2f68679404fdfdf8e0bf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::type" ref="7c502c8d46ed2f68679404fdfdf8e0bf" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#55b76ba0041601d8da38ab5ad619eed5">Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#7c502c8d46ed2f68679404fdfdf8e0bf">type</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the generator type of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d8cee05f88ad5aea288c1f6b8bf7cdc7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::is_line" ref="d8cee05f88ad5aea288c1f6b8bf7cdc7" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#d8cee05f88ad5aea288c1f6b8bf7cdc7">is_line</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a line. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e5902ab7e2d3304037a56ecda7fc22a4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::is_ray" ref="e5902ab7e2d3304037a56ecda7fc22a4" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#e5902ab7e2d3304037a56ecda7fc22a4">is_ray</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a ray. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1827b1f7a42393a2526944530559c5a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::is_point" ref="f1827b1f7a42393a2526944530559c5a" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#f1827b1f7a42393a2526944530559c5a">is_point</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a point. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2aba27eb7310045e1a35c7e68af01ab2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::is_closure_point" ref="2aba27eb7310045e1a35c7e68af01ab2" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#2aba27eb7310045e1a35c7e68af01ab2">is_closure_point</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a closure point. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Coefficient_traits::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#fceefab91d648d188e42e5a75a3a977e">coefficient</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the coefficient of <code>v</code> in <code>*this</code>.  <a href="#fceefab91d648d188e42e5a75a3a977e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Coefficient_traits::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#eff190ba56f86d3425859043689d499a">divisor</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <code>*this</code> is either a point or a closure point, returns its divisor.  <a href="#eff190ba56f86d3425859043689d499a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="de98f4e320d7d21e223afb83240b3800"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::total_memory_in_bytes" ref="de98f4e320d7d21e223afb83240b3800" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#de98f4e320d7d21e223afb83240b3800">total_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a lower bound to the total size in bytes of the memory occupied by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="77fc44f44b1bdda486e19e30310634e2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::external_memory_in_bytes" ref="77fc44f44b1bdda486e19e30310634e2" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#77fc44f44b1bdda486e19e30310634e2">external_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#42867df59ec40173391b76074f9f0fb2">is_equivalent_to</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are equivalent generators.  <a href="#42867df59ec40173391b76074f9f0fb2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="13c726daa7d565ded0b177e24b6d1104"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::ascii_dump" ref="13c726daa7d565ded0b177e24b6d1104" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#13c726daa7d565ded0b177e24b6d1104">ascii_dump</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a40eabb29ea4abe082c3a2e6dc820276"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::ascii_dump" ref="a40eabb29ea4abe082c3a2e6dc820276" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a40eabb29ea4abe082c3a2e6dc820276">ascii_dump</a> (std::ostream &amp;s) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="de2531310fd7806c9e4f745cab145926"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::print" ref="de2531310fd7806c9e4f745cab145926" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#de2531310fd7806c9e4f745cab145926">print</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bc8ae851f2a0a6260d954b3bd8505249"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::ascii_load" ref="bc8ae851f2a0a6260d954b3bd8505249" args="(std::istream &amp;s)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#bc8ae851f2a0a6260d954b3bd8505249">ascii_load</a> (std::istream &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a40eabb29ea4abe082c3a2e6dc820276" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1bf8c762c6f36b30f2abcaffe591acb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::OK" ref="f1bf8c762c6f36b30f2abcaffe591acb" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#f1bf8c762c6f36b30f2abcaffe591acb">OK</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="775a8cec41b0fcc88689a171f5be8546"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::swap" ref="775a8cec41b0fcc88689a171f5be8546" args="(Generator &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#775a8cec41b0fcc88689a171f5be8546">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps <code>*this</code> with <code>y</code>. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#584f3fd5a19536644a66818169b16ac6">line</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the line of direction <code>e</code>.  <a href="#584f3fd5a19536644a66818169b16ac6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#b36bf020da4fb4583e6e1a6b94197cb4">ray</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the ray of direction <code>e</code>.  <a href="#b36bf020da4fb4583e6e1a6b94197cb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#6b8dae6436867a53e27720ee211f1cc7">point</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e=Linear_Expression::zero(), Coefficient_traits::const_reference d=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the point at <code>e</code> / <code>d</code>.  <a href="#6b8dae6436867a53e27720ee211f1cc7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#5c56451d80b8c02636854053de9e0440">closure_point</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e=Linear_Expression::zero(), Coefficient_traits::const_reference d=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the closure point at <code>e</code> / <code>d</code>.  <a href="#5c56451d80b8c02636854053de9e0440"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d593d3aa49a632911d8d49c83b3f4985"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::max_space_dimension" ref="d593d3aa49a632911d8d49c83b3f4985" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#d593d3aa49a632911d8d49c83b3f4985">max_space_dimension</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension a <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html" title="A line, ray, point or closure point.">Generator</a> can handle. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3bc88b2886b0b86865186d142e5ee414"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::initialize" ref="3bc88b2886b0b86865186d142e5ee414" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#3bc88b2886b0b86865186d142e5ee414">initialize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ebb212a14f52ed934059925c1f5f2010"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::finalize" ref="ebb212a14f52ed934059925c1f5f2010" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#ebb212a14f52ed934059925c1f5f2010">finalize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalizes the class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="600c942b0a2e94b550ccd84ef9c30928"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::zero_dim_point" ref="600c942b0a2e94b550ccd84ef9c30928" args="()" -->
static const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#600c942b0a2e94b550ccd84ef9c30928">zero_dim_point</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the origin of the zero-dimensional space <img class="formulaInl" alt="$\Rset^0$" src="form_165.png">. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6804f93015ae6e1dc0c2e42e726380c4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::zero_dim_closure_point" ref="6804f93015ae6e1dc0c2e42e726380c4" args="()" -->
static const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#6804f93015ae6e1dc0c2e42e726380c4">zero_dim_closure_point</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns, as a closure point, the origin of the zero-dimensional space <img class="formulaInl" alt="$\Rset^0$" src="form_165.png">. <br></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#303b4ed4262469c1834228e0f88dba74">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#303b4ed4262469c1834228e0f88dba74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#10cab5245f80aacd8000d0312730ec03">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Parma_Polyhedra_Library::Generator</a> &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Parma_Polyhedra_Library::Generator</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#10cab5245f80aacd8000d0312730ec03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#d7552a414d66f92897d12767579fa3ca">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> is equivalent to <code>y</code>.  <a href="#d7552a414d66f92897d12767579fa3ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#0c26ae11a4146369ff86288347cc54db">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> is not equivalent to <code>y</code>.  <a href="#0c26ae11a4146369ff86288347cc54db"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename To &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#e6206985cd5536c4dac181de5fb21247">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#e6206985cd5536c4dac181de5fb21247"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Temp , typename To &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#5363ddeed325652ee6c064a8936cfe57">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#5363ddeed325652ee6c064a8936cfe57"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename To &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a98511973ca14e8904e4e2c1f774bd3a">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#a98511973ca14e8904e4e2c1f774bd3a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Temp , typename To &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#f4abff14e1b88cbb929f0733432477ff">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#f4abff14e1b88cbb929f0733432477ff"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename To &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#0fb144e5f3fb6815e4c28c89883607be">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code>.  <a href="#0fb144e5f3fb6815e4c28c89883607be"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Temp , typename To &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#e67eb83f2626818420b3201db09e3d58">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code>.  <a href="#e67eb83f2626818420b3201db09e3d58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#75190def344d4c1ba6c59a6f0fcf7420">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#55b76ba0041601d8da38ab5ad619eed5">Generator::Type</a> &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#75190def344d4c1ba6c59a6f0fcf7420"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A line, ray, point or closure point. 
<p>
An object of the class <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html" title="A line, ray, point or closure point.">Generator</a> is one of the following:<p>
<ul>
<li>a line <img class="formulaInl" alt="$\vect{l} = (a_0, \ldots, a_{n-1})^\transpose$" src="form_482.png">;</li></ul>
<p>
<ul>
<li>a ray <img class="formulaInl" alt="$\vect{r} = (a_0, \ldots, a_{n-1})^\transpose$" src="form_483.png">;</li></ul>
<p>
<ul>
<li>a point <img class="formulaInl" alt="$\vect{p} = (\frac{a_0}{d}, \ldots, \frac{a_{n-1}}{d})^\transpose$" src="form_484.png">;</li></ul>
<p>
<ul>
<li>a closure point <img class="formulaInl" alt="$\vect{c} = (\frac{a_0}{d}, \ldots, \frac{a_{n-1}}{d})^\transpose$" src="form_485.png">;</li></ul>
<p>
where <img class="formulaInl" alt="$n$" src="form_0.png"> is the dimension of the space and, for points and closure points, <img class="formulaInl" alt="$d > 0$" src="form_486.png"> is the divisor.<p>
<dl class="user" compact><dt><b>A note on terminology.</b></dt><dd>As observed in Section <a class="el" href="main.html#representation">Representations of Convex Polyhedra</a>, there are cases when, in order to represent a polyhedron <img class="formulaInl" alt="$\cP$" src="form_49.png"> using the generator system <img class="formulaInl" alt="$\cG = (L, R, P, C)$" src="form_99.png">, we need to include in the finite set <img class="formulaInl" alt="$P$" src="form_77.png"> even points of <img class="formulaInl" alt="$\cP$" src="form_49.png"> that are <em>not</em> vertices of <img class="formulaInl" alt="$\cP$" src="form_49.png">. This situation is even more frequent when working with NNC polyhedra and it is the reason why we prefer to use the word `point' where other libraries use the word `vertex'.</dd></dl>
<dl class="user" compact><dt><b>How to build a generator.</b></dt><dd>Each type of generator is built by applying the corresponding function (<code>line</code>, <code>ray</code>, <code>point</code> or <code>closure_point</code>) to a linear expression, representing a direction in the space; the space dimension of the generator is defined as the space dimension of the corresponding linear expression. Linear expressions used to define a generator should be homogeneous (any constant term will be simply ignored). When defining points and closure points, an optional Coefficient argument can be used as a common <em>divisor</em> for all the coefficients occurring in the provided linear expression; the default value for this argument is 1.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>In all the following examples it is assumed that variables <code>x</code>, <code>y</code> and <code>z</code> are defined as follows: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
  Variable z(2);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 1</b></dt><dd>The following code builds a line with direction <img class="formulaInl" alt="$x-y-z$" src="form_487.png"> and having space dimension <img class="formulaInl" alt="$3$" src="form_468.png">: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> l = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#584f3fd5a19536644a66818169b16ac6" title="Returns the line of direction e.">line</a>(x - y - z);
</pre></div> As mentioned above, the constant term of the linear expression is not relevant. Thus, the following code has the same effect: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> l = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#584f3fd5a19536644a66818169b16ac6" title="Returns the line of direction e.">line</a>(x - y - z + 15);
</pre></div> By definition, the origin of the space is not a line, so that the following code throws an exception: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> l = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#584f3fd5a19536644a66818169b16ac6" title="Returns the line of direction e.">line</a>(0*x);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 2</b></dt><dd>The following code builds a ray with the same direction as the line in Example 1: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> r = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#b36bf020da4fb4583e6e1a6b94197cb4" title="Returns the ray of direction e.">ray</a>(x - y - z);
</pre></div> As is the case for lines, when specifying a ray the constant term of the linear expression is not relevant; also, an exception is thrown when trying to build a ray from the origin of the space.</dd></dl>
<dl class="user" compact><dt><b>Example 3</b></dt><dd>The following code builds the point <img class="formulaInl" alt="$\vect{p} = (1, 0, 2)^\transpose \in \Rset^3$" src="form_488.png">: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> p = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(1*x + 0*y + 2*z);
</pre></div> The same effect can be obtained by using the following code: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> p = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(x + 2*z);
</pre></div> Similarly, the origin <img class="formulaInl" alt="$\vect{0} \in \Rset^3$" src="form_489.png"> can be defined using either one of the following lines of code: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> origin3 = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(0*x + 0*y + 0*z);
  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> origin3_alt = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(0*z);
</pre></div> Note however that the following code would have defined a different point, namely <img class="formulaInl" alt="$\vect{0} \in \Rset^2$" src="form_490.png">: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> origin2 = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(0*y);
</pre></div> The following two lines of code both define the only point having space dimension zero, namely <img class="formulaInl" alt="$\vect{0} \in \Rset^0$" src="form_491.png">. In the second case we exploit the fact that the first argument of the function <code>point</code> is optional. <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> origin0 = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#600c942b0a2e94b550ccd84ef9c30928" title="Returns the origin of the zero-dimensional space .">Generator::zero_dim_point</a>();
  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> origin0_alt = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 4</b></dt><dd>The point <img class="formulaInl" alt="$\vect{p}$" src="form_492.png"> specified in Example 3 above can also be obtained with the following code, where we provide a non-default value for the second argument of the function <code>point</code> (the divisor): <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> p = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(2*x + 0*y + 4*z, 2);
</pre></div> Obviously, the divisor can be usefully exploited to specify points having some non-integer (but rational) coordinates. For instance, the point <img class="formulaInl" alt="$\vect{q} = (-1.5, 3.2, 2.1)^\transpose \in \Rset^3$" src="form_493.png"> can be specified by the following code: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> q = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(-15*x + 32*y + 21*z, 10);
</pre></div> If a zero divisor is provided, an exception is thrown.</dd></dl>
<dl class="user" compact><dt><b>Example 5</b></dt><dd>Closure points are specified in the same way we defined points, but invoking their specific constructor function. For instance, the closure point <img class="formulaInl" alt="$\vect{c} = (1, 0, 2)^\transpose \in \Rset^3$" src="form_494.png"> is defined by <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> c = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#5c56451d80b8c02636854053de9e0440" title="Returns the closure point at e / d.">closure_point</a>(1*x + 0*y + 2*z);
</pre></div> For the particular case of the (only) closure point having space dimension zero, we can use any of the following: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> closure_origin0 = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#6804f93015ae6e1dc0c2e42e726380c4" title="Returns, as a closure point, the origin of the zero-dimensional space .">Generator::zero_dim_closure_point</a>();
  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> closure_origin0_alt = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#5c56451d80b8c02636854053de9e0440" title="Returns the closure point at e / d.">closure_point</a>();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>How to inspect a generator</b></dt><dd>Several methods are provided to examine a generator and extract all the encoded information: its space dimension, its type and the value of its integer coefficients.</dd></dl>
<dl class="user" compact><dt><b>Example 6</b></dt><dd>The following code shows how it is possible to access each single coefficient of a generator. If <code>g1</code> is a point having coordinates <img class="formulaInl" alt="$(a_0, \ldots, a_{n-1})^\transpose$" src="form_495.png">, we construct the closure point <code>g2</code> having coordinates <img class="formulaInl" alt="$(a_0, 2 a_1, \ldots, (i+1)a_i, \ldots, n a_{n-1})^\transpose$" src="form_496.png">. <div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (g1.is_point()) {
    cout &lt;&lt; <span class="stringliteral">"Point g1: "</span> &lt;&lt; g1 &lt;&lt; endl;
    Linear_Expression e;
    <span class="keywordflow">for</span> (<a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i = g1.space_dimension(); i-- &gt; 0; )
      e += (i + 1) * g1.coefficient(Variable(i)) * Variable(i);
    <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> g2 = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#5c56451d80b8c02636854053de9e0440" title="Returns the closure point at e / d.">closure_point</a>(e, g1.divisor());
    cout &lt;&lt; <span class="stringliteral">"Closure point g2: "</span> &lt;&lt; g2 &lt;&lt; endl;
  }
  <span class="keywordflow">else</span>
    cout &lt;&lt; <span class="stringliteral">"Generator g1 is not a point."</span> &lt;&lt; endl;
</pre></div> Therefore, for the point <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy-constructor.">Generator</a> g1 = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(2*x - y + 3*z, 2);
</pre></div> we would obtain the following output: <div class="fragment"><pre class="fragment">  Point g1: p((2*A - B + 3*C)/2)
  Closure <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a> g2: cp((2*A - 2*B + 9*C)/2)
</pre></div> When working with (closure) points, be careful not to confuse the notion of <em>coefficient</em> with the notion of <em>coordinate</em>: these are equivalent only when the divisor of the (closure) point is 1. </dd></dl>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="55b76ba0041601d8da38ab5ad619eed5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::Type" ref="55b76ba0041601d8da38ab5ad619eed5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#55b76ba0041601d8da38ab5ad619eed5">Parma_Polyhedra_Library::Generator::Type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The generator type. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="55b76ba0041601d8da38ab5ad619eed54312979a12cae5ebb0791496e1ccce7a"></a><!-- doxytag: member="LINE" ref="55b76ba0041601d8da38ab5ad619eed54312979a12cae5ebb0791496e1ccce7a" args="" -->LINE</em>&nbsp;</td><td>
The generator is a line. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="55b76ba0041601d8da38ab5ad619eed505abaa6ff4aa204c25c94719e8a2b6f4"></a><!-- doxytag: member="RAY" ref="55b76ba0041601d8da38ab5ad619eed505abaa6ff4aa204c25c94719e8a2b6f4" args="" -->RAY</em>&nbsp;</td><td>
The generator is a ray. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="55b76ba0041601d8da38ab5ad619eed5b7fe867b1243e111ef4364e3ef5b5329"></a><!-- doxytag: member="POINT" ref="55b76ba0041601d8da38ab5ad619eed5b7fe867b1243e111ef4364e3ef5b5329" args="" -->POINT</em>&nbsp;</td><td>
The generator is a point. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="55b76ba0041601d8da38ab5ad619eed5bed2d3fff60e7c0b8fc325bf46f9725f"></a><!-- doxytag: member="CLOSURE_POINT" ref="55b76ba0041601d8da38ab5ad619eed5bed2d3fff60e7c0b8fc325bf46f9725f" args="" -->CLOSURE_POINT</em>&nbsp;</td><td>
The generator is a closure point. </td></tr>
</table>
</dl>

<p>Reimplemented in <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html#10e7c95784e356487a6a6263a89cec66">Parma_Polyhedra_Library::Grid_Generator</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="584f3fd5a19536644a66818169b16ac6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::line" ref="584f3fd5a19536644a66818169b16ac6" args="(const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> line           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the line of direction <code>e</code>. 
<p>
Shorthand for <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html" title="A line, ray, point or closure point.">Generator</a> <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#584f3fd5a19536644a66818169b16ac6" title="Returns the line of direction e.">Generator::line(const Linear_Expression&amp; e)</a>.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the homogeneous part of <code>e</code> represents the origin of the vector space.</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b36bf020da4fb4583e6e1a6b94197cb4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::ray" ref="b36bf020da4fb4583e6e1a6b94197cb4" args="(const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> ray           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the ray of direction <code>e</code>. 
<p>
Shorthand for <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html" title="A line, ray, point or closure point.">Generator</a> <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#b36bf020da4fb4583e6e1a6b94197cb4" title="Returns the ray of direction e.">Generator::ray(const Linear_Expression&amp; e)</a>.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the homogeneous part of <code>e</code> represents the origin of the vector space.</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6b8dae6436867a53e27720ee211f1cc7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::point" ref="6b8dae6436867a53e27720ee211f1cc7" args="(const Linear_Expression &amp;e=Linear_Expression::zero(), Coefficient_traits::const_reference d=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> point           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em> = <code>Linear_Expression::zero()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the point at <code>e</code> / <code>d</code>. 
<p>
Shorthand for <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html" title="A line, ray, point or closure point.">Generator</a> <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">Generator::point(const Linear_Expression&amp; e, Coefficient_traits::const_reference d)</a>.<p>
Both <code>e</code> and <code>d</code> are optional arguments, with default values <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero()</a> and <a class="el" href="namespaceParma__Polyhedra__Library.html#66438955854cf73ddaf27a40a69fec7b" title="Returns a const reference to a Coefficient with value 1.">Coefficient_one()</a>, respectively.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>d</code> is zero.</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5c56451d80b8c02636854053de9e0440"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::closure_point" ref="5c56451d80b8c02636854053de9e0440" args="(const Linear_Expression &amp;e=Linear_Expression::zero(), Coefficient_traits::const_reference d=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> closure_point           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em> = <code>Linear_Expression::zero()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the closure point at <code>e</code> / <code>d</code>. 
<p>
Shorthand for <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html" title="A line, ray, point or closure point.">Generator</a> <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#5c56451d80b8c02636854053de9e0440" title="Returns the closure point at e / d.">Generator::closure_point(const Linear_Expression&amp; e, Coefficient_traits::const_reference d)</a>.<p>
Both <code>e</code> and <code>d</code> are optional arguments, with default values <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero()</a> and <a class="el" href="namespaceParma__Polyhedra__Library.html#66438955854cf73ddaf27a40a69fec7b" title="Returns a const reference to a Coefficient with value 1.">Coefficient_one()</a>, respectively.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>d</code> is zero.</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fceefab91d648d188e42e5a75a3a977e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::coefficient" ref="fceefab91d648d188e42e5a75a3a977e" args="(Variable v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient_traits::const_reference Parma_Polyhedra_Library::Generator::coefficient           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the coefficient of <code>v</code> in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the index of <code>v</code> is greater than or equal to the space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html#f4e7705af87f5eb64d2ebdc60cd7a36e">Parma_Polyhedra_Library::Grid_Generator</a>.</p>

</div>
</div><p>
<a class="anchor" name="eff190ba56f86d3425859043689d499a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::divisor" ref="eff190ba56f86d3425859043689d499a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient_traits::const_reference Parma_Polyhedra_Library::Generator::divisor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If <code>*this</code> is either a point or a closure point, returns its divisor. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is neither a point nor a closure point. </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html#cdc0aeddab3d98e336719f42e6e5b06c">Parma_Polyhedra_Library::Grid_Generator</a>.</p>

</div>
</div><p>
<a class="anchor" name="42867df59ec40173391b76074f9f0fb2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::is_equivalent_to" ref="42867df59ec40173391b76074f9f0fb2" args="(const Generator &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Generator::is_equivalent_to           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are equivalent generators. 
<p>
Generators having different space dimensions are not equivalent. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="303b4ed4262469c1834228e0f88dba74"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::operator&lt;&lt;" ref="303b4ed4262469c1834228e0f88dba74" args="(std::ostream &amp;s, const Generator &amp;g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output operator. 
<p>

</div>
</div><p>
<a class="anchor" name="10cab5245f80aacd8000d0312730ec03"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::swap" ref="10cab5245f80aacd8000d0312730ec03" args="(Parma_Polyhedra_Library::Generator &amp;x, Parma_Polyhedra_Library::Generator &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Parma_Polyhedra_Library::Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Parma_Polyhedra_Library::Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specializes <code>std::swap</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="d7552a414d66f92897d12767579fa3ca"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::operator==" ref="d7552a414d66f92897d12767579fa3ca" args="(const Generator &amp;x, const Generator &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> is equivalent to <code>y</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="0c26ae11a4146369ff86288347cc54db"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::operator!=" ref="0c26ae11a4146369ff86288347cc54db" args="(const Generator &amp;x, const Generator &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> is not equivalent to <code>y</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="e6206985cd5536c4dac181de5fb21247"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::rectilinear_distance_assign" ref="e6206985cd5536c4dac181de5fb21247" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Generator &amp;x, const Generator &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. 
<p>
Computes the euclidean distance between <code>x</code> and <code>y</code>.<p>
If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>
If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>
If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>

</div>
</div><p>
<a class="anchor" name="5363ddeed325652ee6c064a8936cfe57"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::rectilinear_distance_assign" ref="5363ddeed325652ee6c064a8936cfe57" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Generator &amp;x, const Generator &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. 
<p>
If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>

</div>
</div><p>
<a class="anchor" name="a98511973ca14e8904e4e2c1f774bd3a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::euclidean_distance_assign" ref="a98511973ca14e8904e4e2c1f774bd3a" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Generator &amp;x, const Generator &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the euclidean distance between <code>x</code> and <code>y</code>. 
<p>
If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>

</div>
</div><p>
<a class="anchor" name="f4abff14e1b88cbb929f0733432477ff"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::euclidean_distance_assign" ref="f4abff14e1b88cbb929f0733432477ff" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Generator &amp;x, const Generator &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the euclidean distance between <code>x</code> and <code>y</code>. 
<p>
If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>

</div>
</div><p>
<a class="anchor" name="0fb144e5f3fb6815e4c28c89883607be"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::l_infinity_distance_assign" ref="0fb144e5f3fb6815e4c28c89883607be" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Generator &amp;x, const Generator &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code>. 
<p>
If the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>
If the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>

</div>
</div><p>
<a class="anchor" name="e67eb83f2626818420b3201db09e3d58"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::l_infinity_distance_assign" ref="e67eb83f2626818420b3201db09e3d58" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Generator &amp;x, const Generator &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code>. 
<p>
If the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>

</div>
</div><p>
<a class="anchor" name="75190def344d4c1ba6c59a6f0fcf7420"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::operator&lt;&lt;" ref="75190def344d4c1ba6c59a6f0fcf7420" args="(std::ostream &amp;s, const Generator::Type &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#55b76ba0041601d8da38ab5ad619eed5">Generator::Type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output operator. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 18 07:13:19 2009 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
