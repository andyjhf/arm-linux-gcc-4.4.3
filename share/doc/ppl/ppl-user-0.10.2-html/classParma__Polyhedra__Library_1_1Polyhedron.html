<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PPL: Parma_Polyhedra_Library::Polyhedron Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::Polyhedron Class Reference<br>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::Polyhedron" -->The base class for convex polyhedra.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ppl.hh&gt;</code>
<p>
Inherited by <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">Parma_Polyhedra_Library::C_Polyhedron</a>, and <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">Parma_Polyhedra_Library::NNC_Polyhedron</a>.
<p>

<p>
<a href="classParma__Polyhedra__Library_1_1Polyhedron-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5dfef947c46e234a1ffd4707312332ec"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::coefficient_type" ref="5dfef947c46e234a1ffd4707312332ec" args="" -->
typedef <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#5dfef947c46e234a1ffd4707312332ec">coefficient_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The numeric type of coefficients. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the Polyhedron</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="43cd840b1ec99350c222b3f217739cea"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::space_dimension" ref="43cd840b1ec99350c222b3f217739cea" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#43cd840b1ec99350c222b3f217739cea">space_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="97ddb3b93ac699eebaca7e79f691b0ad"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::affine_dimension" ref="97ddb3b93ac699eebaca7e79f691b0ad" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#97ddb3b93ac699eebaca7e79f691b0ad">affine_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <img class="formulaInl" alt="$0$" src="form_562.png">, if <code>*this</code> is empty; otherwise, returns the <a class="el" href="main.html#Affine_Independence_and_Affine_Dimension">affine dimension</a> of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7b8d597a3c23af1fce9d8d3e1d36e11d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::constraints" ref="7b8d597a3c23af1fce9d8d3e1d36e11d" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#7b8d597a3c23af1fce9d8d3e1d36e11d">constraints</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of constraints. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7a35f8df974c9e932df6291754859fb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::minimized_constraints" ref="b7a35f8df974c9e932df6291754859fb" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#b7a35f8df974c9e932df6291754859fb">minimized_constraints</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of constraints, with no redundant constraint. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2bf7987a6ee3547c1e125e83e432ee2a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::generators" ref="2bf7987a6ee3547c1e125e83e432ee2a" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#2bf7987a6ee3547c1e125e83e432ee2a">generators</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of generators. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e1c5216e2ba5c80d77e128daea25b46e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::minimized_generators" ref="e1c5216e2ba5c80d77e128daea25b46e" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#e1c5216e2ba5c80d77e128daea25b46e">minimized_generators</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of generators, with no redundant generator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6fb94f0e966e97bfb9dcf43dddcf12ba"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::congruences" ref="6fb94f0e966e97bfb9dcf43dddcf12ba" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#6fb94f0e966e97bfb9dcf43dddcf12ba">congruences</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of (equality) congruences satisfied by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c6ea1802e6a6cfb32e5af6d6d26eb424"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::minimized_congruences" ref="c6ea1802e6a6cfb32e5af6d6d26eb424" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#c6ea1802e6a6cfb32e5af6d6d26eb424">minimized_congruences</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of (equality) congruences satisfied by <code>*this</code>, with no redundant congruences and having the same affine dimension as <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cb75fd68aa10bd15e590e8e8954c5002"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::grid_generators" ref="cb75fd68aa10bd15e590e8e8954c5002" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#cb75fd68aa10bd15e590e8e8954c5002">grid_generators</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a universe system of grid generators. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0d69bc8c9bd9843262551c7e3e33f5a2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::minimized_grid_generators" ref="0d69bc8c9bd9843262551c7e3e33f5a2" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#0d69bc8c9bd9843262551c7e3e33f5a2">minimized_grid_generators</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a universe system of grid generators. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#9f3c5474494eb306717bc3da7c109307">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between the polyhedron <code>*this</code> and the constraint <code>c</code>.  <a href="#9f3c5474494eb306717bc3da7c109307"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#0514c2e57ac8154666e9fe6bb56c0e18">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between the polyhedron <code>*this</code> and the generator <code>g</code>.  <a href="#0514c2e57ac8154666e9fe6bb56c0e18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#6187dbe974649c7bd4de8e66f70d3e46">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between the polyhedron <code>*this</code> and the congruence <code>c</code>.  <a href="#6187dbe974649c7bd4de8e66f70d3e46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d909d5b60cab5d1a6816577c97b60fcf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::is_empty" ref="d909d5b60cab5d1a6816577c97b60fcf" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#d909d5b60cab5d1a6816577c97b60fcf">is_empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an empty polyhedron. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8c33b9ea975535b5aa0882241cf78986"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::is_universe" ref="8c33b9ea975535b5aa0882241cf78986" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#8c33b9ea975535b5aa0882241cf78986">is_universe</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a universe polyhedron. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8ed700f662722cbebdc9328344ba2839"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::is_topologically_closed" ref="8ed700f662722cbebdc9328344ba2839" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#8ed700f662722cbebdc9328344ba2839">is_topologically_closed</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a topologically closed subset of the vector space. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#c251eb38d1b24b8b570d874ee11df424">is_disjoint_from</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint.  <a href="#c251eb38d1b24b8b570d874ee11df424"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0d9abbf681b7b0724963d97596286ae5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::is_discrete" ref="0d9abbf681b7b0724963d97596286ae5" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#0d9abbf681b7b0724963d97596286ae5">is_discrete</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is discrete. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0ac997a15935821583174de968e5bff"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::is_bounded" ref="a0ac997a15935821583174de968e5bff" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a0ac997a15935821583174de968e5bff">is_bounded</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a bounded polyhedron. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bbb7562de97ccf13bd97b57bb5e3ac94"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::contains_integer_point" ref="bbb7562de97ccf13bd97b57bb5e3ac94" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#bbb7562de97ccf13bd97b57bb5e3ac94">contains_integer_point</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains at least one integer point. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#e3be29eddce8f41019e7dcb731c8ba7b">constrains</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>.  <a href="#e3be29eddce8f41019e7dcb731c8ba7b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#f740303d5461c838735ec53c5c1f8855">bounds_from_above</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>.  <a href="#f740303d5461c838735ec53c5c1f8855"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#31d70a625e092dfdaed4f3232701f35d">bounds_from_below</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>.  <a href="#31d70a625e092dfdaed4f3232701f35d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#c5c7acc50141a9104ef5b9b7598c1438">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed.  <a href="#c5c7acc50141a9104ef5b9b7598c1438"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#e680437fdc213b7174c581caa2e0c0d3">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed.  <a href="#e680437fdc213b7174c581caa2e0c0d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#d914801461cad05325559e95b9c4d9c6">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed.  <a href="#d914801461cad05325559e95b9c4d9c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#6e73a7d462d6a9a3891fff6c4a923495">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed.  <a href="#6e73a7d462d6a9a3891fff6c4a923495"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#5df26655af3ae7844569d7086edf8332">contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>.  <a href="#5df26655af3ae7844569d7086edf8332"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#c2182f38e9f8acede601c3dcfa71c3b3">strictly_contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>.  <a href="#c2182f38e9f8acede601c3dcfa71c3b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#13f15417d90174f6c2d3648e83d9fcf5">OK</a> (bool check_not_empty=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if all the invariants are satisfied.  <a href="#13f15417d90174f6c2d3648e83d9fcf5"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Space Dimension Preserving Member Functions that May Modify the Polyhedron</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#0a5c586d872f15baf7fd70941fc16c41">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of constraint <code>c</code> to the system of constraints of <code>*this</code> (without minimizing the result).  <a href="#0a5c586d872f15baf7fd70941fc16c41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#1c64e09d6022054690f7d2bdf4e02138">add_constraint_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of constraint <code>c</code> to the system of constraints of <code>*this</code>, minimizing the result.  <a href="#1c64e09d6022054690f7d2bdf4e02138"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#5d53d09dcc839672fedd4ab5d4142d57">add_generator</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of generator <code>g</code> to the system of generators of <code>*this</code> (without minimizing the result).  <a href="#5d53d09dcc839672fedd4ab5d4142d57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ec640128c6492defc09c4d6ad5d3ea19">add_generator_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of generator <code>g</code> to the system of generators of <code>*this</code>, minimizing the result.  <a href="#ec640128c6492defc09c4d6ad5d3ea19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#7df62db3bf13024d4ee9f8aaf0d27dc6">add_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of congruence <code>cg</code> to <code>*this</code>, if <code>cg</code> can be exactly represented by a polyhedron.  <a href="#7df62db3bf13024d4ee9f8aaf0d27dc6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#eb30e6558c9efffc62d5765b3bfe5e4f">add_congruence_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of congruence <code>cg</code> to <code>*this</code>, if <code>cg</code> can be exactly represented by a polyhedron, minimizing the result.  <a href="#eb30e6558c9efffc62d5765b3bfe5e4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#f60c3f345fb8ec8c708e49e8fa33f737">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the constraints in <code>cs</code> to the system of constraints of <code>*this</code> (without minimizing the result).  <a href="#f60c3f345fb8ec8c708e49e8fa33f737"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#4f9a47ba1b29f1e07a32542584d50686">add_recycled_constraints</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code> (without minimizing the result).  <a href="#4f9a47ba1b29f1e07a32542584d50686"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#304e74729ca34fc67648cbc995e1dfc7">add_constraints_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the constraints in <code>cs</code> to the system of constraints of <code>*this</code>, minimizing the result.  <a href="#304e74729ca34fc67648cbc995e1dfc7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#e6eef0ed4aa8b3690f01f774dd0722fc">add_recycled_constraints_and_minimize</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code>, minimizing the result.  <a href="#e6eef0ed4aa8b3690f01f774dd0722fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#9a45b4b8f148a20359a2f3e2b1c2cb2d">add_generators</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the generators in <code>gs</code> to the system of generators of <code>*this</code> (without minimizing the result).  <a href="#9a45b4b8f148a20359a2f3e2b1c2cb2d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#b1b315e7f04c051a36f48d344dd34052">add_recycled_generators</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the generators in <code>gs</code> to the system of generators of <code>*this</code> (without minimizing the result).  <a href="#b1b315e7f04c051a36f48d344dd34052"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#be643d7919aa34a2c1112702878f5536">add_generators_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the generators in <code>gs</code> to the system of generators of <code>*this</code>, minimizing the result.  <a href="#be643d7919aa34a2c1112702878f5536"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#7a8abcefdfb125b7c9ef5f96d352c1df">add_recycled_generators_and_minimize</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the generators in <code>gs</code> to the system of generators of <code>*this</code>, minimizing the result.  <a href="#7a8abcefdfb125b7c9ef5f96d352c1df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#96e902093a55f87f0aebc2bb13a8d740">add_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the congruences in <code>cgs</code> to <code>*this</code>, if all the congruences can be exactly represented by a polyhedron.  <a href="#96e902093a55f87f0aebc2bb13a8d740"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#7e4bbfa6f481ead40e3ca6231e0f69be">add_congruences_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the congruences in <code>cgs</code> to <code>*this</code>, if all the congruences can be exactly represented by a polyhedron, minimizing the result.  <a href="#7e4bbfa6f481ead40e3ca6231e0f69be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#3569a428ad758dc9ac8273e0f1f77772">add_recycled_congruences</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the congruences in <code>cgs</code> to <code>*this</code>, if all the congruences can be exactly represented by a polyhedron.  <a href="#3569a428ad758dc9ac8273e0f1f77772"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#2aaf9117efebc52a8b45b787075a9647">add_recycled_congruences_and_minimize</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the congruences in <code>cgs</code> to <code>*this</code>, if all the congruences can be exactly represented by a polyhedron, minimizing the result.  <a href="#2aaf9117efebc52a8b45b787075a9647"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#d6a8cc7029bad7ad7ad116c90ff59aec">refine_with_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of constraint <code>c</code> to refine <code>*this</code>.  <a href="#d6a8cc7029bad7ad7ad116c90ff59aec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#236a18fe8cc922d00ee92a6c6e42f923">refine_with_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of congruence <code>cg</code> to refine <code>*this</code>.  <a href="#236a18fe8cc922d00ee92a6c6e42f923"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#bfd98397c137d81dcc27111fba3ccd54">refine_with_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the constraints in <code>cs</code> to refine <code>*this</code>.  <a href="#bfd98397c137d81dcc27111fba3ccd54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a26e1a5815b7a0c3b610395c854594bf">refine_with_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the congruences in <code>cgs</code> to refine <code>*this</code>.  <a href="#a26e1a5815b7a0c3b610395c854594bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#3c1e5a2419a5f4a5cf89133606ed1680">unconstrain</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>.  <a href="#3c1e5a2419a5f4a5cf89133606ed1680"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#9ca6b6eed07fd3b72119b8ea58328e5e">unconstrain</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_unconstrained)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>to_be_unconstrained</code>, assigning the result to <code>*this</code>.  <a href="#9ca6b6eed07fd3b72119b8ea58328e5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#8132d1a9b329271fb4f7faeb59c89c39">intersection_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>. The result is not guaranteed to be minimized.  <a href="#8132d1a9b329271fb4f7faeb59c89c39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#1956a63a72283d208851d3fe2b11989b">intersection_assign_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>, minimizing the result.  <a href="#1956a63a72283d208851d3fe2b11989b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#4b428098e57a9101473a54cd71a0753f">poly_hull_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the poly-hull of <code>*this</code> and <code>y</code>. The result is not guaranteed to be minimized.  <a href="#4b428098e57a9101473a54cd71a0753f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#97011210c7f0b2efa0f837ef2da6c5b3">poly_hull_assign_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the poly-hull of <code>*this</code> and <code>y</code>, minimizing the result.  <a href="#97011210c7f0b2efa0f837ef2da6c5b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e68bea365fe939d08c91ec4edc61a2b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::upper_bound_assign" ref="7e68bea365fe939d08c91ec4edc61a2b" args="(const Polyhedron &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#7e68bea365fe939d08c91ec4edc61a2b">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as poly_hull_assign(y). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#672b0568e7a27c37b3afde649f7c0171">poly_difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Convex_Polyhedral_Difference">poly-difference</a> of <code>*this</code> and <code>y</code>. The result is not guaranteed to be minimized.  <a href="#672b0568e7a27c37b3afde649f7c0171"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eb14f5522982b3874f2cd19586813421"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::difference_assign" ref="eb14f5522982b3874f2cd19586813421" args="(const Polyhedron &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#eb14f5522982b3874f2cd19586813421">difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as poly_difference_assign(y). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a809bff4b85d09cd801e5e5cde1b8c06">simplify_using_context_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty.  <a href="#a809bff4b85d09cd801e5e5cde1b8c06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#c93800b9ec7aae75937598e1f2209b1f">affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#c93800b9ec7aae75937598e1f2209b1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#f47944944e16e786df5c0671e7baa995">affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#f47944944e16e786df5c0671e7baa995"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#4f514edad990412bd66cc666347103ab">generalized_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>.  <a href="#4f514edad990412bd66cc666347103ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#08e91d11b3deb5b694356b5573d2547a">generalized_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>.  <a href="#08e91d11b3deb5b694356b5573d2547a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#50e1047c49fffb06bc5089a06a051a3d">generalized_affine_image</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>.  <a href="#50e1047c49fffb06bc5089a06a051a3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#cbc86683af6afc0818cc9e980a84fcb8">generalized_affine_preimage</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>.  <a href="#cbc86683af6afc0818cc9e980a84fcb8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#e89cd985111a1a27c60a6fcc28ae9788">bounded_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">.  <a href="#e89cd985111a1a27c60a6fcc28ae9788"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#371deb67f73bf27ac9a7ff6f2216db9c">bounded_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">.  <a href="#371deb67f73bf27ac9a7ff6f2216db9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#98c785602c5af8f7e0c1be92bb5e8b71">time_elapse_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>.  <a href="#98c785602c5af8f7e0c1be92bb5e8b71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e10fbc38125e63858549f5ec8a25e046"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::topological_closure_assign" ref="e10fbc38125e63858549f5ec8a25e046" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#e10fbc38125e63858549f5ec8a25e046">topological_closure_assign</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#7366f9b91109b63f078e963bccd9f5b4">BHRZ03_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#BHRZ03_widening">BHRZ03-widening</a> between <code>*this</code> and <code>y</code>.  <a href="#7366f9b91109b63f078e963bccd9f5b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#281b8db6a8e0014ab2c41dd15f8c0708">limited_BHRZ03_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#limited_extrapolation">limited extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#BHRZ03_widening">BHRZ03-widening</a> operator.  <a href="#281b8db6a8e0014ab2c41dd15f8c0708"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#1a3647877302fc6e0e583b8b881a7a4f">bounded_BHRZ03_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#bounded_extrapolation">bounded extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#BHRZ03_widening">BHRZ03-widening</a> operator.  <a href="#1a3647877302fc6e0e583b8b881a7a4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#f074d4d4d406dd065812b32cc8714222">H79_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#H79_widening">H79_widening</a> between <code>*this</code> and <code>y</code>.  <a href="#f074d4d4d406dd065812b32cc8714222"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6e9d9dd7740b414d407c16687c99a88e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::widening_assign" ref="6e9d9dd7740b414d407c16687c99a88e" args="(const Polyhedron &amp;y, unsigned *tp=0)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#6e9d9dd7740b414d407c16687c99a88e">widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as H79_widening_assign(y, tp). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#cf531d280805472a54c22fed0f689932">limited_H79_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#limited_extrapolation">limited extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#H79_widening">H79-widening</a> operator.  <a href="#cf531d280805472a54c22fed0f689932"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#9764ef2f159cfdcca3f151e899bd43ef">bounded_H79_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#bounded_extrapolation">bounded extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#H79_widening">H79-widening</a> operator.  <a href="#9764ef2f159cfdcca3f151e899bd43ef"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Dimension of the Vector Space</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#527e7c81841bbcf1963c6e260dadfe01">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new space dimensions and embeds the old polyhedron in the new vector space.  <a href="#527e7c81841bbcf1963c6e260dadfe01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a6b6fed08414c86d33fc4a44c59e9e22">add_space_dimensions_and_project</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new space dimensions to the polyhedron and does not embed it in the new vector space.  <a href="#a6b6fed08414c86d33fc4a44c59e9e22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#87ebe6f7cd176227f61c6d0fe47a4f68">concatenate_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order.  <a href="#87ebe6f7cd176227f61c6d0fe47a4f68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#4c11206af59b0f6a5471aded55d20961">remove_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_removed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the specified dimensions from the vector space.  <a href="#4c11206af59b0f6a5471aded55d20961"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#dee3b5c0c3800ce2214e68a156cbcf77">remove_higher_space_dimensions</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> new_dimension)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the higher dimensions of the vector space so that the resulting space will have dimension <code>new_dimension</code>.  <a href="#dee3b5c0c3800ce2214e68a156cbcf77"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Partial_Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#787615432c9f1d6aac5a6394aea8cfa9">map_space_dimensions</a> (const Partial_Function &amp;pfunc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>.  <a href="#787615432c9f1d6aac5a6394aea8cfa9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#6b737abc8f33b2a2362e3f9c9ab08d58">expand_space_dimension</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>.  <a href="#6b737abc8f33b2a2362e3f9c9ab08d58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#dd7b66394e6c54bc1ae03a4ed9a33c9e">fold_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_folded, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Folds the space dimensions in <code>to_be_folded</code> into <code>var</code>.  <a href="#dd7b66394e6c54bc1ae03a4ed9a33c9e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous Member Functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c58bbc8bf8db5f570da3db42a0ae2f7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::~Polyhedron" ref="0c58bbc8bf8db5f570da3db42a0ae2f7" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#0c58bbc8bf8db5f570da3db42a0ae2f7">~Polyhedron</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ca90e7afe251a0d4174dcf538b34006b">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps <code>*this</code> with polyhedron <code>y</code>. (<code>*this</code> and <code>y</code> can be dimension-incompatible.).  <a href="#ca90e7afe251a0d4174dcf538b34006b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="547a8d96908afe5a7f9e4ba2e10d7ac8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::ascii_dump" ref="547a8d96908afe5a7f9e4ba2e10d7ac8" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#547a8d96908afe5a7f9e4ba2e10d7ac8">ascii_dump</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="efab726809c553c136e5d8fda50c276e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::ascii_dump" ref="efab726809c553c136e5d8fda50c276e" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#efab726809c553c136e5d8fda50c276e">ascii_dump</a> (std::ostream &amp;s) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d7db8ee4d8972c1818a36d6517ebbff"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::print" ref="1d7db8ee4d8972c1818a36d6517ebbff" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#1d7db8ee4d8972c1818a36d6517ebbff">print</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a38fbbd15d5dc2e98d5b24c92b06c290"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::ascii_load" ref="a38fbbd15d5dc2e98d5b24c92b06c290" args="(std::istream &amp;s)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a38fbbd15d5dc2e98d5b24c92b06c290">ascii_load</a> (std::istream &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#efab726809c553c136e5d8fda50c276e" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6c7c72e56241da463eaeccdff79b6d49"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::total_memory_in_bytes" ref="6c7c72e56241da463eaeccdff79b6d49" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#6c7c72e56241da463eaeccdff79b6d49">total_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a78179b1d8478dce6cf572af8e0b9cb4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::external_memory_in_bytes" ref="a78179b1d8478dce6cf572af8e0b9cb4" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a78179b1d8478dce6cf572af8e0b9cb4">external_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#86d2bbceaa288f2f605ac88516d313cb">hash_code</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a 32-bit hash code for <code>*this</code>.  <a href="#86d2bbceaa288f2f605ac88516d313cb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="73cb0d61cccb259e06b68d4f83deb6d7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::max_space_dimension" ref="73cb0d61cccb259e06b68d4f83deb6d7" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#73cb0d61cccb259e06b68d4f83deb6d7">max_space_dimension</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension all kinds of <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a> can handle. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b49993a1cd4fc6891da88a6259b9f93"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::can_recycle_constraint_systems" ref="3b49993a1cd4fc6891da88a6259b9f93" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#3b49993a1cd4fc6891da88a6259b9f93">can_recycle_constraint_systems</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> indicating that this domain has methods that can recycle constraints. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a39bdf85d6db02629fa73bbcaddab6d5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::initialize" ref="a39bdf85d6db02629fa73bbcaddab6d5" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a39bdf85d6db02629fa73bbcaddab6d5">initialize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e58a861a42c5216a2267e3f94ecaec8c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::finalize" ref="e58a861a42c5216a2267e3f94ecaec8c" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#e58a861a42c5216a2267e3f94ecaec8c">finalize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalizes the class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f496ec55802726ee3b39e52458ab0647"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::can_recycle_congruence_systems" ref="f496ec55802726ee3b39e52458ab0647" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#f496ec55802726ee3b39e52458ab0647">can_recycle_congruence_systems</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>false</code> indicating that this domain cannot recycle congruences. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#b6ab1820f2fdf444d1431ff3af424451">Polyhedron</a> (Topology topol, <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions, <a class="el" href="group__PPL__CXX__interface.html#g616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a polyhedron having the specified properties.  <a href="#b6ab1820f2fdf444d1431ff3af424451"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#b4959b3da46291de301d9150f5afc3aa">Polyhedron</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy-constructor.  <a href="#b4959b3da46291de301d9150f5afc3aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#858e0030826ee6c29545a934166874ef">Polyhedron</a> (Topology topol, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a polyhedron from a system of constraints.  <a href="#858e0030826ee6c29545a934166874ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#1cecffe684d1faa9b0f6b8d4f227e9ae">Polyhedron</a> (Topology topol, <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a polyhedron recycling a system of constraints.  <a href="#1cecffe684d1faa9b0f6b8d4f227e9ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#d6d1e866b7ba9bf4233f3a5254cda0f9">Polyhedron</a> (Topology topol, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a polyhedron from a system of generators.  <a href="#d6d1e866b7ba9bf4233f3a5254cda0f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#fc2a04d2049183cddbcf70316fdf40e7">Polyhedron</a> (Topology topol, <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a polyhedron recycling a system of generators.  <a href="#fc2a04d2049183cddbcf70316fdf40e7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#dad834921ba7c139b0cb10c507b4070a">Polyhedron</a> (Topology topol, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a polyhedron from a box.  <a href="#dad834921ba7c139b0cb10c507b4070a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f15f956dac6d4b19ecd8fee0f9718f29"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::operator=" ref="f15f956dac6d4b19ecd8fee0f9718f29" args="(const Polyhedron &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#f15f956dac6d4b19ecd8fee0f9718f29">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The assignment operator. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#d84befb6d0ded481871cbef1b7306824">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;ph)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#d84befb6d0ded481871cbef1b7306824"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#8af124edba7c75bc76ec394405aa893e">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different polyhedra.  <a href="#8af124edba7c75bc76ec394405aa893e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#67a7d08f3cda46f7a743d46f3a6f33b5">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Parma_Polyhedra_Library::Polyhedron</a> &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Parma_Polyhedra_Library::Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#67a7d08f3cda46f7a743d46f3a6f33b5"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The base class for convex polyhedra. 
<p>
An object of the class <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a> represents a convex polyhedron in the vector space <img class="formulaInl" alt="$\Rset^n$" src="form_16.png">.<p>
A polyhedron can be specified as either a finite system of constraints or a finite system of generators (see Section <a class="el" href="main.html#representation">Representations of Convex Polyhedra</a>) and it is always possible to obtain either representation. That is, if we know the system of constraints, we can obtain from this the system of generators that define the same polyhedron and vice versa. These systems can contain redundant members: in this case we say that they are not in the minimal form.<p>
Two key attributes of any polyhedron are its topological kind (recording whether it is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> or an <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html" title="A not necessarily closed convex polyhedron.">NNC_Polyhedron</a> object) and its space dimension (the dimension <img class="formulaInl" alt="$n \in \Nset$" src="form_121.png"> of the enclosing vector space):<p>
<ul>
<li>all polyhedra, the empty ones included, are endowed with a specific topology and space dimension;</li><li>most operations working on a polyhedron and another object (i.e., another polyhedron, a constraint or generator, a set of variables, etc.) will throw an exception if the polyhedron and the object are not both topology-compatible and dimension-compatible (see Section <a class="el" href="main.html#representation">Representations of Convex Polyhedra</a>);</li><li>the topology of a polyhedron cannot be changed; rather, there are constructors for each of the two derived classes that will build a new polyhedron with the topology of that class from another polyhedron from either class and any topology;</li><li>the only ways in which the space dimension of a polyhedron can be changed are:<ul>
<li><em>explicit</em> calls to operators provided for that purpose;</li><li>standard copy, assignment and swap operators.</li></ul>
</li></ul>
<p>
Note that four different polyhedra can be defined on the zero-dimension space: the empty polyhedron, either closed or NNC, and the universe polyhedron <img class="formulaInl" alt="$R^0$" src="form_513.png">, again either closed or NNC.<p>
<dl class="user" compact><dt><b></b></dt><dd>In all the examples it is assumed that variables <code>x</code> and <code>y</code> are defined (where they are used) as follows: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 1</b></dt><dd>The following code builds a polyhedron corresponding to a square in <img class="formulaInl" alt="$\Rset^2$" src="form_106.png">, given as a system of constraints: <div class="fragment"><pre class="fragment">  Constraint_System cs;
  cs.insert(x &gt;= 0);
  cs.insert(x &lt;= 3);
  cs.insert(y &gt;= 0);
  cs.insert(y &lt;= 3);
  C_Polyhedron ph(cs);
</pre></div> The following code builds the same polyhedron as above, but starting from a system of generators specifying the four vertices of the square: <div class="fragment"><pre class="fragment">  Generator_System gs;
  gs.insert(point(0*x + 0*y));
  gs.insert(point(0*x + 3*y));
  gs.insert(point(3*x + 0*y));
  gs.insert(point(3*x + 3*y));
  C_Polyhedron ph(gs);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 2</b></dt><dd>The following code builds an unbounded polyhedron corresponding to a half-strip in <img class="formulaInl" alt="$\Rset^2$" src="form_106.png">, given as a system of constraints: <div class="fragment"><pre class="fragment">  Constraint_System cs;
  cs.insert(x &gt;= 0);
  cs.insert(x - y &lt;= 0);
  cs.insert(x - y + 1 &gt;= 0);
  C_Polyhedron ph(cs);
</pre></div> The following code builds the same polyhedron as above, but starting from the system of generators specifying the two vertices of the polyhedron and one ray: <div class="fragment"><pre class="fragment">  Generator_System gs;
  gs.insert(point(0*x + 0*y));
  gs.insert(point(0*x + y));
  gs.insert(ray(x - y));
  C_Polyhedron ph(gs);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Example 3</b></dt><dd>The following code builds the polyhedron corresponding to a half-plane by adding a single constraint to the universe polyhedron in <img class="formulaInl" alt="$\Rset^2$" src="form_106.png">: <div class="fragment"><pre class="fragment">  C_Polyhedron ph(2);
  ph.add_constraint(y &gt;= 0);
</pre></div> The following code builds the same polyhedron as above, but starting from the empty polyhedron in the space <img class="formulaInl" alt="$\Rset^2$" src="form_106.png"> and inserting the appropriate generators (a point, a ray and a line). <div class="fragment"><pre class="fragment">  C_Polyhedron ph(2, <a class="code" href="group__PPL__CXX__interface.html#gg616fcdc7600a3a11a8a9152e75730899c7753e1dd51e1b7b3fdfafa9f8332370" title="The empty element, i.e., the empty set.">EMPTY</a>);
  ph.add_generator(point(0*x + 0*y));
  ph.add_generator(ray(y));
  ph.add_generator(line(x));
</pre></div> Note that, although the above polyhedron has no vertices, we must add one point, because otherwise the result of the Minkowski's sum would be an empty polyhedron. To avoid subtle errors related to the minimization process, it is required that the first generator inserted in an empty polyhedron is a point (otherwise, an exception is thrown).</dd></dl>
<dl class="user" compact><dt><b>Example 4</b></dt><dd>The following code shows the use of the function <code>add_space_dimensions_and_embed</code>: <div class="fragment"><pre class="fragment">  C_Polyhedron ph(1);
  ph.add_constraint(x == 2);
  ph.add_space_dimensions_and_embed(1);
</pre></div> We build the universe polyhedron in the 1-dimension space <img class="formulaInl" alt="$\Rset$" src="form_17.png">. Then we add a single equality constraint, thus obtaining the polyhedron corresponding to the singleton set <img class="formulaInl" alt="$\{ 2 \} \sseq \Rset$" src="form_514.png">. After the last line of code, the resulting polyhedron is <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (2, y)^\transpose \in \Rset^2 \bigm| y \in \Rset \,\bigr\}. \]" src="form_515.png">
<p>
</dd></dl>
<dl class="user" compact><dt><b>Example 5</b></dt><dd>The following code shows the use of the function <code>add_space_dimensions_and_project</code>: <div class="fragment"><pre class="fragment">  C_Polyhedron ph(1);
  ph.add_constraint(x == 2);
  ph.add_space_dimensions_and_project(1);
</pre></div> The first two lines of code are the same as in Example 4 for <code>add_space_dimensions_and_embed</code>. After the last line of code, the resulting polyhedron is the singleton set <img class="formulaInl" alt="$\bigl\{ (2, 0)^\transpose \bigr\} \sseq \Rset^2$" src="form_516.png">.</dd></dl>
<dl class="user" compact><dt><b>Example 6</b></dt><dd>The following code shows the use of the function <code>affine_image</code>: <div class="fragment"><pre class="fragment">  C_Polyhedron ph(2, <a class="code" href="group__PPL__CXX__interface.html#gg616fcdc7600a3a11a8a9152e75730899c7753e1dd51e1b7b3fdfafa9f8332370" title="The empty element, i.e., the empty set.">EMPTY</a>);
  ph.add_generator(point(0*x + 0*y));
  ph.add_generator(point(0*x + 3*y));
  ph.add_generator(point(3*x + 0*y));
  ph.add_generator(point(3*x + 3*y));
  Linear_Expression expr = x + 4;
  ph.affine_image(x, expr);
</pre></div> In this example the starting polyhedron is a square in <img class="formulaInl" alt="$\Rset^2$" src="form_106.png">, the considered variable is <img class="formulaInl" alt="$x$" src="form_479.png"> and the affine expression is <img class="formulaInl" alt="$x+4$" src="form_517.png">. The resulting polyhedron is the same square translated to the right. Moreover, if the affine transformation for the same variable <code>x</code> is <img class="formulaInl" alt="$x+y$" src="form_518.png">: <div class="fragment"><pre class="fragment">  Linear_Expression expr = x + y;
</pre></div> the resulting polyhedron is a parallelogram with the height equal to the side of the square and the oblique sides parallel to the line <img class="formulaInl" alt="$x-y$" src="form_519.png">. Instead, if we do not use an invertible transformation for the same variable; for example, the affine expression <img class="formulaInl" alt="$y$" src="form_400.png">: <div class="fragment"><pre class="fragment">  Linear_Expression expr = y;
</pre></div> the resulting polyhedron is a diagonal of the square.</dd></dl>
<dl class="user" compact><dt><b>Example 7</b></dt><dd>The following code shows the use of the function <code>affine_preimage</code>: <div class="fragment"><pre class="fragment">  C_Polyhedron ph(2);
  ph.add_constraint(x &gt;= 0);
  ph.add_constraint(x &lt;= 3);
  ph.add_constraint(y &gt;= 0);
  ph.add_constraint(y &lt;= 3);
  Linear_Expression expr = x + 4;
  ph.affine_preimage(x, expr);
</pre></div> In this example the starting polyhedron, <code>var</code> and the affine expression and the denominator are the same as in Example 6, while the resulting polyhedron is again the same square, but translated to the left. Moreover, if the affine transformation for <code>x</code> is <img class="formulaInl" alt="$x+y$" src="form_518.png"> <div class="fragment"><pre class="fragment">  Linear_Expression expr = x + y;
</pre></div> the resulting polyhedron is a parallelogram with the height equal to the side of the square and the oblique sides parallel to the line <img class="formulaInl" alt="$x+y$" src="form_518.png">. Instead, if we do not use an invertible transformation for the same variable <code>x</code>, for example, the affine expression <img class="formulaInl" alt="$y$" src="form_400.png">: <div class="fragment"><pre class="fragment">  Linear_Expression expr = y;
</pre></div> the resulting polyhedron is a line that corresponds to the <img class="formulaInl" alt="$y$" src="form_400.png"> axis.</dd></dl>
<dl class="user" compact><dt><b>Example 8</b></dt><dd>For this example we use also the variables: <div class="fragment"><pre class="fragment">  Variable z(2);
  Variable w(3);
</pre></div> The following code shows the use of the function <code>remove_space_dimensions</code>: <div class="fragment"><pre class="fragment">  Generator_System gs;
  gs.insert(point(3*x + y +0*z + 2*w));
  C_Polyhedron ph(gs);
  Variables_Set to_be_removed;
  to_be_removed.insert(y);
  to_be_removed.insert(z);
  ph.remove_space_dimensions(to_be_removed);
</pre></div> The starting polyhedron is the singleton set <img class="formulaInl" alt="$\bigl\{ (3, 1, 0, 2)^\transpose \bigr\} \sseq \Rset^4$" src="form_155.png">, while the resulting polyhedron is <img class="formulaInl" alt="$\bigl\{ (3, 2)^\transpose \bigr\} \sseq \Rset^2$" src="form_520.png">. Be careful when removing space dimensions <em>incrementally</em>: since dimensions are automatically renamed after each application of the <code>remove_space_dimensions</code> operator, unexpected results can be obtained. For instance, by using the following code we would obtain a different result: <div class="fragment"><pre class="fragment">  set&lt;Variable&gt; to_be_removed1;
  to_be_removed1.insert(y);
  ph.remove_space_dimensions(to_be_removed1);
  set&lt;Variable&gt; to_be_removed2;
  to_be_removed2.insert(z);
  ph.remove_space_dimensions(to_be_removed2);
</pre></div> In this case, the result is the polyhedron <img class="formulaInl" alt="$\bigl\{(3, 0)^\transpose \bigr\} \sseq \Rset^2$" src="form_521.png">: when removing the set of dimensions <code>to_be_removed2</code> we are actually removing variable <img class="formulaInl" alt="$w$" src="form_522.png"> of the original polyhedron. For the same reason, the operator <code>remove_space_dimensions</code> is not idempotent: removing twice the same non-empty set of dimensions is never the same as removing them just once. </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="b6ab1820f2fdf444d1431ff3af424451"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="b6ab1820f2fdf444d1431ff3af424451" args="(Topology topol, dimension_type num_dimensions, Degenerate_Element kind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">Topology&nbsp;</td>
          <td class="paramname"> <em>topol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a polyhedron having the specified properties. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topol</em>&nbsp;</td><td>The topology of the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&nbsp;</td><td>The number of dimensions of the vector space enclosing the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>Specifies whether the universe or the empty polyhedron has to be built. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b4959b3da46291de301d9150f5afc3aa"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="b4959b3da46291de301d9150f5afc3aa" args="(const Polyhedron &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ordinary copy-constructor. 
<p>
The complexity argument is ignored. 
</div>
</div><p>
<a class="anchor" name="858e0030826ee6c29545a934166874ef"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="858e0030826ee6c29545a934166874ef" args="(Topology topol, const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">Topology&nbsp;</td>
          <td class="paramname"> <em>topol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a polyhedron from a system of constraints. 
<p>
The polyhedron inherits the space dimension of the constraint system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topol</em>&nbsp;</td><td>The topology of the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints defining the polyhedron.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the topology of <code>cs</code> is incompatible with <code>topol</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1cecffe684d1faa9b0f6b8d4f227e9ae"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="1cecffe684d1faa9b0f6b8d4f227e9ae" args="(Topology topol, Constraint_System &amp;cs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">Topology&nbsp;</td>
          <td class="paramname"> <em>topol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a polyhedron recycling a system of constraints. 
<p>
The polyhedron inherits the space dimension of the constraint system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topol</em>&nbsp;</td><td>The topology of the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints defining the polyhedron. It is not declared <code>const</code> because its data-structures may be recycled to build the polyhedron.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the topology of <code>cs</code> is incompatible with <code>topol</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d6d1e866b7ba9bf4233f3a5254cda0f9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="d6d1e866b7ba9bf4233f3a5254cda0f9" args="(Topology topol, const Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">Topology&nbsp;</td>
          <td class="paramname"> <em>topol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a polyhedron from a system of generators. 
<p>
The polyhedron inherits the space dimension of the generator system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topol</em>&nbsp;</td><td>The topology of the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The system of generators defining the polyhedron.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the topology of <code>gs</code> is incompatible with <code>topol</code>, or if the system of generators is not empty but has no points. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fc2a04d2049183cddbcf70316fdf40e7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="fc2a04d2049183cddbcf70316fdf40e7" args="(Topology topol, Generator_System &amp;gs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">Topology&nbsp;</td>
          <td class="paramname"> <em>topol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a polyhedron recycling a system of generators. 
<p>
The polyhedron inherits the space dimension of the generator system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topol</em>&nbsp;</td><td>The topology of the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The system of generators defining the polyhedron. It is not declared <code>const</code> because its data-structures may be recycled to build the polyhedron.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the topology of <code>gs</code> is incompatible with <code>topol</code>, or if the system of generators is not empty but has no points. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dad834921ba7c139b0cb10c507b4070a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="dad834921ba7c139b0cb10c507b4070a" args="(Topology topol, const Box&lt; Interval &gt; &amp;box, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">Topology&nbsp;</td>
          <td class="paramname"> <em>topol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a polyhedron from a box. 
<p>
This will use an algorithm whose complexity is polynomial and build the smallest polyhedron with topology <code>topol</code> containing <code>box</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topol</em>&nbsp;</td><td>The topology of the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The box representing the polyhedron to be built;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9f3c5474494eb306717bc3da7c109307"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::relation_with" ref="9f3c5474494eb306717bc3da7c109307" args="(const Constraint &amp;c) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> Parma_Polyhedra_Library::Polyhedron::relation_with           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the relations holding between the polyhedron <code>*this</code> and the constraint <code>c</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0514c2e57ac8154666e9fe6bb56c0e18"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::relation_with" ref="0514c2e57ac8154666e9fe6bb56c0e18" args="(const Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a> Parma_Polyhedra_Library::Polyhedron::relation_with           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the relations holding between the polyhedron <code>*this</code> and the generator <code>g</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6187dbe974649c7bd4de8e66f70d3e46"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::relation_with" ref="6187dbe974649c7bd4de8e66f70d3e46" args="(const Congruence &amp;cg) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> Parma_Polyhedra_Library::Polyhedron::relation_with           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the relations holding between the polyhedron <code>*this</code> and the congruence <code>c</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>c</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c251eb38d1b24b8b570d874ee11df424"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::is_disjoint_from" ref="c251eb38d1b24b8b570d874ee11df424" args="(const Polyhedron &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::is_disjoint_from           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>x</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e3be29eddce8f41019e7dcb731c8ba7b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::constrains" ref="e3be29eddce8f41019e7dcb731c8ba7b" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::constrains           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f740303d5461c838735ec53c5c1f8855"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::bounds_from_above" ref="f740303d5461c838735ec53c5c1f8855" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::bounds_from_above           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="31d70a625e092dfdaed4f3232701f35d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::bounds_from_below" ref="31d70a625e092dfdaed4f3232701f35d" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::bounds_from_below           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c5c7acc50141a9104ef5b9b7598c1438"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::maximize" ref="c5c7acc50141a9104ef5b9b7598c1438" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::maximize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if and only if the supremum is also the maximum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code> and <code>maximum</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="e680437fdc213b7174c581caa2e0c0d3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::maximize" ref="e680437fdc213b7174c581caa2e0c0d3" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::maximize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if and only if the supremum is also the maximum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>When maximization succeeds, will be assigned the point or closure point where <code>expr</code> reaches its supremum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code>, <code>maximum</code> and <code>g</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="d914801461cad05325559e95b9c4d9c6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::minimize" ref="d914801461cad05325559e95b9c4d9c6" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if and only if the infimum is also the minimum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code> and <code>minimum</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="6e73a7d462d6a9a3891fff6c4a923495"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::minimize" ref="6e73a7d462d6a9a3891fff6c4a923495" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if and only if the infimum is also the minimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>When minimization succeeds, will be assigned a point or closure point where <code>expr</code> reaches its infimum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code>, <code>minimum</code> and <code>g</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="5df26655af3ae7844569d7086edf8332"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::contains" ref="5df26655af3ae7844569d7086edf8332" args="(const Polyhedron &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c2182f38e9f8acede601c3dcfa71c3b3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::strictly_contains" ref="c2182f38e9f8acede601c3dcfa71c3b3" args="(const Polyhedron &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::strictly_contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="13f15417d90174f6c2d3648e83d9fcf5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::OK" ref="13f15417d90174f6c2d3648e83d9fcf5" args="(bool check_not_empty=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::OK           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>check_not_empty</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if all the invariants are satisfied. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if and only if <code>*this</code> satisfies all the invariants and either <code>check_not_empty</code> is <code>false</code> or <code>*this</code> is not empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check_not_empty</em>&nbsp;</td><td><code>true</code> if and only if, in addition to checking the invariants, <code>*this</code> must be checked to be not empty.</td></tr>
  </table>
</dl>
The check is performed so as to intrude as little as possible. If the library has been compiled with run-time assertions enabled, error messages are written on <code>std::cerr</code> in case invariants are violated. This is useful for the purpose of debugging the library. 
</div>
</div><p>
<a class="anchor" name="0a5c586d872f15baf7fd70941fc16c41"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_constraint" ref="0a5c586d872f15baf7fd70941fc16c41" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_constraint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of constraint <code>c</code> to the system of constraints of <code>*this</code> (without minimizing the result). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint that will be added to the system of constraints of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1c64e09d6022054690f7d2bdf4e02138"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_constraint_and_minimize" ref="1c64e09d6022054690f7d2bdf4e02138" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::add_constraint_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of constraint <code>c</code> to the system of constraints of <code>*this</code>, minimizing the result. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint that will be added to the system of constraints of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are topology-incompatible or dimension-incompatible.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d53d09dcc839672fedd4ab5d4142d57"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_generator" ref="5d53d09dcc839672fedd4ab5d4142d57" args="(const Generator &amp;g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_generator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of generator <code>g</code> to the system of generators of <code>*this</code> (without minimizing the result). 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are topology-incompatible or dimension-incompatible, or if <code>*this</code> is an empty polyhedron and <code>g</code> is not a point. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ec640128c6492defc09c4d6ad5d3ea19"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_generator_and_minimize" ref="ec640128c6492defc09c4d6ad5d3ea19" args="(const Generator &amp;g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::add_generator_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of generator <code>g</code> to the system of generators of <code>*this</code>, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are topology-incompatible or dimension-incompatible, or if <code>*this</code> is an empty polyhedron and <code>g</code> is not a point.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7df62db3bf13024d4ee9f8aaf0d27dc6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_congruence" ref="7df62db3bf13024d4ee9f8aaf0d27dc6" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_congruence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of congruence <code>cg</code> to <code>*this</code>, if <code>cg</code> can be exactly represented by a polyhedron. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible, of if <code>cg</code> is a proper congruence which is neither a tautology, nor a contradiction. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="eb30e6558c9efffc62d5765b3bfe5e4f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_congruence_and_minimize" ref="eb30e6558c9efffc62d5765b3bfe5e4f" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::add_congruence_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of congruence <code>cg</code> to <code>*this</code>, if <code>cg</code> can be exactly represented by a polyhedron, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible, of if <code>cg</code> is a proper congruence which is neither a tautology, nor a contradiction.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f60c3f345fb8ec8c708e49e8fa33f737"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_constraints" ref="f60c3f345fb8ec8c708e49e8fa33f737" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_constraints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of the constraints in <code>cs</code> to the system of constraints of <code>*this</code> (without minimizing the result). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>Contains the constraints that will be added to the system of constraints of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4f9a47ba1b29f1e07a32542584d50686"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_recycled_constraints" ref="4f9a47ba1b29f1e07a32542584d50686" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_recycled_constraints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code> (without minimizing the result). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be added to <code>*this</code>. The constraints in <code>cs</code> may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are topology-incompatible or dimension-incompatible.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="304e74729ca34fc67648cbc995e1dfc7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_constraints_and_minimize" ref="304e74729ca34fc67648cbc995e1dfc7" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::add_constraints_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of the constraints in <code>cs</code> to the system of constraints of <code>*this</code>, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>Contains the constraints that will be added to the system of constraints of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are topology-incompatible or dimension-incompatible.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e6eef0ed4aa8b3690f01f774dd0722fc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_recycled_constraints_and_minimize" ref="e6eef0ed4aa8b3690f01f774dd0722fc" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::add_recycled_constraints_and_minimize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code>, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be added to <code>*this</code>. The constraints in <code>cs</code> may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are topology-incompatible or dimension-incompatible.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cs</code> upon successful or exceptional return is that it can be safely destroyed.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9a45b4b8f148a20359a2f3e2b1c2cb2d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_generators" ref="9a45b4b8f148a20359a2f3e2b1c2cb2d" args="(const Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_generators           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of the generators in <code>gs</code> to the system of generators of <code>*this</code> (without minimizing the result). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>Contains the generators that will be added to the system of generators of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>gs</code> are topology-incompatible or dimension-incompatible, or if <code>*this</code> is empty and the system of generators <code>gs</code> is not empty, but has no points. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b1b315e7f04c051a36f48d344dd34052"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_recycled_generators" ref="b1b315e7f04c051a36f48d344dd34052" args="(Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_recycled_generators           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the generators in <code>gs</code> to the system of generators of <code>*this</code> (without minimizing the result). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The generator system to be added to <code>*this</code>. The generators in <code>gs</code> may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>gs</code> are topology-incompatible or dimension-incompatible, or if <code>*this</code> is empty and the system of generators <code>gs</code> is not empty, but has no points.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>gs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="be643d7919aa34a2c1112702878f5536"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_generators_and_minimize" ref="be643d7919aa34a2c1112702878f5536" args="(const Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::add_generators_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of the generators in <code>gs</code> to the system of generators of <code>*this</code>, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>Contains the generators that will be added to the system of generators of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>gs</code> are topology-incompatible or dimension-incompatible, or if <code>*this</code> is empty and the the system of generators <code>gs</code> is not empty, but has no points.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a8abcefdfb125b7c9ef5f96d352c1df"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_recycled_generators_and_minimize" ref="7a8abcefdfb125b7c9ef5f96d352c1df" args="(Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::add_recycled_generators_and_minimize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the generators in <code>gs</code> to the system of generators of <code>*this</code>, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The generator system to be added to <code>*this</code>. The generators in <code>gs</code> may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>gs</code> are topology-incompatible or dimension-incompatible, or if <code>*this</code> is empty and the the system of generators <code>gs</code> is not empty, but has no points.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>gs</code> upon successful or exceptional return is that it can be safely destroyed.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="96e902093a55f87f0aebc2bb13a8d740"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_congruences" ref="96e902093a55f87f0aebc2bb13a8d740" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_congruences           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of the congruences in <code>cgs</code> to <code>*this</code>, if all the congruences can be exactly represented by a polyhedron. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruences to be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, of if there exists in <code>cgs</code> a proper congruence which is neither a tautology, nor a contradiction. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7e4bbfa6f481ead40e3ca6231e0f69be"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_congruences_and_minimize" ref="7e4bbfa6f481ead40e3ca6231e0f69be" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::add_congruences_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of the congruences in <code>cgs</code> to <code>*this</code>, if all the congruences can be exactly represented by a polyhedron, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruences to be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, of if there exists in <code>cgs</code> a proper congruence which is neither a tautology, nor a contradiction</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3569a428ad758dc9ac8273e0f1f77772"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_recycled_congruences" ref="3569a428ad758dc9ac8273e0f1f77772" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_recycled_congruences           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the congruences in <code>cgs</code> to <code>*this</code>, if all the congruences can be exactly represented by a polyhedron. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruences to be added. Its elements may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, of if there exists in <code>cgs</code> a proper congruence which is neither a tautology, nor a contradiction</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2aaf9117efebc52a8b45b787075a9647"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_recycled_congruences_and_minimize" ref="2aaf9117efebc52a8b45b787075a9647" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::add_recycled_congruences_and_minimize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the congruences in <code>cgs</code> to <code>*this</code>, if all the congruences can be exactly represented by a polyhedron, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruences to be added. Its elements may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, of if there exists in <code>cgs</code> a proper congruence which is neither a tautology, nor a contradiction</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d6a8cc7029bad7ad7ad116c90ff59aec"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::refine_with_constraint" ref="d6a8cc7029bad7ad7ad116c90ff59aec" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::refine_with_constraint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of constraint <code>c</code> to refine <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="236a18fe8cc922d00ee92a6c6e42f923"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::refine_with_congruence" ref="236a18fe8cc922d00ee92a6c6e42f923" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::refine_with_congruence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of congruence <code>cg</code> to refine <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bfd98397c137d81dcc27111fba3ccd54"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::refine_with_constraints" ref="bfd98397c137d81dcc27111fba3ccd54" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::refine_with_constraints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of the constraints in <code>cs</code> to refine <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>Contains the constraints used to refine the system of constraints of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a26e1a5815b7a0c3b610395c854594bf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::refine_with_congruences" ref="a26e1a5815b7a0c3b610395c854594bf" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::refine_with_congruences           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of the congruences in <code>cgs</code> to refine <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>Contains the congruences used to refine the system of constraints of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3c1e5a2419a5f4a5cf89133606ed1680"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::unconstrain" ref="3c1e5a2419a5f4a5cf89133606ed1680" args="(Variable var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::unconstrain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The space dimension that will be unconstrained.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9ca6b6eed07fd3b72119b8ea58328e5e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::unconstrain" ref="9ca6b6eed07fd3b72119b8ea58328e5e" args="(const Variables_Set &amp;to_be_unconstrained)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::unconstrain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_unconstrained</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>to_be_unconstrained</code>, assigning the result to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_unconstrained</em>&nbsp;</td><td>The set of space dimension that will be unconstrained.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_removed</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8132d1a9b329271fb4f7faeb59c89c39"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::intersection_assign" ref="8132d1a9b329271fb4f7faeb59c89c39" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::intersection_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>. The result is not guaranteed to be minimized. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1956a63a72283d208851d3fe2b11989b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::intersection_assign_and_minimize" ref="1956a63a72283d208851d3fe2b11989b" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::intersection_assign_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4b428098e57a9101473a54cd71a0753f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::poly_hull_assign" ref="4b428098e57a9101473a54cd71a0753f" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::poly_hull_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the poly-hull of <code>*this</code> and <code>y</code>. The result is not guaranteed to be minimized. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="97011210c7f0b2efa0f837ef2da6c5b3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::poly_hull_assign_and_minimize" ref="97011210c7f0b2efa0f837ef2da6c5b3" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::poly_hull_assign_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the poly-hull of <code>*this</code> and <code>y</code>, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="672b0568e7a27c37b3afde649f7c0171"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::poly_difference_assign" ref="672b0568e7a27c37b3afde649f7c0171" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::poly_difference_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Convex_Polyhedral_Difference">poly-difference</a> of <code>*this</code> and <code>y</code>. The result is not guaranteed to be minimized. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a809bff4b85d09cd801e5e5cde1b8c06"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::simplify_using_context_assign" ref="a809bff4b85d09cd801e5e5cde1b8c06" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::simplify_using_context_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c93800b9ec7aae75937598e1f2209b1f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::affine_image" ref="c93800b9ec7aae75937598e1f2209b1f" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is assigned;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f47944944e16e786df5c0671e7baa995"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::affine_preimage" ref="f47944944e16e786df5c0671e7baa995" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is substituted;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4f514edad990412bd66cc666347103ab"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::generalized_affine_image" ref="4f514edad990412bd66cc666347103ab" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::generalized_affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="08e91d11b3deb5b694356b5573d2547a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::generalized_affine_preimage" ref="08e91d11b3deb5b694356b5573d2547a" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::generalized_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="50e1047c49fffb06bc5089a06a051a3d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::generalized_affine_image" ref="50e1047c49fffb06bc5089a06a051a3d" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::generalized_affine_image           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cbc86683af6afc0818cc9e980a84fcb8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::generalized_affine_preimage" ref="cbc86683af6afc0818cc9e980a84fcb8" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::generalized_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e89cd985111a1a27c60a6fcc28ae9788"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::bounded_affine_image" ref="e89cd985111a1a27c60a6fcc28ae9788" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::bounded_affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="371deb67f73bf27ac9a7ff6f2216db9c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::bounded_affine_preimage" ref="371deb67f73bf27ac9a7ff6f2216db9c" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::bounded_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="98c785602c5af8f7e0c1be92bb5e8b71"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::time_elapse_assign" ref="98c785602c5af8f7e0c1be92bb5e8b71" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::time_elapse_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7366f9b91109b63f078e963bccd9f5b4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::BHRZ03_widening_assign" ref="7366f9b91109b63f078e963bccd9f5b4" args="(const Polyhedron &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::BHRZ03_widening_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#BHRZ03_widening">BHRZ03-widening</a> between <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A polyhedron that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="281b8db6a8e0014ab2c41dd15f8c0708"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::limited_BHRZ03_extrapolation_assign" ref="281b8db6a8e0014ab2c41dd15f8c0708" args="(const Polyhedron &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::limited_BHRZ03_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#limited_extrapolation">limited extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#BHRZ03_widening">BHRZ03-widening</a> operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A polyhedron that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1a3647877302fc6e0e583b8b881a7a4f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::bounded_BHRZ03_extrapolation_assign" ref="1a3647877302fc6e0e583b8b881a7a4f" args="(const Polyhedron &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::bounded_BHRZ03_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#bounded_extrapolation">bounded extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#BHRZ03_widening">BHRZ03-widening</a> operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A polyhedron that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f074d4d4d406dd065812b32cc8714222"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::H79_widening_assign" ref="f074d4d4d406dd065812b32cc8714222" args="(const Polyhedron &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::H79_widening_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#H79_widening">H79_widening</a> between <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A polyhedron that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cf531d280805472a54c22fed0f689932"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::limited_H79_extrapolation_assign" ref="cf531d280805472a54c22fed0f689932" args="(const Polyhedron &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::limited_H79_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#limited_extrapolation">limited extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#H79_widening">H79-widening</a> operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A polyhedron that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9764ef2f159cfdcca3f151e899bd43ef"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::bounded_H79_extrapolation_assign" ref="9764ef2f159cfdcca3f151e899bd43ef" args="(const Polyhedron &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::bounded_H79_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#bounded_extrapolation">bounded extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#H79_widening">H79-widening</a> operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A polyhedron that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="527e7c81841bbcf1963c6e260dadfe01"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_space_dimensions_and_embed" ref="527e7c81841bbcf1963c6e260dadfe01" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_space_dimensions_and_embed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <code>m</code> new space dimensions and embeds the old polyhedron in the new vector space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of dimensions to add.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#73cb0d61cccb259e06b68d4f83deb6d7" title="Returns the maximum space dimension all kinds of Polyhedron can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
</dl>
The new space dimensions will be those having the highest indexes in the new polyhedron, which is characterized by a system of constraints in which the variables running through the new dimensions are not constrained. For instance, when starting from the polyhedron <img class="formulaInl" alt="$\cP \sseq \Rset^2$" src="form_151.png"> and adding a third space dimension, the result will be the polyhedron <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, z)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cP \,\bigr\}. \]" src="form_644.png">
<p>
 
</div>
</div><p>
<a class="anchor" name="a6b6fed08414c86d33fc4a44c59e9e22"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_space_dimensions_and_project" ref="a6b6fed08414c86d33fc4a44c59e9e22" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_space_dimensions_and_project           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <code>m</code> new space dimensions to the polyhedron and does not embed it in the new vector space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of space dimensions to add.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#73cb0d61cccb259e06b68d4f83deb6d7" title="Returns the maximum space dimension all kinds of Polyhedron can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
</dl>
The new space dimensions will be those having the highest indexes in the new polyhedron, which is characterized by a system of constraints in which the variables running through the new dimensions are all constrained to be equal to 0. For instance, when starting from the polyhedron <img class="formulaInl" alt="$\cP \sseq \Rset^2$" src="form_151.png"> and adding a third space dimension, the result will be the polyhedron <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, 0)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cP \,\bigr\}. \]" src="form_645.png">
<p>
 
</div>
</div><p>
<a class="anchor" name="87ebe6f7cd176227f61c6d0fe47a4f68"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::concatenate_assign" ref="87ebe6f7cd176227f61c6d0fe47a4f68" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::concatenate_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the concatenation would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#73cb0d61cccb259e06b68d4f83deb6d7" title="Returns the maximum space dimension all kinds of Polyhedron can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4c11206af59b0f6a5471aded55d20961"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::remove_space_dimensions" ref="4c11206af59b0f6a5471aded55d20961" args="(const Variables_Set &amp;to_be_removed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::remove_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_removed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all the specified dimensions from the vector space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_removed</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be removed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_removed</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dee3b5c0c3800ce2214e68a156cbcf77"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::remove_higher_space_dimensions" ref="dee3b5c0c3800ce2214e68a156cbcf77" args="(dimension_type new_dimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::remove_higher_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>new_dimension</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the higher dimensions of the vector space so that the resulting space will have dimension <code>new_dimension</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>new_dimensions</code> is greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="787615432c9f1d6aac5a6394aea8cfa9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::map_space_dimensions" ref="787615432c9f1d6aac5a6394aea8cfa9" args="(const Partial_Function &amp;pfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Partial_Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::map_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const Partial_Function &amp;&nbsp;</td>
          <td class="paramname"> <em>pfunc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfunc</em>&nbsp;</td><td>The partial function specifying the destiny of each space dimension.</td></tr>
  </table>
</dl>
The template class Partial_Function must provide the following methods. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> has_empty_codomain() const
</pre></div> returns <code>true</code> if and only if the represented partial function has an empty codomain (i.e., it is always undefined). The <code>has_empty_codomain()</code> method will always be called before the methods below. However, if <code>has_empty_codomain()</code> returns <code>true</code>, none of the functions below will be called. <div class="fragment"><pre class="fragment">      <a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> max_in_codomain() const
</pre></div> returns the maximum value that belongs to the codomain of the partial function. The <code>max_in_codomain()</code> method is called at most once. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> maps(<a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i, <a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a>&amp; j) <span class="keyword">const</span>
</pre></div> Let <img class="formulaInl" alt="$f$" src="form_323.png"> be the represented function and <img class="formulaInl" alt="$k$" src="form_286.png"> be the value of <code>i</code>. If <img class="formulaInl" alt="$f$" src="form_323.png"> is defined in <img class="formulaInl" alt="$k$" src="form_286.png">, then <img class="formulaInl" alt="$f(k)$" src="form_646.png"> is assigned to <code>j</code> and <code>true</code> is returned. If <img class="formulaInl" alt="$f$" src="form_323.png"> is undefined in <img class="formulaInl" alt="$k$" src="form_286.png">, then <code>false</code> is returned. This method is called at most <img class="formulaInl" alt="$n$" src="form_0.png"> times, where <img class="formulaInl" alt="$n$" src="form_0.png"> is the dimension of the vector space enclosing the polyhedron.<p>
The result is undefined if <code>pfunc</code> does not encode a partial function with the properties described in the <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">specification of the mapping operator</a>. 
</div>
</div><p>
<a class="anchor" name="6b737abc8f33b2a2362e3f9c9ab08d58"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::expand_space_dimension" ref="6b737abc8f33b2a2362e3f9c9ab08d58" args="(Variable var, dimension_type m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::expand_space_dimension           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension to be replicated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of replicas to be created.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> does not correspond to a dimension of the vector space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#73cb0d61cccb259e06b68d4f83deb6d7" title="Returns the maximum space dimension all kinds of Polyhedron can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
</dl>
If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png">, with <img class="formulaInl" alt="$n > 0$" src="form_167.png">, and <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_135.png">, then the <img class="formulaInl" alt="$k$" src="form_286.png">-th space dimension is <a class="el" href="main.html#expand_space_dimension">expanded</a> to <code>m</code> new space dimensions <img class="formulaInl" alt="$n$" src="form_0.png">, <img class="formulaInl" alt="$n+1$" src="form_168.png">, <img class="formulaInl" alt="$\dots$" src="form_647.png">, <img class="formulaInl" alt="$n+m-1$" src="form_170.png">. 
</div>
</div><p>
<a class="anchor" name="dd7b66394e6c54bc1ae03a4ed9a33c9e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::fold_space_dimensions" ref="dd7b66394e6c54bc1ae03a4ed9a33c9e" args="(const Variables_Set &amp;to_be_folded, Variable var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::fold_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_folded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Folds the space dimensions in <code>to_be_folded</code> into <code>var</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_folded</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be folded;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension that is the destination of the folding operation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>var</code> or with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_folded</code>. Also thrown if <code>var</code> is contained in <code>to_be_folded</code>.</td></tr>
  </table>
</dl>
If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png">, with <img class="formulaInl" alt="$n > 0$" src="form_167.png">, <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_135.png">, <code>to_be_folded</code> is a set of variables whose maximum space dimension is also less than or equal to <img class="formulaInl" alt="$n$" src="form_0.png">, and <code>var</code> is not a member of <code>to_be_folded</code>, then the space dimensions corresponding to variables in <code>to_be_folded</code> are <a class="el" href="main.html#fold_space_dimensions">folded</a> into the <img class="formulaInl" alt="$k$" src="form_286.png">-th space dimension. 
</div>
</div><p>
<a class="anchor" name="ca90e7afe251a0d4174dcf538b34006b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::swap" ref="ca90e7afe251a0d4174dcf538b34006b" args="(Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps <code>*this</code> with polyhedron <code>y</code>. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>x</code> and <code>y</code> are topology-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="86d2bbceaa288f2f605ac88516d313cb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::hash_code" ref="86d2bbceaa288f2f605ac88516d313cb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Parma_Polyhedra_Library::Polyhedron::hash_code           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a 32-bit hash code for <code>*this</code>. 
<p>
If <code>x</code> and <code>y</code> are such that <code>x == y</code>, then <code>x.hash_code() == y.hash_code()</code>. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="d84befb6d0ded481871cbef1b7306824"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::operator&lt;&lt;" ref="d84befb6d0ded481871cbef1b7306824" args="(std::ostream &amp;s, const Polyhedron &amp;ph)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ph</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output operator. 
<p>
Writes a textual representation of <code>ph</code> on <code>s:</code> <code>false</code> is written if <code>ph</code> is an empty polyhedron; <code>true</code> is written if <code>ph</code> is a universe polyhedron; a minimized system of constraints defining <code>ph</code> is written otherwise, all constraints in one row separated by ", ". 
</div>
</div><p>
<a class="anchor" name="8af124edba7c75bc76ec394405aa893e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::operator!=" ref="8af124edba7c75bc76ec394405aa893e" args="(const Polyhedron &amp;x, const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different polyhedra. 
<p>
Note that <code>x</code> and <code>y</code> may be topology- and/or dimension-incompatible polyhedra: in those cases, the value <code>true</code> is returned.
</div>
</div><p>
<a class="anchor" name="67a7d08f3cda46f7a743d46f3a6f33b5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::swap" ref="67a7d08f3cda46f7a743d46f3a6f33b5" args="(Parma_Polyhedra_Library::Polyhedron &amp;x, Parma_Polyhedra_Library::Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Parma_Polyhedra_Library::Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Parma_Polyhedra_Library::Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specializes <code>std::swap</code>. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 18 07:13:19 2009 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
