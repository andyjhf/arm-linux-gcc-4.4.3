<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PPL: Parma_Polyhedra_Library::Powerset&lt; D &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::Powerset&lt; D &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::Powerset" -->The powerset construction on a base-level domain.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ppl.hh&gt;</code>
<p>

<p>
<a href="classParma__Polyhedra__Library_1_1Powerset-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef iterator_to_const<br class="typebreak">
&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#d25e2d27e5d731e6b63fb84a65700faf">Sequence</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alias for a <em>read-only</em> bidirectional iterator on the disjuncts of a <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html" title="The powerset construction on a base-level domain.">Powerset</a> element.  <a href="#ab7519865a52fbbc8dc2031135a9fb41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dab8b3f43dd9a5e707b95e15a9c282f8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::const_iterator" ref="dab8b3f43dd9a5e707b95e15a9c282f8" args="" -->
typedef <br class="typebreak">
const_iterator_to_const<br class="typebreak">
&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#d25e2d27e5d731e6b63fb84a65700faf">Sequence</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#dab8b3f43dd9a5e707b95e15a9c282f8">const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A bidirectional const_iterator on the disjuncts of a <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html" title="The powerset construction on a base-level domain.">Powerset</a> element. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36becc8c3ace976043199807351d5b04"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::reverse_iterator" ref="36becc8c3ace976043199807351d5b04" args="" -->
typedef std::reverse_iterator<br class="typebreak">
&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#36becc8c3ace976043199807351d5b04">reverse_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The reverse iterator type built from <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41" title="Alias for a read-only bidirectional iterator on the disjuncts of a Powerset element...">Powerset::iterator</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f4469416e02c586de17284317f8a92e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::const_reverse_iterator" ref="6f4469416e02c586de17284317f8a92e" args="" -->
typedef std::reverse_iterator<br class="typebreak">
&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#dab8b3f43dd9a5e707b95e15a9c282f8">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#6f4469416e02c586de17284317f8a92e">const_reverse_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The reverse iterator type built from <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#dab8b3f43dd9a5e707b95e15a9c282f8" title="A bidirectional const_iterator on the disjuncts of a Powerset element.">Powerset::const_iterator</a>. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructor</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="900663a0e97525c064ccf31152fa8ae7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::Powerset" ref="900663a0e97525c064ccf31152fa8ae7" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#900663a0e97525c064ccf31152fa8ae7">Powerset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor: builds the bottom of the powerset constraint system (i.e., the empty powerset). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1c71c9b7d1de1b77eeb054e1c0ac935e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::Powerset" ref="1c71c9b7d1de1b77eeb054e1c0ac935e" args="(const Powerset &amp;y)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#1c71c9b7d1de1b77eeb054e1c0ac935e">Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f60bb41867a12ce28144596e3cc1406a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::Powerset" ref="f60bb41867a12ce28144596e3cc1406a" args="(const D &amp;d)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#f60bb41867a12ce28144596e3cc1406a">Powerset</a> (const D &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <code>d</code> is not bottom, builds a powerset containing only <code>d</code>. Builds the empty powerset otherwise. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c3283cf8fd0dd8ff2a319cba1dead1f2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::~Powerset" ref="c3283cf8fd0dd8ff2a319cba1dead1f2" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#c3283cf8fd0dd8ff2a319cba1dead1f2">~Powerset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the Powerset Object</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="411d42e5b59a492742793834efeeabc1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::definitely_entails" ref="411d42e5b59a492742793834efeeabc1" args="(const Powerset &amp;y) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#411d42e5b59a492742793834efeeabc1">definitely_entails</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if <code>*this</code> definitely entails <code>y</code>. Returns <code>false</code> if <code>*this</code> may not entail <code>y</code> (i.e., if <code>*this</code> does not entail <code>y</code> or if entailment could not be decided). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="66e3e2f2433738665eb748d2f6c5878f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::is_top" ref="66e3e2f2433738665eb748d2f6c5878f" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#66e3e2f2433738665eb748d2f6c5878f">is_top</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is the top element of the powerset constraint system (i.e., it represents the universe). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e006881831b298f0af5031e99df2bc6f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::is_bottom" ref="e006881831b298f0af5031e99df2bc6f" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#e006881831b298f0af5031e99df2bc6f">is_bottom</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is the bottom element of the powerset constraint system (i.e., it represents the empty set). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5a36a32ab46d46f574f3091e931e2bd2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::total_memory_in_bytes" ref="5a36a32ab46d46f574f3091e931e2bd2" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#5a36a32ab46d46f574f3091e931e2bd2">total_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a lower bound to the total size in bytes of the memory occupied by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cdc1e9b5ac338be9d0584d50d275226e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::external_memory_in_bytes" ref="cdc1e9b5ac338be9d0584d50d275226e" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#cdc1e9b5ac338be9d0584d50d275226e">external_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a lower bound to the size in bytes of the memory managed by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8c82df1de8703aefeab268dc9ffc557f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::OK" ref="8c82df1de8703aefeab268dc9ffc557f" args="(bool disallow_bottom=false) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#8c82df1de8703aefeab268dc9ffc557f">OK</a> (bool disallow_bottom=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions for the Direct Manipulation of Disjuncts</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#7607ef1c8ef6b668dd2be62c39330406">omega_reduce</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drops from the sequence of disjuncts in <code>*this</code> all the non-maximal elements so that <code>*this</code> is non-redundant.  <a href="#7607ef1c8ef6b668dd2be62c39330406"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="277ba920e188477bb301196b19d63770"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::size" ref="277ba920e188477bb301196b19d63770" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#277ba920e188477bb301196b19d63770">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of disjuncts. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="754f66ed06474d4b68a93131af02a86f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::empty" ref="754f66ed06474d4b68a93131af02a86f" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#754f66ed06474d4b68a93131af02a86f">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if there are no disjuncts in <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dab2c45cbec19ad11bf34db42b794508"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::begin" ref="dab2c45cbec19ad11bf34db42b794508" args="()" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#dab2c45cbec19ad11bf34db42b794508">begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator pointing to the first disjunct, if <code>*this</code> is not empty; otherwise, returns the past-the-end iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a215867508a89858bcc7ab025f8d20f1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::end" ref="a215867508a89858bcc7ab025f8d20f1" args="()" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a215867508a89858bcc7ab025f8d20f1">end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the past-the-end iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="272424f5d0df282c6d1ee63a5c84e3e6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::begin" ref="272424f5d0df282c6d1ee63a5c84e3e6" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#dab8b3f43dd9a5e707b95e15a9c282f8">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#272424f5d0df282c6d1ee63a5c84e3e6">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const_iterator pointing to the first disjunct, if <code>*this</code> is not empty; otherwise, returns the past-the-end const_iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="04aed5c92cf15c71ce85b8cc173a893b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::end" ref="04aed5c92cf15c71ce85b8cc173a893b" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#dab8b3f43dd9a5e707b95e15a9c282f8">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#04aed5c92cf15c71ce85b8cc173a893b">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the past-the-end const_iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b66151b86ac8c495eba1a3209501928a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::rbegin" ref="b66151b86ac8c495eba1a3209501928a" args="()" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#36becc8c3ace976043199807351d5b04">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#b66151b86ac8c495eba1a3209501928a">rbegin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reverse_iterator pointing to the last disjunct, if <code>*this</code> is not empty; otherwise, returns the before-the-start reverse_iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="241c65ff3d32769cbb9badd2c8e00ca5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::rend" ref="241c65ff3d32769cbb9badd2c8e00ca5" args="()" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#36becc8c3ace976043199807351d5b04">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#241c65ff3d32769cbb9badd2c8e00ca5">rend</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the before-the-start reverse_iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9fb86f09111d4ac21fdc7c7baa86e622"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::rbegin" ref="9fb86f09111d4ac21fdc7c7baa86e622" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#6f4469416e02c586de17284317f8a92e">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#9fb86f09111d4ac21fdc7c7baa86e622">rbegin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const_reverse_iterator pointing to the last disjunct, if <code>*this</code> is not empty; otherwise, returns the before-the-start const_reverse_iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5eb3117d3d7d0566a99f9f5807276864"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::rend" ref="5eb3117d3d7d0566a99f9f5807276864" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#6f4469416e02c586de17284317f8a92e">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#5eb3117d3d7d0566a99f9f5807276864">rend</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the before-the-start const_reverse_iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="44b0a622563e60fe28b91b7e9ff76364"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::add_disjunct" ref="44b0a622563e60fe28b91b7e9ff76364" args="(const D &amp;d)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#44b0a622563e60fe28b91b7e9ff76364">add_disjunct</a> (const D &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> the disjunct <code>d</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="386fa9c84bc37468f1a3a2b860a0bc3d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::drop_disjunct" ref="386fa9c84bc37468f1a3a2b860a0bc3d" args="(iterator position)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#386fa9c84bc37468f1a3a2b860a0bc3d">drop_disjunct</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a> position)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drops the disjunct in <code>*this</code> pointed to by <code>position</code>, returning an iterator to the disjunct following <code>position</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="37703f96495cf4bcb8ced3ff20e4c396"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::drop_disjuncts" ref="37703f96495cf4bcb8ced3ff20e4c396" args="(iterator first, iterator last)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#37703f96495cf4bcb8ced3ff20e4c396">drop_disjuncts</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a> first, <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a> last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drops all the disjuncts from <code>first</code> to <code>last</code> (excluded). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2edf5fe7007a3e91a404546ca2f2d98c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::clear" ref="2edf5fe7007a3e91a404546ca2f2d98c" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#2edf5fe7007a3e91a404546ca2f2d98c">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drops all the disjuncts, making <code>*this</code> an empty powerset. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Powerset Object</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b955487a974e74224f3d72d743ee78a4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::operator=" ref="b955487a974e74224f3d72d743ee78a4" args="(const Powerset &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#b955487a974e74224f3d72d743ee78a4">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The assignment operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fe22acf3f8e5b6c20880acd443350482"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::swap" ref="fe22acf3f8e5b6c20880acd443350482" args="(Powerset &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#fe22acf3f8e5b6c20880acd443350482">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps <code>*this</code> with <code>y</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="113964ab3d7ea36326ce962629a322ce"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::least_upper_bound_assign" ref="113964ab3d7ea36326ce962629a322ce" args="(const Powerset &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#113964ab3d7ea36326ce962629a322ce">least_upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the least upper bound of <code>*this</code> and <code>y</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#def4c62b5cdf5186801c592cc62dccea">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> an upper bound of <code>*this</code> and <code>y</code>.  <a href="#def4c62b5cdf5186801c592cc62dccea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#01b873b0e820222e07789c3ba5fa48ae">upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the least upper bound of <code>*this</code> and <code>y</code> and returns <code>true</code>.  <a href="#01b873b0e820222e07789c3ba5fa48ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d3bda090e4ac93d937ac4dd775c20919"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::meet_assign" ref="d3bda090e4ac93d937ac4dd775c20919" args="(const Powerset &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#d3bda090e4ac93d937ac4dd775c20919">meet_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the meet of <code>*this</code> and <code>y</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1ee74f5687635ddbb9729be31a37e2d3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::collapse" ref="1ee74f5687635ddbb9729be31a37e2d3" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#1ee74f5687635ddbb9729be31a37e2d3">collapse</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <code>*this</code> is not empty (i.e., it is not the bottom element), it is reduced to a singleton obtained by computing an upper-bound of all the disjuncts. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::list&lt; D &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#d25e2d27e5d731e6b63fb84a65700faf">Sequence</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A powerset is implemented as a sequence of elements.  <a href="#d25e2d27e5d731e6b63fb84a65700faf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5534b8f8fbd973bfb7051cf5fb31f19d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::Sequence_iterator" ref="5534b8f8fbd973bfb7051cf5fb31f19d" args="" -->
typedef Sequence::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#5534b8f8fbd973bfb7051cf5fb31f19d">Sequence_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alias for the low-level iterator on the disjuncts. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5c3bee913efb87e4661df746e184e1e1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::Sequence_const_iterator" ref="5c3bee913efb87e4661df746e184e1e1" args="" -->
typedef Sequence::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#5c3bee913efb87e4661df746e184e1e1">Sequence_const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alias for the low-level const_iterator on the disjuncts. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="30e0b0c2c668e73566cb1720d72cdac2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::is_omega_reduced" ref="30e0b0c2c668e73566cb1720d72cdac2" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#30e0b0c2c668e73566cb1720d72cdac2">is_omega_reduced</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> does not contain non-maximal elements. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ee126cc2eef44ab1d2055d0d15bc3169"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::collapse" ref="ee126cc2eef44ab1d2055d0d15bc3169" args="(unsigned max_disjuncts)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ee126cc2eef44ab1d2055d0d15bc3169">collapse</a> (unsigned max_disjuncts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Upon return, <code>*this</code> will contain at most <code>max_disjuncts</code> elements; the set of disjuncts in positions greater than or equal to <code>max_disjuncts</code>, will be replaced at that position by their upper-bound. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#0a660ed1cfae2599d7f9236f2084d499">add_non_bottom_disjunct_preserve_reduction</a> (const D &amp;d, <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a> first, <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a> last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> the disjunct <code>d</code>, assuming <code>d</code> is not the bottom element and ensuring partial Omega-reduction.  <a href="#0a660ed1cfae2599d7f9236f2084d499"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#86f44d9d38638be46ef23422783f847e">add_non_bottom_disjunct_preserve_reduction</a> (const D &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> the disjunct <code>d</code>, assuming <code>d</code> is not the bottom element and preserving Omega-reduction.  <a href="#86f44d9d38638be46ef23422783f847e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Binary_Operator_Assign &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ba65a2c1a6d563f5058479bc07181b9a">pairwise_apply_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y, Binary_Operator_Assign op_assign)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of applying <code>op_assign</code> pairwise to the elements in <code>*this</code> and <code>y</code>.  <a href="#ba65a2c1a6d563f5058479bc07181b9a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d2c2fc2c077e77db657af49d332c9b5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::sequence" ref="5d2c2fc2c077e77db657af49d332c9b5" args="" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#d25e2d27e5d731e6b63fb84a65700faf">Sequence</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#5d2c2fc2c077e77db657af49d332c9b5">sequence</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The sequence container holding powerset's elements. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d34bafd07f582c558936f9ea8892abd6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::reduced" ref="d34bafd07f582c558936f9ea8892abd6" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#d34bafd07f582c558936f9ea8892abd6">reduced</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <code>true</code>, <code>*this</code> is Omega-reduced. <br></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#057c4f38d0e8b8a146af731dbd91864f">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are equivalent.  <a href="#057c4f38d0e8b8a146af731dbd91864f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#2a7c225e4f50e2287216dcd77eaf27d5">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are not equivalent.  <a href="#2a7c225e4f50e2287216dcd77eaf27d5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#8691a3facce4d6f973b48743fa42ec42">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#8691a3facce4d6f973b48743fa42ec42"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a55b32c299b7d7bec303f636b66ef624">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt; &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#a55b32c299b7d7bec303f636b66ef624"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename D&gt;<br>
 class Parma_Polyhedra_Library::Powerset&lt; D &gt;</h3>

The powerset construction on a base-level domain. 
<p>
This class offers a generic implementation of a <em>powerset</em> domain as defined in Section <a class="el" href="main.html#powerset">The Powerset Construction</a>.<p>
Besides invoking the available methods on the disjuncts of a <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html" title="The powerset construction on a base-level domain.">Powerset</a>, this class also provides bidirectional iterators that allow for a direct inspection of these disjuncts. For a consistent handling of Omega-reduction, all the iterators are <em>read-only</em>, meaning that the disjuncts cannot be overwritten. Rather, by using the class <code>iterator</code>, it is possible to drop one or more disjuncts (possibly so as to later add back modified versions). As an example of iterator usage, the following template function drops from powerset <code>ps</code> all the disjuncts that would have become redundant by the addition of an external element <code>d</code>.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;
<span class="keywordtype">void</span>
drop_subsumed(Powerset&lt;D&gt;&amp; ps, <span class="keyword">const</span> D&amp; d) {
  <span class="keywordflow">for</span> (<span class="keyword">typename</span> Powerset&lt;D&gt;::iterator i = ps.begin(),
         ps_end = ps.end(), i != ps_end; )
    <span class="keywordflow">if</span> (i-&gt;definitely_entails(d))
      i = ps.drop_disjunct(i);
    <span class="keywordflow">else</span>
      ++i;
}
</pre></div><p>
The template class D must provide the following methods. <div class="fragment"><pre class="fragment">    <a class="code" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783" title="An unsigned integral type for representing memory size in bytes.">memory_size_type</a> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#5a36a32ab46d46f574f3091e931e2bd2" title="Returns a lower bound to the total size in bytes of the memory occupied by *this...">total_memory_in_bytes</a>() const
</pre></div> Returns a lower bound on the total size in bytes of the memory occupied by the instance of D. <div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#66e3e2f2433738665eb748d2f6c5878f" title="Returns true if and only if *this is the top element of the powerset constraint system...">is_top</a>() const
</pre></div> Returns <code>true</code> if and only if the instance of D is the top element of the domain. <div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#e006881831b298f0af5031e99df2bc6f" title="Returns true if and only if *this is the bottom element of the powerset constraint...">is_bottom</a>() const
</pre></div> Returns <code>true</code> if and only if the instance of D is the bottom element of the domain. <div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#411d42e5b59a492742793834efeeabc1" title="Returns true if *this definitely entails y. Returns false if *this may not entail...">definitely_entails</a>(<span class="keyword">const</span> D&amp; y) <span class="keyword">const</span>
</pre></div> Returns <code>true</code> if the instance of D definitely entails <code>y</code>. Returns <code>false</code> if the instance may not entail <code>y</code> (i.e., if the instance does not entail <code>y</code> or if entailment could not be decided). <div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#def4c62b5cdf5186801c592cc62dccea" title="Assigns to *this an upper bound of *this and y.">upper_bound_assign</a>(<span class="keyword">const</span> D&amp; y)
</pre></div> Assigns to the instance of D an upper bound of the instance and <code>y</code>. <div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#d3bda090e4ac93d937ac4dd775c20919" title="Assigns to *this the meet of *this and y.">meet_assign</a>(<span class="keyword">const</span> D&amp; y)
</pre></div> Assigns to the instance of D the meet of the instance and <code>y</code>. <div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#8c82df1de8703aefeab268dc9ffc557f" title="Checks if all the invariants are satisfied.">OK</a>() const
</pre></div> Returns <code>true</code> if the instance of D is in a consistent state, else returns <code>false</code>.<p>
The following operators on the template class D must be defined. <div class="fragment"><pre class="fragment">    <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#8691a3facce4d6f973b48743fa42ec42" title="Output operator.">operator&lt;&lt;</a>(std::ostream&amp; s, <span class="keyword">const</span> D&amp; x)
</pre></div> Writes a textual representation of the instance of D on <code>s</code>. <div class="fragment"><pre class="fragment">    <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#057c4f38d0e8b8a146af731dbd91864f" title="Returns true if and only if x and y are equivalent.">operator==</a>(<span class="keyword">const</span> D&amp; x, <span class="keyword">const</span> D&amp; y)
</pre></div> Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are equivalent D's. <div class="fragment"><pre class="fragment">    <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#2a7c225e4f50e2287216dcd77eaf27d5" title="Returns true if and only if x and y are not equivalent.">operator!=</a>(<span class="keyword">const</span> D&amp; x, <span class="keyword">const</span> D&amp; y)
</pre></div> Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different D's. <hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="d25e2d27e5d731e6b63fb84a65700faf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::Sequence" ref="d25e2d27e5d731e6b63fb84a65700faf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;D&gt; <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#d25e2d27e5d731e6b63fb84a65700faf">Sequence</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A powerset is implemented as a sequence of elements. 
<p>
The particular sequence employed must support efficient deletion in any position and efficient back insertion. 
</div>
</div><p>
<a class="anchor" name="ab7519865a52fbbc8dc2031135a9fb41"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::iterator" ref="ab7519865a52fbbc8dc2031135a9fb41" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator_to_const&lt;<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#d25e2d27e5d731e6b63fb84a65700faf">Sequence</a>&gt; <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for a <em>read-only</em> bidirectional iterator on the disjuncts of a <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html" title="The powerset construction on a base-level domain.">Powerset</a> element. 
<p>
By using this iterator type, the disjuncts cannot be overwritten, but they can be removed using methods <code><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#386fa9c84bc37468f1a3a2b860a0bc3d" title="Drops the disjunct in *this pointed to by position, returning an iterator to the...">drop_disjunct(iterator position)</a></code> and <code><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#37703f96495cf4bcb8ced3ff20e4c396" title="Drops all the disjuncts from first to last (excluded).">drop_disjuncts(iterator first, iterator last)</a></code>, while still ensuring a correct handling of Omega-reduction. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7607ef1c8ef6b668dd2be62c39330406"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::omega_reduce" ref="7607ef1c8ef6b668dd2be62c39330406" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::omega_reduce           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drops from the sequence of disjuncts in <code>*this</code> all the non-maximal elements so that <code>*this</code> is non-redundant. 
<p>
This method is declared <code>const</code> because, even though Omega-reduction may change the syntactic representation of <code>*this</code>, its semantics will be unchanged. 
</div>
</div><p>
<a class="anchor" name="def4c62b5cdf5186801c592cc62dccea"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::upper_bound_assign" ref="def4c62b5cdf5186801c592cc62dccea" args="(const Powerset &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::upper_bound_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> an upper bound of <code>*this</code> and <code>y</code>. 
<p>
The result will be the least upper bound of <code>*this</code> and <code>y</code>. 
</div>
</div><p>
<a class="anchor" name="01b873b0e820222e07789c3ba5fa48ae"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::upper_bound_assign_if_exact" ref="01b873b0e820222e07789c3ba5fa48ae" args="(const Powerset &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::upper_bound_assign_if_exact           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the least upper bound of <code>*this</code> and <code>y</code> and returns <code>true</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0a660ed1cfae2599d7f9236f2084d499"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::add_non_bottom_disjunct_preserve_reduction" ref="0a660ed1cfae2599d7f9236f2084d499" args="(const D &amp;d, iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a> <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::add_non_bottom_disjunct_preserve_reduction           </td>
          <td>(</td>
          <td class="paramtype">const D &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab7519865a52fbbc8dc2031135a9fb41">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> the disjunct <code>d</code>, assuming <code>d</code> is not the bottom element and ensuring partial Omega-reduction. 
<p>
If <code>d</code> is not the bottom element and is not Omega-redundant with respect to elements in positions between <code>first</code> and <code>last</code>, all elements in these positions that would be made Omega-redundant by the addition of <code>d</code> are dropped and <code>d</code> is added to the reduced sequence. If <code>*this</code> is reduced before an invocation of this method, it will be reduced upon successful return from the method. 
</div>
</div><p>
<a class="anchor" name="86f44d9d38638be46ef23422783f847e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::add_non_bottom_disjunct_preserve_reduction" ref="86f44d9d38638be46ef23422783f847e" args="(const D &amp;d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::add_non_bottom_disjunct_preserve_reduction           </td>
          <td>(</td>
          <td class="paramtype">const D &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> the disjunct <code>d</code>, assuming <code>d</code> is not the bottom element and preserving Omega-reduction. 
<p>
If <code>*this</code> is reduced before an invocation of this method, it will be reduced upon successful return from the method. 
</div>
</div><p>
<a class="anchor" name="ba65a2c1a6d563f5058479bc07181b9a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::pairwise_apply_assign" ref="ba65a2c1a6d563f5058479bc07181b9a" args="(const Powerset &amp;y, Binary_Operator_Assign op_assign)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
<div class="memtemplate">
template&lt;typename Binary_Operator_Assign &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::pairwise_apply_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Binary_Operator_Assign&nbsp;</td>
          <td class="paramname"> <em>op_assign</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of applying <code>op_assign</code> pairwise to the elements in <code>*this</code> and <code>y</code>. 
<p>
The elements of the powerset result are obtained by applying <code>op_assign</code> to each pair of elements whose components are drawn from <code>*this</code> and <code>y</code>, respectively. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="057c4f38d0e8b8a146af731dbd91864f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::operator==" ref="057c4f38d0e8b8a146af731dbd91864f" args="(const Powerset&lt; D &gt; &amp;x, const Powerset&lt; D &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are equivalent. 
<p>

</div>
</div><p>
<a class="anchor" name="2a7c225e4f50e2287216dcd77eaf27d5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::operator!=" ref="2a7c225e4f50e2287216dcd77eaf27d5" args="(const Powerset&lt; D &gt; &amp;x, const Powerset&lt; D &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are not equivalent. 
<p>

</div>
</div><p>
<a class="anchor" name="8691a3facce4d6f973b48743fa42ec42"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::operator&lt;&lt;" ref="8691a3facce4d6f973b48743fa42ec42" args="(std::ostream &amp;s, const Powerset&lt; D &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output operator. 
<p>

</div>
</div><p>
<a class="anchor" name="a55b32c299b7d7bec303f636b66ef624"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::swap" ref="a55b32c299b7d7bec303f636b66ef624" args="(Parma_Polyhedra_Library::Powerset&lt; D &gt; &amp;x, Parma_Polyhedra_Library::Powerset&lt; D &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specializes <code>std::swap</code>. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 18 07:13:19 2009 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
