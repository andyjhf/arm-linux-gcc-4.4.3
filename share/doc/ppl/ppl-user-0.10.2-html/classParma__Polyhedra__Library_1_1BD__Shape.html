<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PPL: Parma_Polyhedra_Library::BD_Shape&lt; T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::BD_Shape&lt; T &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::BD_Shape" -->A bounded difference shape.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ppl.hh&gt;</code>
<p>

<p>
<a href="classParma__Polyhedra__Library_1_1BD__Shape-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cfed8bc19e046453778c9d99d84df283"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::coefficient_type_base" ref="cfed8bc19e046453778c9d99d84df283" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#cfed8bc19e046453778c9d99d84df283">coefficient_type_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The numeric base type upon which bounded differences are built. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="12dc6df3a06f4c97c6bb2264bbad05ac"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::coefficient_type" ref="12dc6df3a06f4c97c6bb2264bbad05ac" args="" -->
typedef <a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">N</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#12dc6df3a06f4c97c6bb2264bbad05ac">coefficient_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The (extended) numeric type of the inhomogeneous term of the inequalities defining a BDS. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="edabe8ecd0866b972e97709e17f94681"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::ascii_dump" ref="edabe8ecd0866b972e97709e17f94681" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#edabe8ecd0866b972e97709e17f94681">ascii_dump</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="82b35fc075e1e9542d4cc5cff2e236f8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::ascii_dump" ref="82b35fc075e1e9542d4cc5cff2e236f8" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#82b35fc075e1e9542d4cc5cff2e236f8">ascii_dump</a> (std::ostream &amp;s) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="93c1c491c0035f6c38b9ee036184aa7e"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::print" ref="93c1c491c0035f6c38b9ee036184aa7e" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#93c1c491c0035f6c38b9ee036184aa7e">print</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a6088f536e9340145630576cfd6e6b9"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::ascii_load" ref="1a6088f536e9340145630576cfd6e6b9" args="(std::istream &amp;s)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#1a6088f536e9340145630576cfd6e6b9">ascii_load</a> (std::istream &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#82b35fc075e1e9542d4cc5cff2e236f8" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="033967c42f02b6029fc4d6153eb8072a"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::total_memory_in_bytes" ref="033967c42f02b6029fc4d6153eb8072a" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#033967c42f02b6029fc4d6153eb8072a">total_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="25c5ef784f17646705c76a5be6c724a3"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::external_memory_in_bytes" ref="25c5ef784f17646705c76a5be6c724a3" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#25c5ef784f17646705c76a5be6c724a3">external_memory_in_bytes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#e0a1b4b4a344cad01c58e8e006a7ff16">hash_code</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a 32-bit hash code for <code>*this</code>.  <a href="#e0a1b4b4a344cad01c58e8e006a7ff16"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, Assignment, Swap and Destructor</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ab3964a5c29992e6476852c9d246fe6f">BD_Shape</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions=0, <a class="el" href="group__PPL__CXX__interface.html#g616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind=UNIVERSE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a universe or empty BDS of the specified space dimension.  <a href="#ab3964a5c29992e6476852c9d246fe6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#3825b4905d72422089bf28d3c95c2964">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy-constructor.  <a href="#3825b4905d72422089bf28d3c95c2964"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#fad498a5802a7928442fd0d4b8c6183f">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a conservative, upward approximation of <code>y</code>.  <a href="#fad498a5802a7928442fd0d4b8c6183f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#128b2fafec11e096e41f78710ba2ff0a">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a BDS from the system of constraints <code>cs</code>.  <a href="#128b2fafec11e096e41f78710ba2ff0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#15b3e8152862a6b98ecf1c4f4a142634">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a BDS from a system of congruences.  <a href="#15b3e8152862a6b98ecf1c4f4a142634"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#dbf2609849c95cfb7277df1edc69534f">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a BDS from the system of generators <code>gs</code>.  <a href="#dbf2609849c95cfb7277df1edc69534f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#faa5d6b3c1b3b83161b619c28c5f9936">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a BDS from the polyhedron <code>ph</code>.  <a href="#faa5d6b3c1b3b83161b619c28c5f9936"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a07f93a685253eb04edab43b5ebd27b2">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a BDS out of a box.  <a href="#a07f93a685253eb04edab43b5ebd27b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#25a2d683973c6c6901e47c4fe90cf2b1">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;grid, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a BDS out of a grid.  <a href="#25a2d683973c6c6901e47c4fe90cf2b1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#df78023ac662762ffc808902b970597b">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;os, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a BDS from an octagonal shape.  <a href="#df78023ac662762ffc808902b970597b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bee6d42dd6f94979bcc7fb3d51102864"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::operator=" ref="bee6d42dd6f94979bcc7fb3d51102864" args="(const BD_Shape &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#bee6d42dd6f94979bcc7fb3d51102864">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The assignment operator (<code>*this</code> and <code>y</code> can be dimension-incompatible). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9bf45a32e428970068f654258dd7fb0c"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::swap" ref="9bf45a32e428970068f654258dd7fb0c" args="(BD_Shape &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#9bf45a32e428970068f654258dd7fb0c">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps <code>*this</code> with <code>y</code> (<code>*this</code> and <code>y</code> can be dimension-incompatible). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a78a6abbbb3c425992ca644f732e69e8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::~BD_Shape" ref="a78a6abbbb3c425992ca644f732e69e8" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a78a6abbbb3c425992ca644f732e69e8">~BD_Shape</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the BD_Shape</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8101d965bc32e4ab1df6aa445730769b"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::space_dimension" ref="8101d965bc32e4ab1df6aa445730769b" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#8101d965bc32e4ab1df6aa445730769b">space_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d09a9ccc89ace499a888b6b1a1f4ce44"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::affine_dimension" ref="d09a9ccc89ace499a888b6b1a1f4ce44" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#d09a9ccc89ace499a888b6b1a1f4ce44">affine_dimension</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <img class="formulaInl" alt="$0$" src="form_562.png">, if <code>*this</code> is empty; otherwise, returns the <a class="el" href="main.html#Affine_Independence_and_Affine_Dimension">affine dimension</a> of <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e645f35cbeedf3341428988157f71ab"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::constraints" ref="1e645f35cbeedf3341428988157f71ab" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#1e645f35cbeedf3341428988157f71ab">constraints</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of constraints defining <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="24fbe68af11e373092f23f59b6cfd3e1"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::minimized_constraints" ref="24fbe68af11e373092f23f59b6cfd3e1" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#24fbe68af11e373092f23f59b6cfd3e1">minimized_constraints</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a minimized system of constraints defining <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c7f89b09f6755cdcd97daa3a92522b00"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::congruences" ref="c7f89b09f6755cdcd97daa3a92522b00" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#c7f89b09f6755cdcd97daa3a92522b00">congruences</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of (equality) congruences satisfied by <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8f0bdfca2a6993bfa08358319d589ab6"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::minimized_congruences" ref="8f0bdfca2a6993bfa08358319d589ab6" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#8f0bdfca2a6993bfa08358319d589ab6">minimized_congruences</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a minimal system of (equality) congruences satisfied by <code>*this</code> with the same affine dimension as <code>*this</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#79a586ca093d218e5603380ac0475717">bounds_from_above</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>.  <a href="#79a586ca093d218e5603380ac0475717"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#641b55dd6c26bce06bd8041b38aec873">bounds_from_below</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>.  <a href="#641b55dd6c26bce06bd8041b38aec873"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a7b3a5c12ea008b78eed88a621c1fab1">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed.  <a href="#a7b3a5c12ea008b78eed88a621c1fab1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#e61fdcc22d1e0fe43b94194f2eadaa1a">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed.  <a href="#e61fdcc22d1e0fe43b94194f2eadaa1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#33daeddebffc6eb847edd92c3ba045dc">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed.  <a href="#33daeddebffc6eb847edd92c3ba045dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#1d00782cbab77286295552af7dba7ed8">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed.  <a href="#1d00782cbab77286295552af7dba7ed8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#6a3dd351c33d66250d2b4ac639768f07">contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>.  <a href="#6a3dd351c33d66250d2b4ac639768f07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#8a87935278cb7b1290301e96cb82fcb1">strictly_contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>.  <a href="#8a87935278cb7b1290301e96cb82fcb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#5e972fbb672e9b2faec34b949c9a2918">is_disjoint_from</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint.  <a href="#5e972fbb672e9b2faec34b949c9a2918"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#75188bcee0bfc88a4c8571acc04a1826">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the constraint <code>c</code>.  <a href="#75188bcee0bfc88a4c8571acc04a1826"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#4aef1a4f6e9bed5d473e98320401e0e5">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the congruence <code>cg</code>.  <a href="#4aef1a4f6e9bed5d473e98320401e0e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#16f61fdba7e14a67990a84e93be00efb">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the generator <code>g</code>.  <a href="#16f61fdba7e14a67990a84e93be00efb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="caa538c9c00b2f69301365d916bb49e8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::is_empty" ref="caa538c9c00b2f69301365d916bb49e8" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#caa538c9c00b2f69301365d916bb49e8">is_empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an empty BDS. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="620d5cdb01b8b20848ca01f4e4c05b4f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::is_universe" ref="620d5cdb01b8b20848ca01f4e4c05b4f" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#620d5cdb01b8b20848ca01f4e4c05b4f">is_universe</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a universe BDS. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="242d9bf0b5b215d4aa771e9f8595baea"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::is_discrete" ref="242d9bf0b5b215d4aa771e9f8595baea" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#242d9bf0b5b215d4aa771e9f8595baea">is_discrete</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is discrete. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="54f33edf5fdf4c6f606136b882be9f1d"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::is_topologically_closed" ref="54f33edf5fdf4c6f606136b882be9f1d" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#54f33edf5fdf4c6f606136b882be9f1d">is_topologically_closed</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a topologically closed subset of the vector space. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8c73e2c464d5e93dc55862d00d5478f8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::is_bounded" ref="8c73e2c464d5e93dc55862d00d5478f8" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#8c73e2c464d5e93dc55862d00d5478f8">is_bounded</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a bounded BDS. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="396bd79b5d57d54685d9c1b9d970c00e"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::contains_integer_point" ref="396bd79b5d57d54685d9c1b9d970c00e" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#396bd79b5d57d54685d9c1b9d970c00e">contains_integer_point</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains at least one integer point. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#d369744c43a49ebac904bc3e17de0478">constrains</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>.  <a href="#d369744c43a49ebac904bc3e17de0478"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="29212d49685544d8a3c71993bd30f467"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::OK" ref="29212d49685544d8a3c71993bd30f467" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#29212d49685544d8a3c71993bd30f467">OK</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> satisfies all its invariants. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Space-Dimension Preserving Member Functions that May Modify the BD_Shape</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#20814dec69b3a6602b70a9ad50db9b2a">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of constraint <code>c</code> to the system of bounded differences defining <code>*this</code>.  <a href="#20814dec69b3a6602b70a9ad50db9b2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#b464aec35ab7fb9fe0a8a50e05ad6f99">add_constraint_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of constraint <code>c</code> to the system of bounded differences defining <code>*this</code>.  <a href="#b464aec35ab7fb9fe0a8a50e05ad6f99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#cf4dc2de16f4a54ca03daa6ac1d31ce2">add_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of congruence <code>cg</code> to the system of congruences of <code>*this</code>.  <a href="#cf4dc2de16f4a54ca03daa6ac1d31ce2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#c20541d40c7629b278584406ce554eaf">add_congruence_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of congruence <code>cg</code> to the system of congruences of <code>*this</code>, minimizing the result.  <a href="#c20541d40c7629b278584406ce554eaf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#28b268e37d25a0cfa2b5bf39e85c758d">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of bounded differences defining <code>*this</code>.  <a href="#28b268e37d25a0cfa2b5bf39e85c758d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#535090b407c713681228d6ab2b835e36">add_recycled_constraints</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code>.  <a href="#535090b407c713681228d6ab2b835e36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#2626176104b632be36dc614e1d5536ea">add_constraints_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of bounded differences defining <code>*this</code>.  <a href="#2626176104b632be36dc614e1d5536ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#1cb059d74161d8458f18b02e33efe434">add_recycled_constraints_and_minimize</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code>, minimizing the result.  <a href="#1cb059d74161d8458f18b02e33efe434"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#0cc08ca5d72d5cf465eb7812ffbb156a">add_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>.  <a href="#0cc08ca5d72d5cf465eb7812ffbb156a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#8921d611a6be878bd8ad66a9af6f405e">add_congruences_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Behaves as <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#0cc08ca5d72d5cf465eb7812ffbb156a" title="Adds to *this constraints equivalent to the congruences in cgs.">add_congruences(const Congruence_System&amp;)</a>, but minimizes the resulting BD shape, returning <code>false</code> if and only if the result is empty.  <a href="#8921d611a6be878bd8ad66a9af6f405e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a85819690f928a46e3f437bfe629e976">add_recycled_congruences</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>.  <a href="#a85819690f928a46e3f437bfe629e976"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#794dad01f1995c73b887effa026ac32e">add_recycled_congruences_and_minimize</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Behaves as <code>add_recycled_congruences</code>, but minimizes the resulting BD shape, returning <code>false</code> if and only if the result is empty.  <a href="#794dad01f1995c73b887effa026ac32e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#8ede75fbd470fa30f11d4c02672883f5">refine_with_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of constraint <code>c</code> to refine the system of bounded differences defining <code>*this</code>.  <a href="#8ede75fbd470fa30f11d4c02672883f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ce010a880cb8574335f1be294907de89">refine_with_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of congruence <code>cg</code> to refine the system of bounded differences of <code>*this</code>.  <a href="#ce010a880cb8574335f1be294907de89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#8e13e7d3536de2745bc9e58a25b75b77">refine_with_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the constraints in <code>cs</code> to refine the system of bounded differences defining <code>*this</code>.  <a href="#8e13e7d3536de2745bc9e58a25b75b77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#35f19d0e7190c5a18aebc9ced95d554e">refine_with_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the congruences in <code>cgs</code> to refine the system of bounded differences defining <code>*this</code>.  <a href="#35f19d0e7190c5a18aebc9ced95d554e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#668cbd7cea86f47c4e2b303468083712">unconstrain</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>.  <a href="#668cbd7cea86f47c4e2b303468083712"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#93728c0f0afcd949c391940be93455a8">unconstrain</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_unconstrained)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>to_be_unconstrained</code>, assigning the result to <code>*this</code>.  <a href="#93728c0f0afcd949c391940be93455a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#86dd59c40a3c9867c2979ff24ba342c2">intersection_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>.  <a href="#86dd59c40a3c9867c2979ff24ba342c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#4882da0200ef4201f3adb0f6d7731526">intersection_assign_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>.  <a href="#4882da0200ef4201f3adb0f6d7731526"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#0442c5079b3de8dcac61c224ee7a2e6f">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the smallest BDS containing the union of <code>*this</code> and <code>y</code>.  <a href="#0442c5079b3de8dcac61c224ee7a2e6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a8e2f5b70168ac89a3f47639e7d9a4f9">upper_bound_assign_and_minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the smallest BDS containing the convex union of <code>*this</code> and <code>y</code>.  <a href="#a8e2f5b70168ac89a3f47639e7d9a4f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#4b7615a8ec5120dc083f368ecfe2d1da">upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned.  <a href="#4b7615a8ec5120dc083f368ecfe2d1da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#894e92407922be006a76577cf47b8589">difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the smallest BD shape containing the set difference of <code>*this</code> and <code>y</code>.  <a href="#894e92407922be006a76577cf47b8589"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#84a9c57aa31433a277d9be6b0077065a">simplify_using_context_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty.  <a href="#84a9c57aa31433a277d9be6b0077065a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#4e04c3a6c835332c31dfbb928b31144e">affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#4e04c3a6c835332c31dfbb928b31144e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#07cc48290e435dfb739fb565ff1aa3fa">affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#07cc48290e435dfb739fb565ff1aa3fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#e0ba85e8cab7e4e95ec001bde5bdd99d">generalized_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>.  <a href="#e0ba85e8cab7e4e95ec001bde5bdd99d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#0acf1147e3f81830606dec4cc8faddd4">generalized_affine_image</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>.  <a href="#0acf1147e3f81830606dec4cc8faddd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#988ff507806fa8126649f463ef6a1f31">generalized_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>.  <a href="#988ff507806fa8126649f463ef6a1f31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#79acafbe4f67eb7e2710287bcd60db96">generalized_affine_preimage</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>.  <a href="#79acafbe4f67eb7e2710287bcd60db96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#cda762f8c081fed2862260211618fce0">bounded_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">.  <a href="#cda762f8c081fed2862260211618fce0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#178a6a88143f44b43939d36024af6162">bounded_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">.  <a href="#178a6a88143f44b43939d36024af6162"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#5a66e6f883c7310ddbc312f78bb0970f">time_elapse_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>.  <a href="#5a66e6f883c7310ddbc312f78bb0970f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d80989353ea3738abdb6b605d27cc8fa"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::topological_closure_assign" ref="d80989353ea3738abdb6b605d27cc8fa" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#d80989353ea3738abdb6b605d27cc8fa">topological_closure_assign</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#9507085c5b0efd13c80f08a22b0f5529">CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>.  <a href="#9507085c5b0efd13c80f08a22b0f5529"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#24d2b69146ab1b2216e437468a818cea">CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, Iterator first, Iterator last, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>.  <a href="#24d2b69146ab1b2216e437468a818cea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#1a02b17cbccf348192f3e7f776b3b3fd">BHMZ05_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> of <code>*this</code> and <code>y</code>.  <a href="#1a02b17cbccf348192f3e7f776b3b3fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#eda87d46bc3b54b420a475934e0e1cb6">limited_BHMZ05_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#eda87d46bc3b54b420a475934e0e1cb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#df3cfc56df68bc8063e6e9eb3d0ad3f1">CC76_narrowing_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of restoring in <code>y</code> the constraints of <code>*this</code> that were lost by <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> applications.  <a href="#df3cfc56df68bc8063e6e9eb3d0ad3f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#2af430cd70ac416ca0907312b65812e6">limited_CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#2af430cd70ac416ca0907312b65812e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#5d71f71f50ba04fe5f810acf0cf1e294">H79_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#H79_widening">H79-widening</a> between <code>*this</code> and <code>y</code>.  <a href="#5d71f71f50ba04fe5f810acf0cf1e294"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="00b832cc0784b7b30f4d4a2f738a3032"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::widening_assign" ref="00b832cc0784b7b30f4d4a2f738a3032" args="(const BD_Shape &amp;y, unsigned *tp=0)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#00b832cc0784b7b30f4d4a2f738a3032">widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as H79_widening_assign(y, tp). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ccbd8986577794cea90edef63e859ab1">limited_H79_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#H79_widening">H79-widening</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#ccbd8986577794cea90edef63e859ab1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Dimension of the Vector Space</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#9c0703b2311336754e28a7f739b7e685">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new dimensions and embeds the old BDS into the new space.  <a href="#9c0703b2311336754e28a7f739b7e685"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#fa8a10ff4b09f8a87e3c558a39f5888e">add_space_dimensions_and_project</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new dimensions to the BDS and does not embed it in the new vector space.  <a href="#fa8a10ff4b09f8a87e3c558a39f5888e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#b0a670aeef72d808d620bbc33a5e8cd7">concatenate_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order.  <a href="#b0a670aeef72d808d620bbc33a5e8cd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#f8cd5fb701a14bc509872aeb3617b0b4">remove_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_removed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the specified dimensions.  <a href="#f8cd5fb701a14bc509872aeb3617b0b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#b054f67fb31ea4e860dd7c24c0b56676">remove_higher_space_dimensions</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> new_dimension)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the higher dimensions so that the resulting space will have dimension <code>new_dimension</code>.  <a href="#b054f67fb31ea4e860dd7c24c0b56676"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Partial_Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#c65231748a66ac5c074502cc8e652e10">map_space_dimensions</a> (const Partial_Function &amp;pfunc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>.  <a href="#c65231748a66ac5c074502cc8e652e10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#0badc932380dcb7f72ea50ca922d9d4b">expand_space_dimension</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>.  <a href="#0badc932380dcb7f72ea50ca922d9d4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#bb521f4ff8e2e40318bd06b0ff4d7617">fold_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;to_be_folded, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Folds the space dimensions in <code>to_be_folded</code> into <code>var</code>.  <a href="#bb521f4ff8e2e40318bd06b0ff4d7617"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e68d61763922cee018cbba3834b2085c"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::max_space_dimension" ref="e68d61763922cee018cbba3834b2085c" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#e68d61763922cee018cbba3834b2085c">max_space_dimension</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension that a BDS can handle. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e748c3f5082b158453fbb3ccf57c8f70"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::can_recycle_constraint_systems" ref="e748c3f5082b158453fbb3ccf57c8f70" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#e748c3f5082b158453fbb3ccf57c8f70">can_recycle_constraint_systems</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>false</code> indicating that this domain cannot recycle constraints. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8c89ddcd2fc4311af0e358477630d7d9"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::can_recycle_congruence_systems" ref="8c89ddcd2fc4311af0e358477630d7d9" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#8c89ddcd2fc4311af0e358477630d7d9">can_recycle_congruence_systems</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>false</code> indicating that this domain cannot recycle congruences. <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#c91aac77237c2405df039c4fcfa08ab0">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same BDS.  <a href="#c91aac77237c2405df039c4fcfa08ab0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#5049b85730d6720536be440753b11ed8">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;bds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#5049b85730d6720536be440753b11ed8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#cdc537f0aa5117fe3749d3c50b7dc4fd">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> aren't the same BDS.  <a href="#cdc537f0aa5117fe3749d3c50b7dc4fd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#f4b0f891a6911d7784216f537fa3e473">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#f4b0f891a6911d7784216f537fa3e473"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Temp , typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#221657648a7e456dba61589e37765cd4">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#221657648a7e456dba61589e37765cd4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#47a21a1c8a88c306877d15d4dbc697b4">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#47a21a1c8a88c306877d15d4dbc697b4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Temp , typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#e5c66812ab981ee2d1ab96ce218a7782">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#e5c66812ab981ee2d1ab96ce218a7782"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#d0a9267e420144cacfb867076d00a803">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code>.  <a href="#d0a9267e420144cacfb867076d00a803"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Temp , typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#8d6c186583503c4394603550b50edf59">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code>.  <a href="#8d6c186583503c4394603550b50edf59"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#f6351727d099ad178db8b8e742507f4c">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt; &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#f6351727d099ad178db8b8e742507f4c"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T&gt;<br>
 class Parma_Polyhedra_Library::BD_Shape&lt; T &gt;</h3>

A bounded difference shape. 
<p>
The class template BD_Shape&lt;T&gt; allows for the efficient representation of a restricted kind of <em>topologically closed</em> convex polyhedra called <em>bounded difference shapes</em> (BDSs, for short). The name comes from the fact that the closed affine half-spaces that characterize the polyhedron can be expressed by constraints of the form <img class="formulaInl" alt="$\pm x_i \leq k$" src="form_527.png"> or <img class="formulaInl" alt="$x_i - x_j \leq k$" src="form_528.png">, where the inhomogeneous term <img class="formulaInl" alt="$k$" src="form_286.png"> is a rational number.<p>
Based on the class template type parameter <code>T</code>, a family of extended numbers is built and used to approximate the inhomogeneous term of bounded differences. These extended numbers provide a representation for the value <img class="formulaInl" alt="$+\infty$" src="form_529.png">, as well as <em>rounding-aware</em> implementations for several arithmetic functions. The value of the type parameter <code>T</code> may be one of the following:<ul>
<li>a bounded precision integer type (e.g., <code>int32_t</code> or <code>int64_t</code>);</li><li>a bounded precision floating point type (e.g., <code>float</code> or <code>double</code>);</li><li>an unbounded integer or rational type, as provided by GMP (i.e., <code>mpz_class</code> or <code>mpq_class</code>).</li></ul>
<p>
The user interface for BDSs is meant to be as similar as possible to the one developed for the polyhedron class <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a>.<p>
The domain of BD shapes <em>optimally supports</em>:<ul>
<li>tautological and inconsistent constraints and congruences;</li><li>bounded difference constraints;</li><li>non-proper congruences (i.e., equalities) that are expressible as bounded-difference constraints.</li></ul>
<p>
Depending on the method, using a constraint or congruence that is not optimally supported by the domain will either raise an exception or result in a (possibly non-optimal) upward approximation.<p>
A constraint is a bounded difference if it has the form <p class="formulaDsp">
<img class="formulaDsp" alt="\[ a_i x_i - a_j x_j \relsym b \]" src="form_530.png">
<p>
 where <img class="formulaInl" alt="$\mathord{\relsym} \in \{ \leq, =, \geq \}$" src="form_531.png"> and <img class="formulaInl" alt="$a_i$" src="form_224.png">, <img class="formulaInl" alt="$a_j$" src="form_532.png">, <img class="formulaInl" alt="$b$" src="form_225.png"> are integer coefficients such that <img class="formulaInl" alt="$a_i = 0$" src="form_533.png">, or <img class="formulaInl" alt="$a_j = 0$" src="form_534.png">, or <img class="formulaInl" alt="$a_i = a_j$" src="form_535.png">. The user is warned that the above bounded difference <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> object will be mapped into a <em>correct</em> and <em>optimal</em> approximation that, depending on the expressive power of the chosen template argument <code>T</code>, may loose some precision. Also note that strict constraints are not bounded differences.<p>
For instance, a <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> object encoding <img class="formulaInl" alt="$3x - 3y \leq 1$" src="form_536.png"> will be approximated by:<ul>
<li><img class="formulaInl" alt="$x - y \leq 1$" src="form_537.png">, if <code>T</code> is a (bounded or unbounded) integer type;</li><li><img class="formulaInl" alt="$x - y \leq \frac{1}{3}$" src="form_538.png">, if <code>T</code> is the unbounded rational type <code>mpq_class</code>;</li><li><img class="formulaInl" alt="$x - y \leq k$" src="form_539.png">, where <img class="formulaInl" alt="$k > \frac{1}{3}$" src="form_540.png">, if <code>T</code> is a floating point type (having no exact representation for <img class="formulaInl" alt="$\frac{1}{3}$" src="form_541.png">).</li></ul>
<p>
On the other hand, depending from the context, a <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> object encoding <img class="formulaInl" alt="$3x - y \leq 1$" src="form_542.png"> will be either upward approximated (e.g., by safely ignoring it) or it will cause an exception.<p>
In the following examples it is assumed that the type argument <code>T</code> is one of the possible instances listed above and that variables <code>x</code>, <code>y</code> and <code>z</code> are defined (where they are used) as follows: <div class="fragment"><pre class="fragment">    Variable x(0);
    Variable y(1);
    Variable z(2);
</pre></div><p>
<dl class="user" compact><dt><b>Example 1</b></dt><dd>The following code builds a BDS corresponding to a cube in <img class="formulaInl" alt="$\Rset^3$" src="form_543.png">, given as a system of constraints: <div class="fragment"><pre class="fragment">    Constraint_System cs;
    cs.insert(x &gt;= 0);
    cs.insert(x &lt;= 1);
    cs.insert(y &gt;= 0);
    cs.insert(y &lt;= 1);
    cs.insert(z &gt;= 0);
    cs.insert(z &lt;= 1);
    BD_Shape&lt;T&gt; bd(cs);
</pre></div> Since only those constraints having the syntactic form of a <em>bounded difference</em> are optimally supported, the following code will throw an exception (caused by constraints 7, 8 and 9): <div class="fragment"><pre class="fragment">    Constraint_System cs;
    cs.insert(x &gt;= 0);
    cs.insert(x &lt;= 1);
    cs.insert(y &gt;= 0);
    cs.insert(y &lt;= 1);
    cs.insert(z &gt;= 0);
    cs.insert(z &lt;= 1);
    cs.insert(x + y &lt;= 0);      <span class="comment">// 7</span>
    cs.insert(x - z + x &gt;= 0);  <span class="comment">// 8</span>
    cs.insert(3*z - y &lt;= 1);    <span class="comment">// 9</span>
    BD_Shape&lt;T&gt; bd(cs);
</pre></div> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="ab3964a5c29992e6476852c9d246fe6f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="ab3964a5c29992e6476852c9d246fe6f" args="(dimension_type num_dimensions=0, Degenerate_Element kind=UNIVERSE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>num_dimensions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em> = <code>UNIVERSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a universe or empty BDS of the specified space dimension. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&nbsp;</td><td>The number of dimensions of the vector space enclosing the BDS;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>Specifies whether the universe or the empty BDS has to be built. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3825b4905d72422089bf28d3c95c2964"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="3825b4905d72422089bf28d3c95c2964" args="(const BD_Shape &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ordinary copy-constructor. 
<p>
The complexity argument is ignored. 
</div>
</div><p>
<a class="anchor" name="fad498a5802a7928442fd0d4b8c6183f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="fad498a5802a7928442fd0d4b8c6183f" args="(const BD_Shape&lt; U &gt; &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a conservative, upward approximation of <code>y</code>. 
<p>
The complexity argument is ignored. 
</div>
</div><p>
<a class="anchor" name="128b2fafec11e096e41f78710ba2ff0a"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="128b2fafec11e096e41f78710ba2ff0a" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a BDS from the system of constraints <code>cs</code>. 
<p>
The BDS inherits the space dimension of <code>cs</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>A system of constraints: constraints that are not <a class="el" href="main.html#Bounded_Difference_Shapes">bounded differences</a> are ignored (even though they may have contributed to the space dimension).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>cs</code> contains a constraint which is not optimally supported by the BD shape domain. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="15b3e8152862a6b98ecf1c4f4a142634"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="15b3e8152862a6b98ecf1c4f4a142634" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a BDS from a system of congruences. 
<p>
The BDS inherits the space dimension of <code>cgs</code> <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>A system of congruences: some elements may be safely ignored. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dbf2609849c95cfb7277df1edc69534f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="dbf2609849c95cfb7277df1edc69534f" args="(const Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a BDS from the system of generators <code>gs</code>. 
<p>
Builds the smallest BDS containing the polyhedron defined by <code>gs</code>. The BDS inherits the space dimension of <code>gs</code>.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of generators is not empty but has no points. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="faa5d6b3c1b3b83161b619c28c5f9936"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="faa5d6b3c1b3b83161b619c28c5f9936" args="(const Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a BDS from the polyhedron <code>ph</code>. 
<p>
Builds a BDS containing <code>ph</code> using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the BDS built is the smallest one containing <code>ph</code>. 
</div>
</div><p>
<a class="anchor" name="a07f93a685253eb04edab43b5ebd27b2"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="a07f93a685253eb04edab43b5ebd27b2" args="(const Box&lt; Interval &gt; &amp;box, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a BDS out of a box. 
<p>
The BDS inherits the space dimension of the box. The built BDS is the most precise BDS that includes the box.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The box representing the BDS to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>box</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="25a2d683973c6c6901e47c4fe90cf2b1"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="25a2d683973c6c6901e47c4fe90cf2b1" args="(const Grid &amp;grid, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a BDS out of a grid. 
<p>
The BDS inherits the space dimension of the grid. The built BDS is the most precise BDS that includes the grid.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>grid</em>&nbsp;</td><td>The grid used to build the BDS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>grid</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="df78023ac662762ffc808902b970597b"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="df78023ac662762ffc808902b970597b" args="(const Octagonal_Shape&lt; U &gt; &amp;os, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a BDS from an octagonal shape. 
<p>
The BDS inherits the space dimension of the octagonal shape. The built BDS is the most precise BDS that includes the octagonal shape.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The octagonal shape used to build the BDS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>os</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="79a586ca093d218e5603380ac0475717"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::bounds_from_above" ref="79a586ca093d218e5603380ac0475717" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::bounds_from_above           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="641b55dd6c26bce06bd8041b38aec873"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::bounds_from_below" ref="641b55dd6c26bce06bd8041b38aec873" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::bounds_from_below           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a7b3a5c12ea008b78eed88a621c1fab1"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::maximize" ref="a7b3a5c12ea008b78eed88a621c1fab1" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::maximize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if and only if the supremum is also the maximum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code> and <code>maximum</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="e61fdcc22d1e0fe43b94194f2eadaa1a"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::maximize" ref="e61fdcc22d1e0fe43b94194f2eadaa1a" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::maximize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if and only if the supremum is also the maximum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>When maximization succeeds, will be assigned the point or closure point where <code>expr</code> reaches its supremum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code>, <code>maximum</code> and <code>g</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="33daeddebffc6eb847edd92c3ba045dc"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::minimize" ref="33daeddebffc6eb847edd92c3ba045dc" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if and only if the infimum is also the minimum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code> and <code>minimum</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="1d00782cbab77286295552af7dba7ed8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::minimize" ref="1d00782cbab77286295552af7dba7ed8" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if and only if the infimum is also the minimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>When minimization succeeds, will be assigned a point or closure point where <code>expr</code> reaches its infimum value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code>, <code>minimum</code> and <code>g</code> are left untouched. 
</div>
</div><p>
<a class="anchor" name="6a3dd351c33d66250d2b4ac639768f07"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::contains" ref="6a3dd351c33d66250d2b4ac639768f07" args="(const BD_Shape &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8a87935278cb7b1290301e96cb82fcb1"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::strictly_contains" ref="8a87935278cb7b1290301e96cb82fcb1" args="(const BD_Shape &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::strictly_contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5e972fbb672e9b2faec34b949c9a2918"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::is_disjoint_from" ref="5e972fbb672e9b2faec34b949c9a2918" args="(const BD_Shape &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::is_disjoint_from           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>x</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="75188bcee0bfc88a4c8571acc04a1826"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::relation_with" ref="75188bcee0bfc88a4c8571acc04a1826" args="(const Constraint &amp;c) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::relation_with           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the relations holding between <code>*this</code> and the constraint <code>c</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4aef1a4f6e9bed5d473e98320401e0e5"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::relation_with" ref="4aef1a4f6e9bed5d473e98320401e0e5" args="(const Congruence &amp;cg) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::relation_with           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the relations holding between <code>*this</code> and the congruence <code>cg</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="16f61fdba7e14a67990a84e93be00efb"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::relation_with" ref="16f61fdba7e14a67990a84e93be00efb" args="(const Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::relation_with           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the relations holding between <code>*this</code> and the generator <code>g</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d369744c43a49ebac904bc3e17de0478"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::constrains" ref="d369744c43a49ebac904bc3e17de0478" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::constrains           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="20814dec69b3a6602b70a9ad50db9b2a"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_constraint" ref="20814dec69b3a6602b70a9ad50db9b2a" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_constraint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of constraint <code>c</code> to the system of bounded differences defining <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint to be added. If it is not a bounded difference, it will be simply ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible, or <code>c</code> is not optimally supported by the BD shape domain. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b464aec35ab7fb9fe0a8a50e05ad6f99"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_constraint_and_minimize" ref="b464aec35ab7fb9fe0a8a50e05ad6f99" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_constraint_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of constraint <code>c</code> to the system of bounded differences defining <code>*this</code>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint to be added. If it is not a bounded difference, it will be simply ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible, or <code>c</code> is not optimally supported by the BD shape domain.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cf4dc2de16f4a54ca03daa6ac1d31ce2"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_congruence" ref="cf4dc2de16f4a54ca03daa6ac1d31ce2" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_congruence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of congruence <code>cg</code> to the system of congruences of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&nbsp;</td><td>The congruence to be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible, or <code>cg</code> is not optimally supported by the BD shape domain. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c20541d40c7629b278584406ce554eaf"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_congruence_and_minimize" ref="c20541d40c7629b278584406ce554eaf" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_congruence_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a copy of congruence <code>cg</code> to the system of congruences of <code>*this</code>, minimizing the result. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&nbsp;</td><td>The congruence to be added.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible, or <code>cg</code> is not optimally supported by the BD shape domain.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="28b268e37d25a0cfa2b5bf39e85c758d"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_constraints" ref="28b268e37d25a0cfa2b5bf39e85c758d" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_constraints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the constraints in <code>cs</code> to the system of bounded differences defining <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints that will be added. Constraints that are not bounded differences will be simply ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible, or <code>cs</code> contains a constraint which is not optimally supported by the BD shape domain. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="535090b407c713681228d6ab2b835e36"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_recycled_constraints" ref="535090b407c713681228d6ab2b835e36" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_recycled_constraints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be added to <code>*this</code>. The constraints in <code>cs</code> may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible, or <code>cs</code> contains a constraint which is not optimally supported by the BD shape domain.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2626176104b632be36dc614e1d5536ea"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_constraints_and_minimize" ref="2626176104b632be36dc614e1d5536ea" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_constraints_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the constraints in <code>cs</code> to the system of bounded differences defining <code>*this</code>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints that will be added.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible, or <code>cs</code> contains a constraint which is not optimally supported by the BD shape domain.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1cb059d74161d8458f18b02e33efe434"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_recycled_constraints_and_minimize" ref="1cb059d74161d8458f18b02e33efe434" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_recycled_constraints_and_minimize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code>, minimizing the result. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be added to <code>*this</code>. The constraints in <code>cs</code> may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible, or <code>cs</code> contains a constraint which is not optimally supported by the BD shape domain.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cs</code> upon successful or exceptional return is that it can be safely destroyed.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0cc08ca5d72d5cf465eb7812ffbb156a"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_congruences" ref="0cc08ca5d72d5cf465eb7812ffbb156a" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_congruences           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>Contains the congruences that will be added to the system of constraints of <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, or <code>cgs</code> contains a congruence which is not optimally supported by the BD shape domain. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8921d611a6be878bd8ad66a9af6f405e"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_congruences_and_minimize" ref="8921d611a6be878bd8ad66a9af6f405e" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_congruences_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Behaves as <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#0cc08ca5d72d5cf465eb7812ffbb156a" title="Adds to *this constraints equivalent to the congruences in cgs.">add_congruences(const Congruence_System&amp;)</a>, but minimizes the resulting BD shape, returning <code>false</code> if and only if the result is empty. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a85819690f928a46e3f437bfe629e976"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_recycled_congruences" ref="a85819690f928a46e3f437bfe629e976" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_recycled_congruences           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>Contains the congruences that will be added to the system of constraints of <code>*this</code>. Its elements may be recycled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, or <code>cgs</code> contains a congruence which is not optimally supported by the BD shape domain.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="794dad01f1995c73b887effa026ac32e"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_recycled_congruences_and_minimize" ref="794dad01f1995c73b887effa026ac32e" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_recycled_congruences_and_minimize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Behaves as <code>add_recycled_congruences</code>, but minimizes the resulting BD shape, returning <code>false</code> if and only if the result is empty. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ede75fbd470fa30f11d4c02672883f5"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::refine_with_constraint" ref="8ede75fbd470fa30f11d4c02672883f5" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::refine_with_constraint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of constraint <code>c</code> to refine the system of bounded differences defining <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint. If it is not a bounded difference, it will be ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ce010a880cb8574335f1be294907de89"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::refine_with_congruence" ref="ce010a880cb8574335f1be294907de89" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::refine_with_congruence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of congruence <code>cg</code> to refine the system of bounded differences of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&nbsp;</td><td>The congruence. If it is not a bounded difference equality, it will be ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8e13e7d3536de2745bc9e58a25b75b77"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::refine_with_constraints" ref="8e13e7d3536de2745bc9e58a25b75b77" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::refine_with_constraints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of the constraints in <code>cs</code> to refine the system of bounded differences defining <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be used. Constraints that are not bounded differences are ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="35f19d0e7190c5a18aebc9ced95d554e"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::refine_with_congruences" ref="35f19d0e7190c5a18aebc9ced95d554e" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::refine_with_congruences           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a copy of the congruences in <code>cgs</code> to refine the system of bounded differences defining <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruence system to be used. Congruences that are not bounded difference equalities are ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="668cbd7cea86f47c4e2b303468083712"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::unconstrain" ref="668cbd7cea86f47c4e2b303468083712" args="(Variable var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::unconstrain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The space dimension that will be unconstrained.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="93728c0f0afcd949c391940be93455a8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::unconstrain" ref="93728c0f0afcd949c391940be93455a8" args="(const Variables_Set &amp;to_be_unconstrained)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::unconstrain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_unconstrained</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>to_be_unconstrained</code>, assigning the result to <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_unconstrained</em>&nbsp;</td><td>The set of space dimension that will be unconstrained.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_removed</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="86dd59c40a3c9867c2979ff24ba342c2"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::intersection_assign" ref="86dd59c40a3c9867c2979ff24ba342c2" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::intersection_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4882da0200ef4201f3adb0f6d7731526"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::intersection_assign_and_minimize" ref="4882da0200ef4201f3adb0f6d7731526" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::intersection_assign_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0442c5079b3de8dcac61c224ee7a2e6f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::upper_bound_assign" ref="0442c5079b3de8dcac61c224ee7a2e6f" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::upper_bound_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the smallest BDS containing the union of <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a8e2f5b70168ac89a3f47639e7d9a4f9"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::upper_bound_assign_and_minimize" ref="a8e2f5b70168ac89a3f47639e7d9a4f9" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::upper_bound_assign_and_minimize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the smallest BDS containing the convex union of <code>*this</code> and <code>y</code>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the result is empty.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>See <a class="el" href="main.html#A_Note_on_the_Implementation_of_the_Operators">A Note on the Implementation of the Operators</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4b7615a8ec5120dc083f368ecfe2d1da"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::upper_bound_assign_if_exact" ref="4b7615a8ec5120dc083f368ecfe2d1da" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::upper_bound_assign_if_exact           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="894e92407922be006a76577cf47b8589"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::difference_assign" ref="894e92407922be006a76577cf47b8589" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::difference_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the smallest BD shape containing the set difference of <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="84a9c57aa31433a277d9be6b0077065a"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::simplify_using_context_assign" ref="84a9c57aa31433a277d9be6b0077065a" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::simplify_using_context_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4e04c3a6c835332c31dfbb928b31144e"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::affine_image" ref="4e04c3a6c835332c31dfbb928b31144e" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is assigned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="07cc48290e435dfb739fb565ff1aa3fa"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::affine_preimage" ref="07cc48290e435dfb739fb565ff1aa3fa" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is substituted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e0ba85e8cab7e4e95ec001bde5bdd99d"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::generalized_affine_image" ref="e0ba85e8cab7e4e95ec001bde5bdd99d" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::generalized_affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine transfer function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0acf1147e3f81830606dec4cc8faddd4"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::generalized_affine_image" ref="0acf1147e3f81830606dec4cc8faddd4" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::generalized_affine_image           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="988ff507806fa8126649f463ef6a1f31"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::generalized_affine_preimage" ref="988ff507806fa8126649f463ef6a1f31" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::generalized_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_641.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine transfer function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="79acafbe4f67eb7e2710287bcd60db96"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::generalized_affine_preimage" ref="79acafbe4f67eb7e2710287bcd60db96" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::generalized_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_642.png">, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_299.png"> is the relation symbol encoded by <code>relsym</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cda762f8c081fed2862260211618fce0"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::bounded_affine_image" ref="cda762f8c081fed2862260211618fce0" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::bounded_affine_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="178a6a88143f44b43939d36024af6162"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::bounded_affine_preimage" ref="178a6a88143f44b43939d36024af6162" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::bounded_affine_preimage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_643.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5a66e6f883c7310ddbc312f78bb0970f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::time_elapse_assign" ref="5a66e6f883c7310ddbc312f78bb0970f" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::time_elapse_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9507085c5b0efd13c80f08a22b0f5529"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::CC76_extrapolation_assign" ref="9507085c5b0efd13c80f08a22b0f5529" args="(const BD_Shape &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::CC76_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="24d2b69146ab1b2216e437468a818cea"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::CC76_extrapolation_assign" ref="24d2b69146ab1b2216e437468a818cea" args="(const BD_Shape &amp;y, Iterator first, Iterator last, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::CC76_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>An iterator referencing the first stop-point.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>An iterator referencing one past the last stop-point.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1a02b17cbccf348192f3e7f776b3b3fd"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BHMZ05_widening_assign" ref="1a02b17cbccf348192f3e7f776b3b3fd" args="(const BD_Shape &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::BHMZ05_widening_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> of <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="eda87d46bc3b54b420a475934e0e1cb6"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::limited_BHMZ05_extrapolation_assign" ref="eda87d46bc3b54b420a475934e0e1cb6" args="(const BD_Shape &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::limited_BHMZ05_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Improves the result of the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened BDS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a strict inequality. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="df3cfc56df68bc8063e6e9eb3d0ad3f1"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::CC76_narrowing_assign" ref="df3cfc56df68bc8063e6e9eb3d0ad3f1" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::CC76_narrowing_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of restoring in <code>y</code> the constraints of <code>*this</code> that were lost by <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> applications. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A BDS that <em>must</em> contain <code>*this</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>As was the case for widening operators, the argument <code>y</code> is meant to denote the value computed in the previous iteration step, whereas <code>*this</code> denotes the value computed in the current iteration step (in the <em>decreasing</em> iteration sequence). Hence, the call <code>x.CC76_narrowing_assign(y)</code> will assign to <code>x</code> the result of the computation <img class="formulaInl" alt="$\mathtt{y} \Delta \mathtt{x}$" src="form_668.png">. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2af430cd70ac416ca0907312b65812e6"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::limited_CC76_extrapolation_assign" ref="2af430cd70ac416ca0907312b65812e6" args="(const BD_Shape &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::limited_CC76_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Improves the result of the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened BDS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a strict inequality. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5d71f71f50ba04fe5f810acf0cf1e294"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::H79_widening_assign" ref="5d71f71f50ba04fe5f810acf0cf1e294" args="(const BD_Shape &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::H79_widening_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#H79_widening">H79-widening</a> between <code>*this</code> and <code>y</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ccbd8986577794cea90edef63e859ab1"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::limited_H79_extrapolation_assign" ref="ccbd8986577794cea90edef63e859ab1" args="(const BD_Shape &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::limited_H79_extrapolation_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Improves the result of the <a class="el" href="main.html#H79_widening">H79-widening</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened BDS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9c0703b2311336754e28a7f739b7e685"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_space_dimensions_and_embed" ref="9c0703b2311336754e28a7f739b7e685" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_space_dimensions_and_embed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <code>m</code> new dimensions and embeds the old BDS into the new space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of dimensions to add.</td></tr>
  </table>
</dl>
The new dimensions will be those having the highest indexes in the new BDS, which is defined by a system of bounded differences in which the variables running through the new dimensions are unconstrained. For instance, when starting from the BDS <img class="formulaInl" alt="$\cB \sseq \Rset^2$" src="form_669.png"> and adding a third dimension, the result will be the BDS <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, z)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cB \,\bigr\}. \]" src="form_670.png">
<p>
 
</div>
</div><p>
<a class="anchor" name="fa8a10ff4b09f8a87e3c558a39f5888e"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_space_dimensions_and_project" ref="fa8a10ff4b09f8a87e3c558a39f5888e" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_space_dimensions_and_project           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <code>m</code> new dimensions to the BDS and does not embed it in the new vector space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of dimensions to add.</td></tr>
  </table>
</dl>
The new dimensions will be those having the highest indexes in the new BDS, which is defined by a system of bounded differences in which the variables running through the new dimensions are all constrained to be equal to 0. For instance, when starting from the BDS <img class="formulaInl" alt="$\cB \sseq \Rset^2$" src="form_669.png"> and adding a third dimension, the result will be the BDS <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, 0)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cB \,\bigr\}. \]" src="form_671.png">
<p>
 
</div>
</div><p>
<a class="anchor" name="b0a670aeef72d808d620bbc33a5e8cd7"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::concatenate_assign" ref="b0a670aeef72d808d620bbc33a5e8cd7" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::concatenate_assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the concatenation would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#e68d61763922cee018cbba3834b2085c" title="Returns the maximum space dimension that a BDS can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f8cd5fb701a14bc509872aeb3617b0b4"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::remove_space_dimensions" ref="f8cd5fb701a14bc509872aeb3617b0b4" args="(const Variables_Set &amp;to_be_removed)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::remove_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_removed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all the specified dimensions. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_removed</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the dimensions to be removed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_removed</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b054f67fb31ea4e860dd7c24c0b56676"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::remove_higher_space_dimensions" ref="b054f67fb31ea4e860dd7c24c0b56676" args="(dimension_type new_dimension)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::remove_higher_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>new_dimension</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the higher dimensions so that the resulting space will have dimension <code>new_dimension</code>. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>new_dimension</code> is greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c65231748a66ac5c074502cc8e652e10"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::map_space_dimensions" ref="c65231748a66ac5c074502cc8e652e10" args="(const Partial_Function &amp;pfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Partial_Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::map_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const Partial_Function &amp;&nbsp;</td>
          <td class="paramname"> <em>pfunc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfunc</em>&nbsp;</td><td>The partial function specifying the destiny of each dimension.</td></tr>
  </table>
</dl>
The template class Partial_Function must provide the following methods. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> has_empty_codomain() const
</pre></div> returns <code>true</code> if and only if the represented partial function has an empty co-domain (i.e., it is always undefined). The <code>has_empty_codomain()</code> method will always be called before the methods below. However, if <code>has_empty_codomain()</code> returns <code>true</code>, none of the functions below will be called. <div class="fragment"><pre class="fragment">      <a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> max_in_codomain() const
</pre></div> returns the maximum value that belongs to the co-domain of the partial function. <div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> maps(<a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i, <a class="code" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a>&amp; j) <span class="keyword">const</span>
</pre></div> Let <img class="formulaInl" alt="$f$" src="form_323.png"> be the represented function and <img class="formulaInl" alt="$k$" src="form_286.png"> be the value of <code>i</code>. If <img class="formulaInl" alt="$f$" src="form_323.png"> is defined in <img class="formulaInl" alt="$k$" src="form_286.png">, then <img class="formulaInl" alt="$f(k)$" src="form_646.png"> is assigned to <code>j</code> and <code>true</code> is returned. If <img class="formulaInl" alt="$f$" src="form_323.png"> is undefined in <img class="formulaInl" alt="$k$" src="form_286.png">, then <code>false</code> is returned.<p>
The result is undefined if <code>pfunc</code> does not encode a partial function with the properties described in the <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">specification of the mapping operator</a>. 
</div>
</div><p>
<a class="anchor" name="0badc932380dcb7f72ea50ca922d9d4b"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::expand_space_dimension" ref="0badc932380dcb7f72ea50ca922d9d4b" args="(Variable var, dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::expand_space_dimension           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension to be replicated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of replicas to be created.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> does not correspond to a dimension of the vector space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#e68d61763922cee018cbba3834b2085c" title="Returns the maximum space dimension that a BDS can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
</dl>
If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png">, with <img class="formulaInl" alt="$n > 0$" src="form_167.png">, and <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_135.png">, then the <img class="formulaInl" alt="$k$" src="form_286.png">-th space dimension is <a class="el" href="main.html#expand_space_dimension">expanded</a> to <code>m</code> new space dimensions <img class="formulaInl" alt="$n$" src="form_0.png">, <img class="formulaInl" alt="$n+1$" src="form_168.png">, <img class="formulaInl" alt="$\dots$" src="form_647.png">, <img class="formulaInl" alt="$n+m-1$" src="form_170.png">. 
</div>
</div><p>
<a class="anchor" name="bb521f4ff8e2e40318bd06b0ff4d7617"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::fold_space_dimensions" ref="bb521f4ff8e2e40318bd06b0ff4d7617" args="(const Variables_Set &amp;to_be_folded, Variable var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::fold_space_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_be_folded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Folds the space dimensions in <code>to_be_folded</code> into <code>var</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_be_folded</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be folded;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension that is the destination of the folding operation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>var</code> or with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>to_be_folded</code>. Also thrown if <code>var</code> is contained in <code>to_be_folded</code>.</td></tr>
  </table>
</dl>
If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png">, with <img class="formulaInl" alt="$n > 0$" src="form_167.png">, <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_135.png">, <code>to_be_folded</code> is a set of variables whose maximum space dimension is also less than or equal to <img class="formulaInl" alt="$n$" src="form_0.png">, and <code>var</code> is not a member of <code>to_be_folded</code>, then the space dimensions corresponding to variables in <code>to_be_folded</code> are <a class="el" href="main.html#fold_space_dimensions">folded</a> into the <img class="formulaInl" alt="$k$" src="form_286.png">-th space dimension. 
</div>
</div><p>
<a class="anchor" name="e0a1b4b4a344cad01c58e8e006a7ff16"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::hash_code" ref="e0a1b4b4a344cad01c58e8e006a7ff16" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::hash_code           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a 32-bit hash code for <code>*this</code>. 
<p>
If <code>x</code> and <code>y</code> are such that <code>x == y</code>, then <code>x.hash_code() == y.hash_code()</code>. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="c91aac77237c2405df039c4fcfa08ab0"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::operator==" ref="c91aac77237c2405df039c4fcfa08ab0" args="(const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same BDS. 
<p>
Note that <code>x</code> and <code>y</code> may be dimension-incompatible shapes: in this case, the value <code>false</code> is returned.
</div>
</div><p>
<a class="anchor" name="5049b85730d6720536be440753b11ed8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::operator&lt;&lt;" ref="5049b85730d6720536be440753b11ed8" args="(std::ostream &amp;s, const BD_Shape&lt; T &gt; &amp;bds)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output operator. 
<p>
Writes a textual representation of <code>bds</code> on <code>s:</code> <code>false</code> is written if <code>bds</code> is an empty polyhedron; <code>true</code> is written if <code>bds</code> is the universe polyhedron; a system of constraints defining <code>bds</code> is written otherwise, all constraints separated by ", ".
</div>
</div><p>
<a class="anchor" name="cdc537f0aa5117fe3749d3c50b7dc4fd"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::operator!=" ref="cdc537f0aa5117fe3749d3c50b7dc4fd" args="(const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if and only if <code>x</code> and <code>y</code> aren't the same BDS. 
<p>
Note that <code>x</code> and <code>y</code> may be dimension-incompatible shapes: in this case, the value <code>true</code> is returned.
</div>
</div><p>
<a class="anchor" name="f4b0f891a6911d7784216f537fa3e473"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::rectilinear_distance_assign" ref="f4b0f891a6911d7784216f537fa3e473" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. 
<p>
If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.<p>
If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.
</div>
</div><p>
<a class="anchor" name="221657648a7e456dba61589e37765cd4"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::rectilinear_distance_assign" ref="221657648a7e456dba61589e37765cd4" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. 
<p>
If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.
</div>
</div><p>
<a class="anchor" name="47a21a1c8a88c306877d15d4dbc697b4"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::euclidean_distance_assign" ref="47a21a1c8a88c306877d15d4dbc697b4" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the euclidean distance between <code>x</code> and <code>y</code>. 
<p>
If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.<p>
If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.
</div>
</div><p>
<a class="anchor" name="e5c66812ab981ee2d1ab96ce218a7782"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::euclidean_distance_assign" ref="e5c66812ab981ee2d1ab96ce218a7782" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the euclidean distance between <code>x</code> and <code>y</code>. 
<p>
If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.
</div>
</div><p>
<a class="anchor" name="d0a9267e420144cacfb867076d00a803"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::l_infinity_distance_assign" ref="d0a9267e420144cacfb867076d00a803" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code>. 
<p>
If the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.<p>
If the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.
</div>
</div><p>
<a class="anchor" name="8d6c186583503c4394603550b50edf59"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::l_infinity_distance_assign" ref="8d6c186583503c4394603550b50edf59" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code>. 
<p>
If the <img class="formulaInl" alt="$L_\infty$" src="form_619.png"> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.<p>
The direction of the approximation is specified by <code>dir</code>.<p>
All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.
</div>
</div><p>
<a class="anchor" name="f6351727d099ad178db8b8e742507f4c"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::swap" ref="f6351727d099ad178db8b8e742507f4c" args="(Parma_Polyhedra_Library::BD_Shape&lt; T &gt; &amp;x, Parma_Polyhedra_Library::BD_Shape&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specializes <code>std::swap</code>. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 18 07:13:19 2009 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
