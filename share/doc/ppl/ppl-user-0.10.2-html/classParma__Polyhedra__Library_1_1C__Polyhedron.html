<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PPL: Parma_Polyhedra_Library::C_Polyhedron Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::C_Polyhedron Class Reference<br>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::C_Polyhedron" --><!-- doxytag: inherits="Parma_Polyhedra_Library::Polyhedron" -->A closed convex polyhedron.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ppl.hh&gt;</code>
<p>
Inherits <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Parma_Polyhedra_Library::Polyhedron</a>.
<p>

<p>
<a href="classParma__Polyhedra__Library_1_1C__Polyhedron-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#4b841053fdf5718c17a018ff650b550a">C_Polyhedron</a> (<a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions=0, <a class="el" href="group__PPL__CXX__interface.html#g616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind=UNIVERSE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds either the universe or the empty C polyhedron.  <a href="#4b841053fdf5718c17a018ff650b550a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#33d58476db85f48e4ad680c69bca524f">C_Polyhedron</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a C polyhedron from a system of constraints.  <a href="#33d58476db85f48e4ad680c69bca524f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#2b220dabc613a89a062968101429e58c">C_Polyhedron</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a C polyhedron recycling a system of constraints.  <a href="#2b220dabc613a89a062968101429e58c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#c98ed1378829f72aee73c40dff16f269">C_Polyhedron</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a C polyhedron from a system of generators.  <a href="#c98ed1378829f72aee73c40dff16f269"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#8a6c3f01edb04382620066f17b63b20c">C_Polyhedron</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a C polyhedron recycling a system of generators.  <a href="#8a6c3f01edb04382620066f17b63b20c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#e46f7a91b9fac1a62ef875ec5c72aab6">C_Polyhedron</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a C polyhedron from a system of congruences.  <a href="#e46f7a91b9fac1a62ef875ec5c72aab6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#c3126925bcd3349b150771d52c19639d">C_Polyhedron</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a C polyhedron recycling a system of congruences.  <a href="#c3126925bcd3349b150771d52c19639d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#9720487deabf813a31afd4e9cfe695aa">C_Polyhedron</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a C polyhedron representing the topological closure of the NNC polyhedron <code>y</code>.  <a href="#9720487deabf813a31afd4e9cfe695aa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#68e25304a250a8c739927adfb90043d1">C_Polyhedron</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a C polyhedron out of a box.  <a href="#68e25304a250a8c739927adfb90043d1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#e9a2b78be6811d666fb9d145078d796d">C_Polyhedron</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;bd, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a C polyhedron out of a BD shape.  <a href="#e9a2b78be6811d666fb9d145078d796d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#6b286c9e001bf126a0ab85aac675786d">C_Polyhedron</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;os, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a C polyhedron out of an octagonal shape.  <a href="#6b286c9e001bf126a0ab85aac675786d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#c86d25d06285c9a2e890770fed084574">C_Polyhedron</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;grid, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a C polyhedron out of a grid.  <a href="#c86d25d06285c9a2e890770fed084574"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#faae25a26dbecf9341c7fb2c2575f81f">C_Polyhedron</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy-constructor.  <a href="#faae25a26dbecf9341c7fb2c2575f81f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="59d06e9b429faef7a632d58e4a0b12bd"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::operator=" ref="59d06e9b429faef7a632d58e4a0b12bd" args="(const C_Polyhedron &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#59d06e9b429faef7a632d58e4a0b12bd">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The assignment operator. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f581bf46ab0488f444977453ba2ea2d"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::operator=" ref="6f581bf46ab0488f444977453ba2ea2d" args="(const NNC_Polyhedron &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#6f581bf46ab0488f444977453ba2ea2d">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the topological closure of the NNC polyhedron <code>y</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="09726be54fe2a591787de59eeffdd2ea"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::~C_Polyhedron" ref="09726be54fe2a591787de59eeffdd2ea" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#09726be54fe2a591787de59eeffdd2ea">~C_Polyhedron</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#5eb7f86790ada6549123a0225d68a4de">poly_hull_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the poly-hull of <code>*this</code> and <code>y</code> is exact it is assigned to <code>*this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned.  <a href="#5eb7f86790ada6549123a0225d68a4de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6424da8931d774f6a2e403c1e2f0d09a"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::upper_bound_assign_if_exact" ref="6424da8931d774f6a2e403c1e2f0d09a" args="(const C_Polyhedron &amp;y)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#6424da8931d774f6a2e403c1e2f0d09a">upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as poly_hull_assign_if_exact(y). <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A closed convex polyhedron. 
<p>
An object of the class <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> represents a <em>topologically closed</em> convex polyhedron in the vector space <img class="formulaInl" alt="$\Rset^n$" src="form_16.png">.<p>
When building a closed polyhedron starting from a system of constraints, an exception is thrown if the system contains a <em>strict inequality</em> constraint. Similarly, an exception is thrown when building a closed polyhedron starting from a system of generators containing a <em>closure point</em>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Such an exception will be obtained even if the system of constraints (resp., generators) actually defines a topologically closed subset of the vector space, i.e., even if all the strict inequalities (resp., closure points) in the system happen to be redundant with respect to the system obtained by removing all the strict inequality constraints (resp., all the closure points). In contrast, when building a closed polyhedron starting from an object of the class <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html" title="A not necessarily closed convex polyhedron.">NNC_Polyhedron</a>, the precise topological closure test will be performed. </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="4b841053fdf5718c17a018ff650b550a"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="4b841053fdf5718c17a018ff650b550a" args="(dimension_type num_dimensions=0, Degenerate_Element kind=UNIVERSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>num_dimensions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em> = <code>UNIVERSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds either the universe or the empty C polyhedron. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&nbsp;</td><td>The number of dimensions of the vector space enclosing the C polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>Specifies whether a universe or an empty C polyhedron should be built.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension.</td></tr>
  </table>
</dl>
Both parameters are optional: by default, a 0-dimension space universe C polyhedron is built. 
</div>
</div><p>
<a class="anchor" name="33d58476db85f48e4ad680c69bca524f"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="33d58476db85f48e4ad680c69bca524f" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a C polyhedron from a system of constraints. 
<p>
The polyhedron inherits the space dimension of the constraint system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints defining the polyhedron.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of constraints contains strict inequalities. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2b220dabc613a89a062968101429e58c"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="2b220dabc613a89a062968101429e58c" args="(Constraint_System &amp;cs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a C polyhedron recycling a system of constraints. 
<p>
The polyhedron inherits the space dimension of the constraint system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints defining the polyhedron. It is not declared <code>const</code> because its data-structures may be recycled to build the polyhedron.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of constraints contains strict inequalities. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c98ed1378829f72aee73c40dff16f269"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="c98ed1378829f72aee73c40dff16f269" args="(const Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a C polyhedron from a system of generators. 
<p>
The polyhedron inherits the space dimension of the generator system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The system of generators defining the polyhedron.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of generators is not empty but has no points, or if it contains closure points. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8a6c3f01edb04382620066f17b63b20c"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="8a6c3f01edb04382620066f17b63b20c" args="(Generator_System &amp;gs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a C polyhedron recycling a system of generators. 
<p>
The polyhedron inherits the space dimension of the generator system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The system of generators defining the polyhedron. It is not declared <code>const</code> because its data-structures may be recycled to build the polyhedron.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of generators is not empty but has no points, or if it contains closure points. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e46f7a91b9fac1a62ef875ec5c72aab6"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="e46f7a91b9fac1a62ef875ec5c72aab6" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a C polyhedron from a system of congruences. 
<p>
The polyhedron inherits the space dimension of the congruence system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences defining the polyhedron. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c3126925bcd3349b150771d52c19639d"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="c3126925bcd3349b150771d52c19639d" args="(Congruence_System &amp;cgs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a C polyhedron recycling a system of congruences. 
<p>
The polyhedron inherits the space dimension of the congruence system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences defining the polyhedron. It is not declared <code>const</code> because its data-structures may be recycled to build the polyhedron.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9720487deabf813a31afd4e9cfe695aa"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="9720487deabf813a31afd4e9cfe695aa" args="(const NNC_Polyhedron &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a C polyhedron representing the topological closure of the NNC polyhedron <code>y</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The NNC polyhedron to be used;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="68e25304a250a8c739927adfb90043d1"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="68e25304a250a8c739927adfb90043d1" args="(const Box&lt; Interval &gt; &amp;box, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a C polyhedron out of a box. 
<p>
The polyhedron inherits the space dimension of the box and is the most precise that includes the box. The algorithm used has polynomial complexity.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The box representing the polyhedron to be approximated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>box</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e9a2b78be6811d666fb9d145078d796d"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="e9a2b78be6811d666fb9d145078d796d" args="(const BD_Shape&lt; U &gt; &amp;bd, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a C polyhedron out of a BD shape. 
<p>
The polyhedron inherits the space dimension of the BDS and is the most precise that includes the BDS.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bd</em>&nbsp;</td><td>The BDS used to build the polyhedron.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6b286c9e001bf126a0ab85aac675786d"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="6b286c9e001bf126a0ab85aac675786d" args="(const Octagonal_Shape&lt; U &gt; &amp;os, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a C polyhedron out of an octagonal shape. 
<p>
The polyhedron inherits the space dimension of the octagonal shape and is the most precise that includes the octagonal shape.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The octagonal shape used to build the polyhedron.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c86d25d06285c9a2e890770fed084574"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="c86d25d06285c9a2e890770fed084574" args="(const Grid &amp;grid, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a C polyhedron out of a grid. 
<p>
The polyhedron inherits the space dimension of the grid and is the most precise that includes the grid.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>grid</em>&nbsp;</td><td>The grid used to build the polyhedron.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="faae25a26dbecf9341c7fb2c2575f81f"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron" ref="faae25a26dbecf9341c7fb2c2575f81f" args="(const C_Polyhedron &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::C_Polyhedron::C_Polyhedron           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#g113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ordinary copy-constructor. 
<p>
The complexity argument is ignored. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5eb7f86790ada6549123a0225d68a4de"></a><!-- doxytag: member="Parma_Polyhedra_Library::C_Polyhedron::poly_hull_assign_if_exact" ref="5eb7f86790ada6549123a0225d68a4de" args="(const C_Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::C_Polyhedron::poly_hull_assign_if_exact           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the poly-hull of <code>*this</code> and <code>y</code> is exact it is assigned to <code>*this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 18 07:13:19 2009 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
